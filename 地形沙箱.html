<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="åœ°å½¢æ²™ç®±">
    <link rel="apple-touch-icon" href="åœ–æ¨™URL.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ°å½¢æ²™ç®±</title>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <style>
    canvas {
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .tool-button {
        cursor: pointer;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }
    .mobile-only {
        display: none;
    }

    @media (max-width: 768px) {
        .mobile-only {
            display: block;
        }
    }

    #developer-info {
       position: fixed;
       top: 10px;
       left: 10px;
       z-index: 1001; /* ç¢ºä¿æ–‡å­—åœ¨å…¶ä»–å…ƒç´ ä¹‹ä¸Š */
       font-size: 12px;
       color: rgba(0, 0, 0, 0.6);
       pointer-events: none; /* é˜²æ­¢æ–‡å­—é®æ“‹å…¶ä»–å…ƒç´ çš„äº‹ä»¶ */
      }

    #mobile-controls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 1000;
    }

    #joystick-container {
        width: 120px;
        height: 120px;
        position: relative;
    }

    #joystick-base {
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        position: relative;
    }

    #joystick-knob {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .terrain-toolbar {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 45px; /* èˆ‡ drawing-toolbar ç›¸åŒ */
        }
        .terrain-toolbar .tool-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .terrain-toolbar .tool-group:not(:last-child),
        .drawing-toolbar .tool-group:not(:last-child) {
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .tool-button {
             width: 35px;
             height: 35px;
             padding: 0;
             background: #4CAF50;
             border: none;
             border-radius: 4px;
             color: white;
             cursor: pointer;
             transition: all 0.3s;
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative;
             font-size: 24px; /*  èª¿æ•´æ­¤æ•¸å€¼ä»¥æ”¹è®Š emoji å¤§å° */
         }

        .tool-button:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        .tool-button.active {
            background: #367c39;
            transform: scale(1.1);
        }

        .tool-tooltip {
            position: absolute;
            left: 45px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1001;
            pointer-events: none;
        }
        .tool-button:hover .tool-tooltip {
            opacity: 1;
        }
        .status-bar {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 12px;
        }
        .settings-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
        }
        .settings-panel.show {
            display: block;
        }
        .drawing-toolbar {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 45px;
        }

        .drawing-toolbar .tool-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .terrain-toolbar .tool-group:not(:last-child),
        .drawing-toolbar .tool-group:not(:last-child) {
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .color-btn {
            width: 35px;
            height: 35px;
            padding: 0;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-btn.active {
            border-color: #000;
            transform: scale(1.1);
        }
        .measurement-toolbar {
            position: fixed;
            top: 50%;
            left: 20px; /* ä¿®æ”¹é€™è£¡ */
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 45px;
        }

        .map-drawing-toolbar {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
            flex-direction: column;
            gap: 10px;
            width: 45px;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .ruler {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #000;
            cursor: move;
            z-index: 3;
        }

        .protractor-tool {
            position: fixed;
            width: 300px; /* ç¢ºä¿ HTML å’Œ CSS å°ºå¯¸ä¸€è‡´ */
            height: 300px;
            border: 2px solid #000;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0); /* å®Œå…¨é€æ˜ */
            cursor: move;
            z-index: 1002; /* ç¢ºä¿åœ¨å…¶ä»–å…ƒç´ ä¹‹ä¸Š */
            touch-action: none; /* æ·»åŠ é€™è¡Œ */
            -webkit-user-select: none; /* æ·»åŠ é€™è¡Œ */
            user-select: none; /* æ·»åŠ é€™è¡Œ */
        }

        .protractor-tool.hidden {
            display: none;
        }

        /* ç¸±å‰–é¢é¢æ¿æ¨£å¼ */
        .profile-panel {
            position: fixed;
            /* ç§»é™¤åº•éƒ¨å›ºå®šä½ç½® */
            /* bottom: 20px; */
            /* left: 50%; */
            /* transform: translateX(-50%); */
            width: 80%;
            max-width: 800px;
            height: 250px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1010;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .profile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            cursor: grab; /* æ·»åŠ æŠ“å–å…‰æ ‡ */
            background: rgba(240, 240, 240, 0.95); /* æ ‡é¢˜æ èƒŒæ™¯ */
        }

        .profile-title {
            font-weight: bold;
            font-size: 16px;
        }

        .profile-close {
            cursor: pointer;
            font-size: 20px;
            color: #666;
        }

        .profile-content {
            flex: 1;
            padding: 10px;
            position: relative;
        }

        .profile-canvas {
            width: 100%;
            height: 100%;
        }

        .profile-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .profile-point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: red;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            z-index: 1002;
        }

        .grid-number {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        #map-container {
            position: relative;
            overflow: visible;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* é™ä½ z-index */
        }
        #map-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab; /* ç•¶é¼ æ¨™æ‡¸åœæ™‚é¡¯ç¤ºæŠ“å–æ‰‹å‹¢ */
            background-color: #ffffff
        }
        #map-drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        #file-input {
            display: none;
        }
        #addMarkerBtn {
          /* æŒ‰éˆ•æ¨£å¼ï¼Œå¯ä»¥æ ¹æ“šéœ€æ±‚èª¿æ•´ */
          border: 1px solid #ccc;
          padding: 8px;
          cursor: pointer;
          margin: 5px;
        }
        /* æ¨™è¨»æ¨£å¼ */
        /* æ¨™è¨»æ¨£å¼ */
        /* æ¨™è¨»æ¨£å¼ */
        .marker {
            position: absolute;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            transform: translate(-50%, -10px); /* èª¿æ•´æ¨™è¨˜ä½ç½® */
            cursor: pointer; /* æŒ‡æ¨™æ¨£å¼ */
            z-index: 10; /* ç¢ºä¿æ¨™è¨˜åœ¨åœ°åœ–ä¹‹ä¸Š */
        }

        .marker-triangle {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 20px solid white;
            align-self: center;
        }

        .marker-label {
            background-color: white;
            padding: 2px 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            white-space: nowrap;
            font-size: 12px;
            text-align: center;
            position: relative; /* ç›¸å°æ–¼ .marker å®šä½ */
             left: 50%; /* å°†å·¦è¾¹ç¼˜ç§»åŠ¨åˆ° .marker çš„ä¸­å¿ƒ */
             transform: translateX(-50%); /* å°† label çš„ä¸­å¿ƒå¯¹é½åˆ° .marker çš„ä¸­å¿ƒ */
        }

        /* å³éµèœå–®æ¨£å¼ï¼ˆå·²å­˜åœ¨ï¼Œç¢ºä¿ä½ç½®å±¬æ€§åˆç†ï¼‰ */
        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            z-index: 1000;
            display: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
        }
        .context-menu-item:hover {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
<input type="checkbox" id="debug-water-boundary" style="display:none">
<div id="developer-info">é–‹ç™¼è€…ï¼šé»ƒæ™ºè»’è€å¸«</div>
    <div id="loading-screen">è¼‰å…¥ä¸­...</div>
    <div id="map-container" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;">
    <canvas id="map-canvas"></canvas>
    <canvas id="map-drawing-canvas"></canvas>
</div>
<!-- å³éµèœå–® -->
<div id="contextMenu" class="context-menu">
    <div class="context-menu-item" id="editMarker">ç·¨è¼¯æ¨™è¨˜</div>
    <div class="context-menu-item" id="deleteMarker">åˆªé™¤æ¨™è¨˜</div>
</div>
    <div id="canvas-container"></div>
    <div id="mobile-controls" class="mobile-only">
        <div id="joystick-container">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
    </div>
    <div id="protractor-tool" class="protractor-tool hidden">
    <canvas id="protractor-canvas" width="300" height="300"></canvas>
</div>

<!-- ç¸±å‰–é¢é¢æ¿ -->
<div class="profile-panel" id="profile-panel">
    <div class="profile-header">
        <div class="profile-title">ç¸±å‰–é¢åˆ†æ</div>
        <div class="profile-close" id="profile-close">Ã—</div>
    </div>
    <div class="profile-content">
        <canvas class="profile-canvas" id="profile-canvas"></canvas>
        <div class="profile-info" id="profile-info">
            è·é›¢: 0m | å¹³å‡å¡åº¦: 0Â°
        </div>
    </div>
</div>

    <div class="terrain-toolbar">
        <div class="tool-group">
            <button class="tool-button" data-tool="raise">
                â¬†ï¸
                <span class="tool-tooltip">æŠ¬å‡åœ°å½¢</span>
            </button>
            <button class="tool-button" data-tool="lower">
                â¬‡ï¸
                <span class="tool-tooltip">é™ä½åœ°å½¢</span>
            </button>
            <button class="tool-button" data-tool="smooth">
                ğŸ”„
                <span class="tool-tooltip">å¹³æ»‘åœ°å½¢</span>
            </button>
            <button class="tool-button" id="map-mode-btn">
                ğŸ—ºï¸
                <span class="tool-tooltip">åœ°åœ–ä»‹é¢</span>
            </button>
            <button class="tool-button" id="addMarkerBtn">
                ğŸ“Œ
                <span class="tool-tooltip">æ¨™è¨»</span>
            </button>

        </div>
        <div class="tool-group">
            <button class="tool-button" id="settings-btn">
                âš™ï¸
                <span class="tool-tooltip">è¨­ç½®</span>
            </button>
            <button class="tool-button" id="save-btn">
                ğŸ’¾
                <span class="tool-tooltip">ä¿å­˜åœ°å½¢</span>
            </button>
            <button class="tool-button" id="load-btn">
                ğŸ“‚
                <span class="tool-tooltip">è®€å–åœ°å½¢</span>
            </button>
            <button class="tool-button" id="reset-btn">
                ğŸ”„
                <span class="tool-tooltip">é‡è¨­</span>
            </button>
            <button class="tool-button" id="fullscreen-btn">
                ğŸ”²
                <span class="tool-tooltip">å…¨å±æ¨¡å¼</span>
            </button>
        </div>
    </div>
        <div class="drawing-toolbar">
            <div class="tool-group">
                <button class="tool-button color-btn" data-color="#ff0000" style="background: #ff0000;">
                    <span class="tool-tooltip">ç´…è‰²ç­†</span>
                </button>
                <button class="tool-button color-btn" data-color="#0000ff" style="background: #0000ff;">
                    <span class="tool-tooltip">è—è‰²ç­†</span>
                </button>
                <button class="tool-button color-btn" data-color="#ffff00" style="background: #ffff00;">
                    <span class="tool-tooltip">é»ƒè‰²ç­†</span>
                </button>
                <button class="tool-button color-btn" data-color="#00ff00" style="background: #00ff00;">
                    <span class="tool-tooltip">ç¶ è‰²ç­†</span>
                </button>
                <button class="tool-button color-btn" data-color="#ffffff" style="background: #ffffff;">
                    <span class="tool-tooltip">ç™½è‰²ç­†</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="draw3d-toggle">
                    ğŸ§µ
                    <span class="tool-tooltip">3Dç¹ªåœ–æ¨¡å¼</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="eraser-btn">
                    ğŸ§½
                    <span class="tool-tooltip">æ©¡çš®æ“¦</span>
                </button>
                <button class="tool-button" id="undo-btn">
                    â†©ï¸
                    <span class="tool-tooltip">ä¸Šä¸€æ­¥</span>
                </button>
                <button class="tool-button" id="redo-btn">
                    â†ªï¸
                    <span class="tool-tooltip">ä¸‹ä¸€æ­¥</span>
                </button>
                <button class="tool-button" id="clear-btn">
                    ğŸ—‘ï¸
                    <span class="tool-tooltip">æ¸…é™¤å…¨éƒ¨</span>
                </button>
            </div>
        </div>

        <!-- åœ°åœ–æ¨¡å¼çš„æ¸¬é‡å·¥å…·æ¬„ -->
        <div class="measurement-toolbar" style="display: none;">
            <div class="tool-group">
                <button class="tool-button" id="return-3d-btn">
                    ğŸ”™
                    <span class="tool-tooltip">è¿”å›3Dæ¨¡å¼</span>
                </button>
            </div>
            <div class="tool-group">
              <button class="tool-button" id="polyline-toggle">
                   ğŸ”—
                 <span class="tool-tooltip">å¤šé»é€£ç·š</span>
             </button>
             <button class="tool-button" id="polyline-clear">
                 ğŸ—‘ï¸
                 <span class="tool-tooltip">æ¸…é™¤é€£ç·š</span>
             </button>
                <button class="tool-button" id="protractor-toggle">
                    ğŸ“
                    <span class="tool-tooltip">é‡è§’å™¨å·¥å…·</span>
                </button>
                <button class="tool-button" id="profile-toggle">
                    ğŸ“Š
                    <span class="tool-tooltip">ç¸±å‰–é¢åˆ†æ</span>
                </button>
            </div>
            <div class="tool-group protractor-controls" style="display: none;">
                <button class="tool-button" id="protractor-recall">
                    ğŸ“
                    <span class="tool-tooltip">å‘¼å–šé‡è§’å™¨</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="zoom-in">
                    ğŸ”+
                    <span class="tool-tooltip">æ”¾å¤§</span>
                </button>
                <button class="tool-button" id="zoom-out">
                    ğŸ”-
                    <span class="tool-tooltip">ç¸®å°</span>
                </button>
            </div>
        </div>

        <!-- åœ°åœ–æ¨¡å¼ç¹ªåœ–å·¥å…·æ¬„ -->
        <div class="map-drawing-toolbar">
            <div class="tool-group">
                <button class="tool-button map-color-btn" data-color="#ff0000" style="background: #ff0000;">
                    <span class="tool-tooltip">ç´…è‰²ç­†</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#0000ff" style="background: #0000ff;">
                    <span class="tool-tooltip">è—è‰²ç­†</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#ffff00" style="background: #ffff00;">
                    <span class="tool-tooltip">é»ƒè‰²ç­†</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#00ff00" style="background: #00ff00;">
                    <span class="tool-tooltip">ç¶ è‰²ç­†</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#ffffff" style="background: #ffffff;">
                    <span class="tool-tooltip">ç™½è‰²ç­†</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="map-eraser-btn">
                    ğŸ§½
                    <span class="tool-tooltip">æ©¡çš®æ“¦</span>
                </button>
                <button class="tool-button" id="map-undo-btn">
                    â†©ï¸
                    <span class="tool-tooltip">ä¸Šä¸€æ­¥</span>
                </button>
                <button class="tool-button" id="map-redo-btn">
                    â†ªï¸
                    <span class="tool-tooltip">ä¸‹ä¸€æ­¥</span>
                </button>
                <button class="tool-button" id="map-clear-btn">
                    ğŸ—‘ï¸
                    <span class="tool-tooltip">æ¸…é™¤å…¨éƒ¨</span>
                </button>
            </div>
        </div>
    </div>

    <div class="settings-panel">
        <h4>åƒæ•¸è¨­ç½®</h4>
        <label>å·¥å…·å¼·åº¦: <input type="range" id="tool-strength" min="1" max="100" value="40"></label>
        <label>å·¥å…·ç¯„åœ: <input type="range" id="tool-radius" min="1" max="100" value="40"></label>
        <label>æ©¡çš®æ“¦å¤§å°: <input type="range" id="eraser-size" min="1" max="50" value="40"></label>
    </div>

    <div class="status-bar">
        åº§æ¨™: X: 0, Y: 0, Z: 0 | é«˜åº¦: 0m | å¡åº¦: 0Â°
    </div>
    <input type="file" id="file-input" accept=".json">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, terrain;
        let raycaster, mouse;
        let currentTool = null;
        let isMouseDown = false;
        let radiusIndicator, mouseHelper;
        let isDrawing = false;
        let isErasing = false;
        let currentColor = '#ff0000';
        let drawingHistory = [];
        let historyIndex = -1;
        let drawingCanvas, drawingContext;
        let isMapMode = false;
        let showGrid = false;
        let showDrawings = true;
        let ruler = null;
        let protractor = null;
        let gridOverlay = null;
        let currentScale = 1;
        let targetPosition = new THREE.Vector3(0, 0, 0);
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let joystickActive = false;
        let joystickBase = null;
        let joystickKnob = null;
        let joystickCenter = { x: 0, y: 0 };
        let currentJoystickPos = { x: 0, y: 0 };
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            z: false,
            c: false
        };
        let initialTerrainPositions; // åœ¨é€™è£¡å®£å‘Š initialTerrainPositions è®Šæ•¸
        let terrainHistory = [];
        let terrainHistoryIndex = -1;
        let isPolylineMode = false;
        let polylinePoints = [];
        let totalDistance = 0;
        let polylineLayer = null;
        let pixelSize = 1;
        let protractorVisible = false;
        let isDraggingMap = false; // æ˜¯å¦æ­£åœ¨æ‹–ç§»åœ°åœ–
        let dragStart = { x: 0, y: 0 }; // æ‹–ç§»é–‹å§‹çš„ä½ç½®
        let mapOffset = { x: 0, y: 0 }; // åœ°åœ–çš„åç§»é‡
        let activeMarker = null; //ç›®å‰é¸å®šçš„æ¨™è¨»
        let markers = []; // å„²å­˜æ‰€æœ‰æ¨™è¨˜çš„é™£åˆ—

        // æ·»åŠ æ–°çš„å…¨å±€è®Šé‡
        let is3DDrawingMode = false;
        let tube3DMeshes = []; // æ”¹ç‚ºé™£åˆ—ä¾†å­˜å„²å¤šå€‹ç®¡ç‹€ç‰©é«”
        let drawingPoints = [];

        // åœ¨å…¨å±€è®Šé‡å€åŸŸæ·»åŠ 
        let tube3DMeshHistory = [[]]; // å­˜å„² 3D ç·šæ¢çš„æ­·å²è¨˜éŒ„
        let tube3DMeshHistoryIndex = 0; // 3D ç·šæ¢æ­·å²ç´¢å¼•
        let tube3DMesh = null; // ç•¶å‰æ­£åœ¨ç¹ªè£½çš„ 3D ç·šæ¢

        // ç¸±å‰–é¢ç›¸é—œè®Šé‡
        let isProfileMode = false;
        let profilePoints = [];
        let profileLine = null;
        let heightMultiplier = 10; // é«˜åº¦ç¸®æ”¾å› å­
        let controlPoint = null; // åˆå§‹åŒ– controlPoint
        let isProfileCalculating = false;
        let profileTimeoutId = null;

        // æ·»åŠ é€™äº›æ–°è®Šé‡ä¾†è·Ÿè¸ªé«˜äº®é»
        let profileHighlightPoint = null; // ç”¨æ–¼å­˜å„²é«˜äº®é»åœ¨åœ°åœ–ä¸Šçš„ä½ç½®
        let isProfileHovering = false; // ç”¨æ–¼æ¨™è¨˜æ»‘é¼ æ˜¯å¦æ­£åœ¨ç¸±å‰–é¢åœ–ä¸Šæ‡¸åœ
        // æ·»åŠ é«˜äº®å±¤ç•«å¸ƒè®Šé‡
        let highlightCanvas;
        let highlightContext;

        // 2Dåœ°åœ–ç¹ªåœ–ç›¸é—œè®Šé‡
        let mapDrawingCanvas, mapDrawingContext;
        let mapDrawingHistory = [];
        let mapHistoryIndex = -1;
        let isMapDrawing = false;
        let isMapErasing = false;
        let mapCurrentColor = '#ff0000';

        // åˆå§‹åŒ–å…¥å£å‡½æ•¸ï¼Œç¢ºä¿DOMå®Œå…¨è¼‰å…¥å¾Œæ‰åŸ·è¡Œ
        window.addEventListener('load', init);

        function init() {
            try {
                // åˆå§‹åŒ–3Då ´æ™¯
                initScene();

                // åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨
                initEventListeners();

                // å‰µå»ºåŠå¾‘æŒ‡ç¤ºå™¨
                createRadiusIndicator();

                // åˆå§‹åŒ–ç¹ªåœ–å·¥å…·
                initDrawingTools();

                // åˆå§‹åŒ–åœ°åœ–æ¨¡å¼
                initMapMode();

                // åˆå§‹åŒ–é‡è§’å™¨
                initProtractor();

                // åˆå§‹åŒ–2Dåœ°åœ–ç¹ªåœ–åŠŸèƒ½
                initMapDrawingTools();

                // ä¿å­˜åˆå§‹åœ°å½¢ç‹€æ…‹
                const terrainPositions = terrain.geometry.attributes.position.array;
                const newTerrainPositions = new Float32Array(terrainPositions);
                terrainHistory.push({
                    type: 'terrain',
                    data: newTerrainPositions,
                    drawingIndex: -1,
                });
                terrainHistoryIndex++;

                // ä¿å­˜åˆå§‹ç‹€æ…‹åˆ°æ­·å²è¨˜éŒ„
                saveToHistory();

                // é–‹å§‹å‹•ç•«å¾ªç’°
                animate();

                // éš±è—åŠ è¼‰å±
                document.getElementById('loading-screen').style.display = 'none';
            } catch (error) {
                console.error('åˆå§‹åŒ–éŒ¯èª¤:', error);
                document.getElementById('loading-screen').textContent = 'è¼‰å…¥å¤±æ•—: ' + error.message;
            }

            // ç§»å‹•è¨­å‚™åˆå§‹åŒ–
            if (isMobile) {
                initMobileControls();
            }
        }

        const mapCanvas = document.getElementById('map-canvas');

        // åœ°åœ–æ‹–å‹•è™•ç†
        // ä¿®æ”¹åœ°å›¾ç”»å¸ƒçš„mousedownäº‹ä»¶å¤„ç†å™¨
        mapCanvas.addEventListener('mousedown', (e) => {
            // å¯¹äºçºµå‰–é¢æ¨¡å¼ï¼Œæ”¹ä¸ºåªé€šè¿‡clickäº‹ä»¶å¤„ç†ï¼Œä¸åœ¨mousedownæ—¶å¤„ç†
            if (isProfileMode) {
                // ä»…æ›´æ–°é¼ æ ‡æ ·å¼ï¼Œå®é™…ç‚¹å‡»å¤„ç†ç”±clickäº‹ä»¶å®Œæˆ
                mapCanvas.style.cursor = 'crosshair';
                return;
            }

            // åªæœ‰åœ¨æ²¡æœ‰æ¿€æ´»ä»»ä½•ç»˜å›¾å·¥å…·å’Œæµ‹é‡å·¥å…·æ—¶æ‰å¯ç”¨æ‹–ç§»
            if (isMapDrawing || isMapErasing || isPolylineMode) {
                return;
            }

            // é˜»æ­¢äº‹ä»¶å†’æ³¡å’Œé»˜èªè¡Œç‚º
            e.preventDefault();
            e.stopPropagation();

            // æ˜ç¢ºè¨­ç½®æ‹–ç§»ç‹€æ…‹
            isDraggingMap = true;

            // ä¿å­˜é»æ“Šæ™‚çš„åˆå§‹ä½ç½®
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            mapCanvas.style.cursor = 'grabbing';

            console.log("é–‹å§‹æ‹–ç§»åœ°åœ–", isDraggingMap);
        });

        // ä¿®æ”¹mousemoveäº‹ä»¶å¤„ç†å™¨
        document.addEventListener('mousemove', (e) => {
            if (isDraggingMap) {
                // è¨ˆç®—æ‹–å‹•çš„è·é›¢
                const deltaX = e.clientX - dragStart.x;
                const deltaY = e.clientY - dragStart.y;

                // æ›´æ–°åœ°åœ–åç§»é‡
                mapOffset.x += deltaX;
                mapOffset.y += deltaY;

                // æ›´æ–°æ‹–å‹•èµ·å§‹é»
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;

                // ä½¿ç”¨CSSå˜æ¢ç§»åŠ¨åœ°å›¾å®¹å™¨ï¼Œè€Œä¸æ˜¯é‡ç»˜
                updateMapContainerPosition();
            }
        });

        // ä¿®æ”¹mouseupäº‹ä»¶å¤„ç†å™¨
        document.addEventListener('mouseup', (e) => {
            if (isDraggingMap) {
                e.preventDefault();
                e.stopPropagation();
                console.log("çµæŸæ‹–ç§»åœ°åœ–");
            }

            isDraggingMap = false;
            if (isProfileMode) {
                mapCanvas.style.cursor = 'crosshair';
            } else {
                mapCanvas.style.cursor = 'grab';
            }
        });

        function updateMapContainerPosition() {
            const mapCanvas = document.getElementById('map-canvas');
            const mapDrawingCanvas = document.getElementById('map-drawing-canvas');

            // ä½¿ç”¨CSSå˜æ¢ç§»åŠ¨åœ°å›¾
            if (mapCanvas) {
                mapCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }

            // åŒæ­¥ç§»åŠ¨ç»˜å›¾ç”»å¸ƒï¼Œä½¿ç¬”è¿¹è·Ÿéšåœ°å›¾
            if (mapDrawingCanvas) {
                mapDrawingCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }

            // åŒæ­¥ç§»å‹•é«˜äº®å±¤ç•«å¸ƒ
            if (highlightCanvas) {
                highlightCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }
        }

        function updateMapPosition() {
            // æ›´æ–°åœ°åœ–åç§»ä¸¦é‡æ–°ç¹ªè£½åœ°åœ–
            updateMapContainerPosition();


            // æ¸…é™¤ç¹ªåœ–ç•«å¸ƒçš„æ¨£å¼è®Šæ›ï¼Œå› ç‚ºæˆ‘å€‘åœ¨ Canvas ç¹ªåœ–ä¸­æ‡‰ç”¨äº†åç§»
            const mapDrawingCanvas = document.getElementById('map-drawing-canvas');
            // ç»˜å›¾ç”»å¸ƒéœ€è¦ä¸ä¸»ç”»å¸ƒåŒæ­¥å˜æ¢
            if (mapDrawingCanvas) {
                mapDrawingCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }
        }

        // ç²å–é‡è§’å°ºç›¸é—œå…ƒç´ 
        const protractorTool = document.getElementById('protractor-tool');
        const protractorCanvas = document.getElementById('protractor-canvas');
        const protractorCtx = protractorCanvas.getContext('2d');

        // ç¸±å‰–é¢ç›¸é—œå…ƒç´ 
        const profilePanel = document.getElementById('profile-panel');
        const profileCanvas = document.getElementById('profile-canvas');
        const profileCtx = profileCanvas.getContext('2d');
        const profileInfo = document.getElementById('profile-info');
        const profileClose = document.getElementById('profile-close');

        // åˆå§‹åŒ–é‡è§’å°º
        function initProtractor() {
            drawProtractor();
        }

        // ç¹ªè£½é‡è§’å°º
        function drawProtractor() {
            console.log('ç¹ªè£½é‡è§’å°ºé–‹å§‹');
            const ctx = protractorCtx;
            const canvasWidth = protractorCanvas.width;
            const canvasHeight = protractorCanvas.height;
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const radius = (Math.min(centerX, centerY) - 10) * currentScale;
            const crosshairSize = 20 * currentScale;
            const controlPointAngle = 45;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.globalAlpha = 1;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * currentScale;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerX - crosshairSize, centerY);
            ctx.lineTo(centerX + crosshairSize, centerY);
            ctx.moveTo(centerX, centerY - crosshairSize);
            ctx.lineTo(centerX, centerY + crosshairSize);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2 * currentScale;
            ctx.stroke();


            for (let angle = 0; angle < 360; angle += 1) {
                const adjustedAngle = angle - 90;
                const rad = adjustedAngle * (Math.PI / 180);
                let inner, outer, lineWidth, strokeStyle;

                if (angle % 30 === 0) {
                    inner = crosshairSize + 0 * currentScale;
                    outer = radius;
                    lineWidth = 2 * currentScale;
                    strokeStyle = '#000';
                } else if (angle % 10 === 0) {
                    inner = crosshairSize + 5 * currentScale;
                    outer = radius * currentScale;
                    lineWidth = 1.5 * currentScale;
                    strokeStyle = '#555';
                } else if (angle % 2 === 0) {
                     inner = crosshairSize + 105 * currentScale;
                    outer = radius * currentScale;
                   lineWidth = 0.5 * currentScale;
                    strokeStyle = '#000';
               }

               ctx.beginPath();
               ctx.moveTo(
                   centerX + inner * Math.cos(rad),
                   centerY + inner * Math.sin(rad)
               );
                ctx.lineTo(
                   centerX + outer * Math.cos(rad),
                    centerY + outer * Math.sin(rad)
                );
               ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
               ctx.stroke();


              if (angle % 30 === 0) {
                   const labelRadius = outer - (25 * currentScale);
                    const labelX = centerX + labelRadius * Math.cos(rad);
                   const labelY = centerY + labelRadius * Math.sin(rad);
                  ctx.font = `${14 * currentScale}px Arial`;
                  ctx.fillStyle = '#000';
                   ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                   const displayAngle = (angle === 0) ? '0' : angle.toString();
                    ctx.fillText(displayAngle, labelX, labelY);
                }
            }

            // ç¹ªè£½ç¸®æ”¾æ§åˆ¶é» (45åº¦è™•)
            const rad = (controlPointAngle - 90) * (Math.PI / 180);
            const pointX = centerX + (radius * Math.cos(rad));
            const pointY = centerY + (radius * Math.sin(rad));
            const pointRadius = 5 * currentScale;

            ctx.beginPath();
            ctx.arc(pointX, pointY, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = '#00ff00'; // æ§åˆ¶é»é¡è‰² (ç¶ è‰²)
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1 * currentScale;
            ctx.stroke();

            // è¨­ç½® controlPoint å°è±¡
            controlPoint = {
                x: pointX,
                y: pointY,
                radius: pointRadius
            };

            // ç§»é™¤äº‹ä»¶ç›£è½å™¨
           protractorCanvas.removeEventListener('mousedown', startControlPointDrag);
           protractorCanvas.removeEventListener('touchstart', startControlPointDrag);
           document.removeEventListener('mousemove', handleControlPointDrag);
           document.removeEventListener('touchmove', handleControlPointDrag);
           document.removeEventListener('mouseup', stopControlPointDrag);
           document.removeEventListener('touchend', stopControlPointDrag);

           // æ·»åŠ äº‹ä»¶ç›£è½å™¨
           protractorCanvas.addEventListener('mousedown', startControlPointDrag);
           protractorCanvas.addEventListener('touchstart', startControlPointDrag, { passive: false });
           document.addEventListener('mousemove', handleControlPointDrag);
            document.addEventListener('touchmove', handleControlPointDrag, { passive: false });
           document.addEventListener('mouseup', stopControlPointDrag);
          document.addEventListener('touchend', stopControlPointDrag);


            console.log('ç¹ªè£½é‡è§’å°ºå®Œæˆ');
        }

        // é¡¯ç¤ºé‡è§’å°º
        function showProtractor() {
            protractorTool.classList.remove('hidden');
            protractorVisible = true;
        }

        // éš±è—é‡è§’å°º
        function hideProtractor() {
            protractorTool.classList.add('hidden');
            protractorVisible = false;
        }

        // åˆ‡æ›é‡è§’å°ºé¡¯ç¤ºç‹€æ…‹
        function toggleProtractor() {
            if(protractorVisible){
                hideProtractor();
            } else {
                showProtractor();
            }
        }

        // ç›£è½é‡è§’å°ºæŒ‰éˆ•
        document.getElementById('protractor-toggle').addEventListener('click', () => {
            toggleProtractor();
        });

        // ä½¿é‡è§’å°ºå¯æ‹–æ‹½
        let isDragging = false;
        let offset = { x: 0, y: 0 };

        // æ»‘é¼ äº‹ä»¶
        protractorTool.addEventListener('mousedown', (e) => {
            isDragging = true;
            offset.x = e.clientX - protractorTool.getBoundingClientRect().left;
            offset.y = e.clientY - protractorTool.getBoundingClientRect().top;
        });

        // è§¸æ‘¸äº‹ä»¶
        protractorTool.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            offset.x = touch.clientX - protractorTool.getBoundingClientRect().left;
            offset.y = touch.clientY - protractorTool.getBoundingClientRect().top;
        }, { passive: false });

        document.addEventListener('mousemove', (e) => {
            if(isDragging){
                protractorTool.style.left = `${e.clientX - offset.x}px`;
                protractorTool.style.top = `${e.clientY - offset.y}px`;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if(isDragging){
                e.preventDefault();
                const touch = e.touches[0];
                protractorTool.style.left = `${touch.clientX - offset.x}px`;
                protractorTool.style.top = `${touch.clientY - offset.y}px`;
            }
        }, { passive: false });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('touchend', () => {
            isDragging = false;
        });

        // é˜²æ­¢æ‰‹å‹¢è¡çª
        protractorTool.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        }, { passive: false });

        protractorTool.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        }, { passive: false });

        protractorTool.addEventListener('gestureend', (e) => {
            e.preventDefault();
        }, { passive: false });

        function getControlPointElement() {
            return protractorTool.querySelector('div[style*="border-radius: 50%"]'); // ç¢ºä¿ç¬¦åˆé¸æ“‡å™¨
        }

        let isControlPointDragging = false; // åˆ¤æ–·æ˜¯å¦æ­£åœ¨æ‹–æ‹‰æ§åˆ¶é»
        let dragStartPos = { x: 0, y: 0 }; // æ‹–æ‹‰é–‹å§‹çš„ä½ç½®
        let initialScale = 1;

        // å•Ÿå‹•æ§åˆ¶é»æ‹–æ‹‰
        function startControlPointDrag(e) {
            e.preventDefault();
            if (!controlPoint) return;

            let x, y;
            if (e.offsetX !== undefined && e.offsetY !== undefined) {
                x = e.offsetX;
                y = e.offsetY;
            }
            else if (e.touches && e.touches.length > 0) {
                const canvasRect = protractorCanvas.getBoundingClientRect();
                x = e.touches[0].clientX - canvasRect.left;
                y = e.touches[0].clientY - canvasRect.top;
            }
            else {
                return; //æ²’æœ‰è§¸ç¢°ï¼Œç›´æ¥çµæŸã€‚
            }

            const distance = Math.sqrt((x-controlPoint.x)**2 + (y-controlPoint.y)**2);

            if (distance <= controlPoint.radius) {
                isControlPointDragging = true;
                dragStartPos = { x: x, y: y };
                initialScale = currentScale;
            }
        }

        // æ‹–æ‹‰æ§åˆ¶é»
        function handleControlPointDrag(e) {
            if (!isControlPointDragging) return;
            e.preventDefault();

            let x, y;
            if (e.offsetX !== undefined && e.offsetY !== undefined) {
                x = e.offsetX;
                y = e.offsetY;
            }
            else if (e.touches && e.touches.length > 0) {
                const canvasRect = protractorCanvas.getBoundingClientRect();
                x = e.touches[0].clientX - canvasRect.left;
                y = e.touches[0].clientY - canvasRect.top;
            }
            else {
                return; //æ²’æœ‰è§¸ç¢°ï¼Œç›´æ¥çµæŸã€‚
            }

            const deltaX = x - dragStartPos.x;
            const scaleChange = (deltaX/200);

            currentScale = initialScale + scaleChange;
            currentScale = Math.max(0.1, Math.min(5, currentScale));
            drawProtractor();
        }

        // åœæ­¢æ§åˆ¶é»æ‹–æ‹‰
        function stopControlPointDrag() {
            isControlPointDragging = false;
        }

        function initMobileControls() {
            joystickBase = document.getElementById('joystick-base');
            joystickKnob = document.getElementById('joystick-knob');

            // è§¸æ‘¸äº‹ä»¶è™•ç†
            joystickBase.addEventListener('touchstart', handleJoystickStart);
            document.addEventListener('touchmove', handleJoystickMove);
            document.addEventListener('touchend', handleJoystickEnd);
        }

        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function handleJoystickEnd() {
            joystickActive = false;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            currentJoystickPos = { x: 0, y: 0 };
        }

        function updateJoystickPosition(x, y) {
            const deltaX = x - joystickCenter.x;
            const deltaY = y - joystickCenter.y;
            const angle = Math.atan2(deltaY, deltaX);
            const distance = Math.min(40, Math.sqrt(deltaX * deltaX + deltaY * deltaY));

            const knobX = Math.cos(angle) * distance;
            const knobY = Math.sin(angle) * distance;

            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            currentJoystickPos = {
                x: knobX / 40,
                y: knobY / 40
            };
        }

        // ç¸±å‰–é¢ç›¸é—œå‡½æ•¸
        function toggleProfileMode() {
            try {
                isProfileMode = !isProfileMode;
                const profileToggleBtn = document.getElementById('profile-toggle');
                profileToggleBtn.classList.toggle('active');

                // é‡ç½®ç¸±å‰–é¢æ•¸æ“š
                resetProfileTool();

                // æ›´æ–°æ»‘é¼ æ¨£å¼
                if (isProfileMode) {
                    mapCanvas.style.cursor = 'crosshair'; // åå­—æº–å¿ƒè¡¨ç¤ºé¸æ“‡æ¨¡å¼

                    // æç¤ºç”¨æˆ¶é¸æ“‡é»
                    alert('è«‹åœ¨åœ°åœ–ä¸Šé»é¸å…©å€‹é»ä»¥å‰µå»ºç¸±å‰–é¢åˆ†æ');

                    // ç¦ç”¨å…¶ä»–å·¥å…·
                    resetOtherTools();
                } else {
                    mapCanvas.style.cursor = 'grab';
                    hideProfilePanel();
                }
            } catch (error) {
                console.error("åˆ‡æ›ç¸±å‰–é¢æ¨¡å¼éŒ¯èª¤:", error);
                isProfileMode = false;
                if (profileToggleBtn) {
                    profileToggleBtn.classList.remove('active');
                }
                mapCanvas.style.cursor = 'grab';
            }
        }

        function resetOtherTools() {
            // ç¦ç”¨å…¶ä»–æ¸¬é‡å·¥å…·
            isPolylineMode = false;
            const polylineToggleBtn = document.getElementById('polyline-toggle');
            if (polylineToggleBtn) {
                polylineToggleBtn.classList.remove('active');
            }
            hideProtractor();

            // ç¦ç”¨åœ°åœ–ç¹ªåœ–å·¥å…·
            resetMapDrawingTools();
        }

        function resetProfileTool() {
            // æ¸…é™¤ä¹‹å‰çš„é»å’Œç¸±å‰–é¢
            profilePoints = [];
            hideProfilePanel();

            // é‡ç¹ªåœ°åœ–ï¼ˆç§»é™¤ä¹‹å‰çš„ç·šæ¢ï¼‰
            generate2DMap();
        }

        function handleProfileClick(e) {
            if (!isProfileMode) return;

            // é˜²æ­¢äº‹ä»¶ä¼ æ’­ï¼ˆé¿å…æ‹–æ›³åœ°å›¾ï¼‰
            e.stopPropagation();

            try {
                console.log("å¤„ç†çºµå‰–é¢ç‚¹å‡»");
                // è·å–ç‚¹å‡»ä½ç½®
                const rect = mapCanvas.getBoundingClientRect();
                const clientX = e.clientX;
                const clientY = e.clientY;

                // è®¡ç®—ç›¸å¯¹äºå˜æ¢åç”»å¸ƒçš„ç‚¹å‡»ä½ç½®
                const rawX = clientX - rect.left;
                const rawY = clientY - rect.top;

                // è€ƒè™‘åœ°å›¾çš„å˜æ¢ï¼ˆCSS transformï¼‰
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶ç‚¹ç”¨äºè®¡ç®—
                const canvasCenterX = mapCanvas.width / 2;
                const canvasCenterY = mapCanvas.height / 2;

                // å°†ç‚¹å‡»ä½ç½®è½¬æ¢å›åŸå§‹ï¼ˆæœªå˜æ¢ï¼‰åæ ‡ç©ºé—´
                // å…ˆç§»é™¤CSSå˜æ¢çš„å½±å“
                const withoutOffsetX = rawX - mapOffset.x;
                const withoutOffsetY = rawY - mapOffset.y;

                // å†è€ƒè™‘ç¼©æ”¾ï¼ˆç›¸å¯¹äºä¸­å¿ƒç‚¹ï¼‰
                const transformedX = canvasCenterX + (withoutOffsetX - canvasCenterX) / currentScale;
                const transformedY = canvasCenterY + (withoutOffsetY - canvasCenterY) / currentScale;

                // è®¡ç®—åœ°å›¾çš„åŸºæœ¬å‚æ•°
                const mapSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                const gridSegments = 100;
                const pixelSize = mapSize / gridSegments;
                const offsetX = (mapCanvas.width - gridSegments * pixelSize) / 2;
                const offsetY = (mapCanvas.height - gridSegments * pixelSize) / 2;

                // è®¡ç®—ç›¸å¯¹äºåœ°å½¢ç½‘æ ¼çš„ä½ç½®
                const gridX = (transformedX - offsetX) / pixelSize;
                const gridY = (transformedY - offsetY) / pixelSize;

                console.log("ç‚¹å‡»åæ ‡:", {rawX, rawY, transformedX, transformedY, gridX, gridY});

                // æ·»åŠ ç‚¹ï¼ˆæœ€å¤šä¸¤ä¸ªç‚¹ï¼‰
                if (profilePoints.length < 2) {
                    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
                    if (gridX >= 0 && gridX <= gridSegments && gridY >= 0 && gridY <= gridSegments) {
                        profilePoints.push({
                            screenX: rawX,
                            screenY: rawY,
                            // å­˜å‚¨åŸå§‹åæ ‡ï¼ˆä¸å«ç¼©æ”¾ä¿¡æ¯ï¼‰
                            transformedX: transformedX,
                            transformedY: transformedY,
                            // å­˜å‚¨ç½‘æ ¼åæ ‡ï¼ˆç”¨äºé«˜åº¦è®¡ç®—ï¼‰
                            gridX: gridX,
                            gridY: gridY,
                            // å­˜å‚¨é€‰æ‹©ç‚¹æ—¶çš„ç¼©æ”¾å› å­
                            originalScale: currentScale
                        });

                        console.log("æ·»åŠ çºµå‰–é¢ç‚¹:", profilePoints.length);

                        // å¦‚æœå·²é€‰ä¸¤ä¸ªç‚¹ï¼Œåˆ™ç»˜åˆ¶çºµå‰–é¢
                        if (profilePoints.length === 2) {
                            console.log("ç»˜åˆ¶çºµå‰–é¢çº¿å’Œå›¾è¡¨");
                            drawProfileLine();
                            // ä½¿ç”¨å»¶æ—¶é¿å…é˜»å¡UI
                            setTimeout(() => {
                                try {
                                    createProfileChart();
                                    showProfilePanel();
                                } catch (chartError) {
                                    console.error("åˆ›å»ºå‰–é¢å›¾è¡¨é”™è¯¯:", chartError);
                                    alert("åˆ›å»ºå‰–é¢å›¾è¡¨æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•");
                                    // é‡ç½®å‰–é¢å·¥å…·
                                    resetProfileTool();
                                }
                            }, 100);
                        } else {
                            // é‡ç»˜åœ°å›¾ä»¥æ˜¾ç¤ºç¬¬ä¸€ä¸ªç‚¹
                            generate2DMap();
                        }
                    } else {
                        console.warn("ç‚¹å‡»ä½ç½®è¶…å‡ºæœ‰æ•ˆèŒƒå›´:", {gridX, gridY});
                    }
                }
            } catch (error) {
                console.error("å¤„ç†çºµå‰–é¢ç‚¹å‡»é”™è¯¯:", error);
                alert("å¤„ç†çºµå‰–é¢ç‚¹å‡»æ—¶å‘ç”Ÿé”™è¯¯ã€‚è¯·é‡è¯•æˆ–é‡ç½®å·¥å…·ã€‚");
                // é‡ç½®å‰–é¢å·¥å…·ï¼Œé¿å…å¡æ­»
                resetProfileTool();
            }
        }

        function drawProfileLine() {
            try {
                // åœ¨åœ°åœ–ä¸Šç¹ªè£½é€£ç·š
                if (profilePoints.length !== 2) return;

                const mapContext = mapCanvas.getContext('2d');

                // ä¿å­˜ç•«å¸ƒç‹€æ…‹
                mapContext.save();

                // æ‡‰ç”¨èˆ‡åœ°åœ–ç›¸åŒçš„è®Šæ›
                mapContext.translate(mapOffset.x, mapOffset.y);
                mapContext.translate(mapCanvas.width / 2, mapCanvas.height / 2);
                mapContext.scale(currentScale, currentScale);
                mapContext.translate(-mapCanvas.width / 2, -mapCanvas.height / 2);

                // ç¹ªè£½é€£æ¥ç·š
                mapContext.beginPath();

                // è€ƒæ…®åŸå§‹ç¼©æ”¾å› å­å’Œå½“å‰ç¼©æ”¾å› å­çš„å·®å¼‚
                // è®¡ç®—æ¯ä¸ªç‚¹åœ¨å½“å‰ç¼©æ”¾çº§åˆ«ä¸‹çš„ä½ç½®
                const canvasCenterX = mapCanvas.width / 2;
                const canvasCenterY = mapCanvas.height / 2;

                // è°ƒæ•´ç¬¬ä¸€ä¸ªç‚¹
                const point1 = profilePoints[0];
                // ä»ä¸­å¿ƒç‚¹è®¡ç®—ç›¸å¯¹ä½ç½®
                const relX1 = point1.transformedX - canvasCenterX;
                const relY1 = point1.transformedY - canvasCenterY;
                // è°ƒæ•´ä¸ºå½“å‰ç¼©æ”¾çº§åˆ«
                const adjustedX1 = canvasCenterX + (relX1 * point1.originalScale / currentScale);
                const adjustedY1 = canvasCenterY + (relY1 * point1.originalScale / currentScale);

                // è°ƒæ•´ç¬¬äºŒä¸ªç‚¹
                const point2 = profilePoints[1];
                const relX2 = point2.transformedX - canvasCenterX;
                const relY2 = point2.transformedY - canvasCenterY;
                const adjustedX2 = canvasCenterX + (relX2 * point2.originalScale / currentScale);
                const adjustedY2 = canvasCenterY + (relY2 * point2.originalScale / currentScale);

                // ä½¿ç”¨è°ƒæ•´åçš„åæ ‡
                mapContext.moveTo(adjustedX1, adjustedY1);
                mapContext.lineTo(adjustedX2, adjustedY2);
                mapContext.strokeStyle = '#ff0000';
                mapContext.lineWidth = 3 / currentScale; // è€ƒæ…®ç¸®æ”¾èª¿æ•´ç·šå¯¬
                mapContext.stroke();

                // ç¹ªè£½é»ï¼ˆä½¿ç”¨è°ƒæ•´åçš„åæ ‡ï¼‰
                for (let i = 0; i < profilePoints.length; i++) {
                    const point = profilePoints[i];
                    const relX = point.transformedX - canvasCenterX;
                    const relY = point.transformedY - canvasCenterY;
                    const adjustedX = canvasCenterX + (relX * point.originalScale / currentScale);
                    const adjustedY = canvasCenterY + (relY * point.originalScale / currentScale);

                    mapContext.beginPath();
                    mapContext.arc(adjustedX, adjustedY, 6 / currentScale, 0, 2 * Math.PI);
                    mapContext.fillStyle = i === 0 ? '#00ff00' : '#ff0000';
                    mapContext.fill();
                    mapContext.strokeStyle = '#ffffff';
                    mapContext.lineWidth = 2 / currentScale;
                    mapContext.stroke();

                    // æ›´æ–°ç‚¹çš„ä¸´æ—¶ä½ç½®ä»¥ä¾›å…¶ä»–å‡½æ•°ä½¿ç”¨
                    point.adjustedX = adjustedX;
                    point.adjustedY = adjustedY;
                }

                // ç¹ªè£½é«˜äº®é»ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (isProfileHovering && profileHighlightPoint) {
                    mapContext.beginPath();

                    // è®¡ç®—é«˜äº®ç‚¹ç›¸å¯¹äºçº¿æ®µçš„ä½ç½®ï¼ˆä»ä¿æŒç›¸åŒçš„ç›¸å¯¹ä½ç½®ï¼‰
                    const p1 = profilePoints[0];
                    const p2 = profilePoints[1];

                    // è®¡ç®—é«˜äº®ç‚¹åœ¨è°ƒæ•´åçš„çº¿æ®µä¸Šçš„ç›¸åº”ä½ç½®
                    let highlightX, highlightY;

                    if (profileHighlightPoint.t !== undefined) {
                        // å¦‚æœå·²ç»ä¿å­˜äº†æ’å€¼å› å­ï¼Œç›´æ¥ä½¿ç”¨
                        const t = profileHighlightPoint.t;
                        highlightX = adjustedX1 + (adjustedX2 - adjustedX1) * t;
                        highlightY = adjustedY1 + (adjustedY2 - adjustedY1) * t;
                    } else {
                        // å¦åˆ™ä½¿ç”¨åŸå§‹é«˜äº®ç‚¹
                        highlightX = profileHighlightPoint.x;
                        highlightY = profileHighlightPoint.y;
                    }

                    mapContext.arc(
                        highlightX,
                        highlightY,
                        8 / currentScale, // ç¨å¤§ä¸€é»æ›´é†’ç›®
                        0,
                        2 * Math.PI
                    );
                    mapContext.fillStyle = '#ffff00'; // é»ƒè‰²
                    mapContext.strokeStyle = '#000000'; // é»‘è‰²é‚Šæ¡†
                    mapContext.lineWidth = 2 / currentScale;
                    mapContext.fill();
                    mapContext.stroke();
                }

                // æ¢å¾©ç•«å¸ƒç‹€æ…‹
                mapContext.restore();
            } catch (error) {
                console.error("ç¹ªè£½ç¸±å‰–é¢ç·šéŒ¯èª¤:", error);
            }
            // æ·»åŠ æ‡¸åœæ•ˆæœåˆå§‹åŒ–
            addProfileHoverEffect();
        }

        function createProfileChart() {
            try {
                if (profilePoints.length !== 2) return;

                // ç²å–ç¸±å‰–é¢ç•«å¸ƒå’Œä¸Šä¸‹æ–‡
                const canvas = profileCanvas;
                const ctx = profileCtx;

                // èª¿æ•´ç•«å¸ƒå¤§å°
                canvas.width = canvas.offsetWidth || 800;
                canvas.height = canvas.offsetHeight || 200;

                // æ¸…é™¤ç•«å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ç²å–åœ°å½¢æ•¸æ“š
                const positions = terrain.geometry.attributes.position.array;
                const gridSize = Math.sqrt(positions.length / 3);

                // è¨­ç½®ç¸±å‰–é¢åœ–çš„é‚Šè·
                const margin = {
                    top: 20,
                    right: 20,
                    bottom: 40,
                    left: 60
                };

                const width = canvas.width - margin.left - margin.right;
                const height = canvas.height - margin.top - margin.bottom;

                // ç²å–å…©é»ä¹‹é–“çš„é«˜åº¦æ¡æ¨£
                const samples = 100; // æ¡æ¨£é»æ•¸é‡
                const samplePoints = [];

                // è¨ˆç®—åˆ†æç·šä¸Šçš„æ¯å€‹é»
                for (let i = 0; i < samples; i++) {
                    const t = i / (samples - 1);

                    // åœ¨ç¶²æ ¼åæ¨™ä¸Šé€²è¡Œæ’å€¼
                    const gridX = profilePoints[0].gridX + t * (profilePoints[1].gridX - profilePoints[0].gridX);
                    const gridY = profilePoints[0].gridY + t * (profilePoints[1].gridY - profilePoints[0].gridY);

                    // ä½¿ç”¨é›™ç·šæ€§æ’å€¼ç²å–é«˜åº¦
                    const height = bilinearInterpolate(positions, gridSize, gridX, gridY) * heightMultiplier;

                    // è¨ˆç®—è·é›¢ï¼ˆä»¥ç±³ç‚ºå–®ä½ï¼‰
                    const distance = Math.sqrt(
                        Math.pow(profilePoints[1].gridX - profilePoints[0].gridX, 2) +
                        Math.pow(profilePoints[1].gridY - profilePoints[0].gridY, 2)
                    ) * (100 / 100); // ç¸®æ”¾åˆ°å¯¦éš›åœ°å½¢å°ºå¯¸ï¼ˆ100ç±³ï¼‰

                    const currentDistance = t * distance;

                    samplePoints.push({
                        distance: currentDistance,
                        height: height,
                        x: margin.left + (width * t),
                        y: margin.top + height * (height < 0 ? 0.5 : 1) // é«˜åº¦ç¸®æ”¾
                    });
                }

                // æ‰¾å‡ºé«˜åº¦çš„æœ€å¤§å€¼å’Œæœ€å°å€¼
                let minHeight = Math.min(...samplePoints.map(p => p.height));
                let maxHeight = Math.max(...samplePoints.map(p => p.height));

                // ç‚ºäº†æ›´å¥½çš„è¦–è¦ºæ•ˆæœï¼Œç¢ºä¿é«˜åº¦ç¯„åœåˆç†
                const heightRange = maxHeight - minHeight;
                if (heightRange < 10) {
                    // å¦‚æœç¯„åœå¤ªå°ï¼Œæ“´å¤§ç¯„åœ
                    const mid = (maxHeight + minHeight) / 2;
                    minHeight = mid - 5;
                    maxHeight = mid + 5;
                }

                // è¨ˆç®—ç¸½è·é›¢å’Œå¹³å‡å¡åº¦
                const totalDistance = samplePoints[samplePoints.length - 1].distance;
                const heightDifference = Math.abs(samplePoints[samplePoints.length - 1].height - samplePoints[0].height);
                const averageSlope = Math.atan(heightDifference / totalDistance) * (180 / Math.PI);

                // æ›´æ–°è³‡è¨Šé¢æ¿
                profileInfo.textContent = `è·é›¢: ${totalDistance.toFixed(1)}m | å¹³å‡å¡åº¦: ${averageSlope.toFixed(1)}Â°`;

                // ç¹ªè£½èƒŒæ™¯
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(margin.left, margin.top, width, height);

                // ç¹ªè£½åº§æ¨™è»¸
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                // Xè»¸
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top + height);
                ctx.lineTo(margin.left + width, margin.top + height);
                ctx.stroke();

                // Yè»¸
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top);
                ctx.lineTo(margin.left, margin.top + height);
                ctx.stroke();

                // ç¹ªè£½Xè»¸æ¨™ç±¤
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';

                // è·é›¢åˆ»åº¦
                const distanceStep = Math.ceil(totalDistance / 5); // 5å€‹åˆ»åº¦
                for (let d = 0; d <= totalDistance; d += distanceStep) {
                    const x = margin.left + (d / totalDistance) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top + height);
                    ctx.lineTo(x, margin.top + height + 5);
                    ctx.stroke();
                    ctx.fillText(`${d}m`, x, margin.top + height + 8);
                }

                // ç¹ªè£½Yè»¸æ¨™ç±¤
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                // é«˜åº¦åˆ»åº¦
                const heightStep = Math.ceil((maxHeight - minHeight) / 5); // 5å€‹åˆ»åº¦
                for (let h = Math.floor(minHeight); h <= Math.ceil(maxHeight); h += heightStep) {
                    const normalizedHeight = (h - minHeight) / (maxHeight - minHeight);
                    const y = margin.top + height - (normalizedHeight * height);

                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left - 5, y);
                    ctx.stroke();
                    ctx.fillText(`${h.toFixed(0)}m`, margin.left - 8, y);

                    // ç¹ªè£½æ°´å¹³è¼”åŠ©ç·š
                    ctx.beginPath();
                    ctx.strokeStyle = '#ddd';
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + width, y);
                    ctx.stroke();
                    ctx.strokeStyle = '#000';
                }

                // Xè»¸æ¨™é¡Œ
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillText('è·é›¢ (m)', margin.left + width / 2, margin.top + height + 25);

                // Yè»¸æ¨™é¡Œ
                ctx.save();
                ctx.translate(margin.left - 40, margin.top + height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('é«˜åº¦ (m)', 0, 0);
                ctx.restore();

                // ç¹ªè£½åœ°å½¢æ›²ç·š
                ctx.beginPath();

                // æ­£è¦åŒ–é«˜åº¦å€¼åˆ°ç¹ªåœ–å€åŸŸ
                const normalizeY = (h) => margin.top + height - ((h - minHeight) / (maxHeight - minHeight) * height);

                // ç§»å‹•åˆ°ç¬¬ä¸€å€‹é»
                ctx.moveTo(samplePoints[0].x, normalizeY(samplePoints[0].height));

                // ç¹ªè£½å‰©é¤˜é»
                for (let i = 1; i < samplePoints.length; i++) {
                    ctx.lineTo(samplePoints[i].x, normalizeY(samplePoints[i].height));
                }

                // ç¹ªè£½ç·šæ¢
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.stroke();

                // å¡«å……åœ°å½¢ä¸‹æ–¹å€åŸŸ
                ctx.lineTo(samplePoints[samplePoints.length - 1].x, normalizeY(minHeight));
                ctx.lineTo(samplePoints[0].x, normalizeY(minHeight));
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fill();

                // ç¹ªè£½èµ·é»å’Œçµ‚é»æ¨™è¨˜
                const startY = normalizeY(samplePoints[0].height);
                const endY = normalizeY(samplePoints[samplePoints.length - 1].height);

                // èµ·é»ï¼ˆç¶ è‰²ï¼‰
                ctx.beginPath();
                ctx.arc(samplePoints[0].x, startY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // çµ‚é»ï¼ˆç´…è‰²ï¼‰
                ctx.beginPath();
                ctx.arc(samplePoints[samplePoints.length - 1].x, endY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // æ·»åŠ æµ·æ‹”æ¨™ç±¤
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(`${samplePoints[0].height.toFixed(1)}m`, samplePoints[0].x, startY - 8);

                ctx.textBaseline = 'bottom';
                ctx.fillText(`${samplePoints[samplePoints.length - 1].height.toFixed(1)}m`,
                           samplePoints[samplePoints.length - 1].x, endY - 8);
            } catch (error) {
                console.error("å‰µå»ºç¸±å‰–é¢åœ–éŒ¯èª¤:", error);
            }
        }

        function hideProfilePanel() {
            profilePanel.style.display = 'none';
        }

        // ç¹ªè£½ç¸±å‰–é¢é¸æ“‡é»
        function drawProfilePoints(context) {
            // ä¿å­˜ä¸Šä¸‹æ–‡çŠ¶æ€
            context.save();

            for (let i = 0; i < profilePoints.length; i++) {
                const point = profilePoints[i];
                context.beginPath();

                // ä½¿ç”¨å˜æ¢è¿‡çš„åæ ‡
                const drawX = point.transformedX;
                const drawY = point.transformedY;

                context.arc(drawX, drawY, 6 / currentScale, 0, 2 * Math.PI);
                context.fillStyle = i === 0 ? '#00ff00' : '#ff0000'; // èµ·ç‚¹ç»¿è‰²ï¼Œç»ˆç‚¹çº¢è‰²
                context.fill();
                context.strokeStyle = '#ffffff';
                context.lineWidth = 2 / currentScale;
                context.stroke();
            }

            // æ¢å¤ä¸Šä¸‹æ–‡çŠ¶æ€
            context.restore();
        }

        function makeProfilePanelDraggable() {
            const profilePanel = document.getElementById('profile-panel');
            const profileHeader = profilePanel.querySelector('.profile-header');

            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            // é¼ æ ‡äº‹ä»¶
            profileHeader.addEventListener('mousedown', (e) => {
                // ç¡®ä¿ä¸æ˜¯ç‚¹å‡»å…³é—­æŒ‰é’®
                if (e.target.id === 'profile-close') return;

                isDragging = true;
                dragOffset.x = e.clientX - profilePanel.getBoundingClientRect().left;
                dragOffset.y = e.clientY - profilePanel.getBoundingClientRect().top;
                profilePanel.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const left = e.clientX - dragOffset.x;
                const top = e.clientY - dragOffset.y;

                // ç¡®ä¿é¢æ¿ä¸ä¼šè¢«æ‹–å‡ºå±å¹•
                const maxX = window.innerWidth - profilePanel.offsetWidth;
                const maxY = window.innerHeight - profilePanel.offsetHeight;

                profilePanel.style.left = `${Math.max(0, Math.min(left, maxX))}px`;
                profilePanel.style.top = `${Math.max(0, Math.min(top, maxY))}px`;
                profilePanel.style.bottom = 'auto'; // å–æ¶ˆåº•éƒ¨å®šä½
                profilePanel.style.transform = 'none'; // å–æ¶ˆåŸæ¥çš„ä¸­å¿ƒå®šä½
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                profilePanel.style.cursor = 'default';
            });

            // è§¦æ‘¸äº‹ä»¶
            profileHeader.addEventListener('touchstart', (e) => {
                if (e.target.id === 'profile-close') return;

                isDragging = true;
                const touch = e.touches[0];
                dragOffset.x = touch.clientX - profilePanel.getBoundingClientRect().left;
                dragOffset.y = touch.clientY - profilePanel.getBoundingClientRect().top;
                e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;

                const touch = e.touches[0];
                const left = touch.clientX - dragOffset.x;
                const top = touch.clientY - dragOffset.y;

                const maxX = window.innerWidth - profilePanel.offsetWidth;
                const maxY = window.innerHeight - profilePanel.offsetHeight;

                profilePanel.style.left = `${Math.max(0, Math.min(left, maxX))}px`;
                profilePanel.style.top = `${Math.max(0, Math.min(top, maxY))}px`;
                profilePanel.style.bottom = 'auto';
                profilePanel.style.transform = 'none';
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        }

        // åœ¨showProfilePanelå‡½æ•°ä¸­è°ƒç”¨æ­¤å‡½æ•°
        function showProfilePanel() {
            profilePanel.style.display = 'flex';

            // åˆå§‹è®¾ç½®ä¸ºå±…ä¸­
            profilePanel.style.left = '50%';
            profilePanel.style.top = '50%';
            profilePanel.style.transform = 'translate(-50%, -50%)';
            profilePanel.style.bottom = 'auto';

            // ç¡®ä¿é¢æ¿å¯æ‹–åŠ¨
            makeProfilePanelDraggable();

            // ç¡®ä¿ canvas åœ¨æ˜¾ç¤ºåè°ƒæ•´å¤§å°
            setTimeout(() => {
                profileCanvas.width = profileCanvas.offsetWidth || 800;
                profileCanvas.height = profileCanvas.offsetHeight || 200;
                createProfileChart(); // åœ¨è°ƒæ•´å¤§å°åé‡æ–°ç»˜åˆ¶
            }, 100);
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xb0d5e8);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 50, 60);
            camera.lookAt(0, 0, 0);
            camera.rotation.y = Math.PI/2;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createTerrain();

            // å„²å­˜åˆå§‹åœ°å½¢è³‡æ–™
            const terrainPositions = terrain.geometry.attributes.position.array;
            initialTerrainPositions = new Float32Array(terrainPositions);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = true;      // å•Ÿç”¨å¹³ç§»
            controls.panSpeed = 1.0;        // èª¿æ•´å¹³ç§»é€Ÿåº¦
            controls.enableZoom = true;     // å•Ÿç”¨ç¸®æ”¾
            controls.zoomSpeed = 1.0;       // èª¿æ•´ç¸®æ”¾é€Ÿåº¦
            controls.enableRotate = true;   // å•Ÿç”¨æ—‹è½‰
            controls.rotateSpeed = 0.8;     // èª¿æ•´æ—‹è½‰é€Ÿåº¦
            controls.maxPolarAngle = Math.PI / 2; // é™åˆ¶æœ€å¤§ä¿¯è¦–è§’åº¦ç‚º90åº¦
            controls.minPolarAngle = 0;     // å…è¨±å®Œå…¨å‚ç›´è¦–è§’
            controls.screenSpacePanning = true; // ä½¿å¹³ç§»èˆ‡å±å¹•ç©ºé–“å°é½Š
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(100, 100, 100, 100);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    colorLow: { value: new THREE.Color(0x228B22) },    // æ·±ç¶ è‰²
                    colorMid: { value: new THREE.Color(0xffd700) },    // é»ƒè‰²
                    colorHigh: { value: new THREE.Color(0x800000) },   // æ·±ç´…è‰²
                    colorWaterShallow: { value: new THREE.Color(0x87CEEB) }, // æ·ºè—è‰²
                    colorWaterDeep: { value: new THREE.Color(0x0000FF) },   // æ·±è—è‰²
                    contourInterval: { value: 2.0 },
                    contourWidth: { value: 0.1 },
                    heightScale: { value: 1.0 },
                    maxHeight: { value: 1.0 },
                    waterThreshold: { value: -0.5 }  // æ°´æ·±é–¾å€¼ï¼ˆ0.5ç±³ï¼‰
                },
                vertexShader: `
                    varying float vHeight;
                    void main() {
                        vHeight = position.z;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 colorLow;
                    uniform vec3 colorMid;
                    uniform vec3 colorHigh;
                    uniform vec3 colorWaterShallow;
                    uniform vec3 colorWaterDeep;
                    uniform float contourInterval;
                    uniform float contourWidth;
                    uniform float heightScale;
                    uniform float maxHeight;
                    uniform float waterThreshold;
                    varying float vHeight;

                    void main() {
                        float scaledHeight = vHeight * heightScale;
                        vec3 terrainColor;
                        float heightPercent;

                        if (scaledHeight < 0.0) {
                            // è™•ç†è² é«˜åº¦ï¼ˆæ°´åŸŸï¼‰
                            if (scaledHeight > waterThreshold) {
                                // 0åˆ°-0.5ç±³ä¹‹é–“ï¼Œä½¿ç”¨æ·ºè—è‰²
                                terrainColor = colorWaterShallow;
                            } else {
                                // ä½æ–¼-0.5ç±³ï¼Œä½¿ç”¨æ·±è—è‰²
                                terrainColor = colorWaterDeep;
                            }
                        } else {
                            // è™•ç†æ­£é«˜åº¦ï¼ˆé™¸åœ°ï¼‰
                            heightPercent = scaledHeight / maxHeight;
                            if (heightPercent <= 0.5) {
                                terrainColor = mix(colorLow, colorMid, heightPercent * 2.0);
                            } else {
                                terrainColor = mix(colorMid, colorHigh, (heightPercent - 0.5) * 2.0);
                            }
                        }

                        // ç­‰é«˜ç·šè™•ç†
                        float finalColor = 1.0;
                        float absHeight = abs(scaledHeight);
                        if (absHeight > 0.01) {
                            float contour = mod(absHeight, contourInterval);
                            float line = smoothstep(0.0, contourWidth, contour) *
                                        smoothstep(contourInterval, contourInterval - contourWidth, contour);
                            finalColor = line;
                        }

                        gl_FragColor = vec4(mix(vec3(0.0), terrainColor, finalColor), 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);
        }

        function createRadiusIndicator() {
            const geometry = new THREE.CircleGeometry(1, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                opacity: 0.3,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            radiusIndicator = new THREE.Mesh(geometry, material);
            radiusIndicator.rotation.x = -Math.PI / 2;
            radiusIndicator.visible = false;
            scene.add(radiusIndicator);

            const helperGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const helperMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                depthTest: false
            });
            mouseHelper = new THREE.Mesh(helperGeometry, helperMaterial);
            mouseHelper.visible = false;
            scene.add(mouseHelper);
        }

        function updateRadiusIndicator(position) {
            if (!radiusIndicator) return;

            const toolRadius = document.getElementById('tool-radius').value / 5;
            radiusIndicator.position.copy(position);
            radiusIndicator.position.z += 0.1;
            radiusIndicator.scale.set(toolRadius, toolRadius, 1);
            radiusIndicator.visible = true;

            mouseHelper.position.copy(position);
            mouseHelper.position.z += 0.2;
            mouseHelper.visible = true;
        }

        function onTouchStart(event) {
            event.preventDefault();

            if (currentTool === 'addMarker') {
                const touch = event.touches[0];
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                addMarker(event);
                currentTool = null;
                controls.enabled = true;
                return;
            }

            if (currentTool) {
                isMouseDown = true;
                const touch = event.touches[0];
                updateTouchPosition(touch);
                modifyTerrain();
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (!isMouseDown) return;

            const touch = event.touches[0];
            updateTouchPosition(touch);
            if (currentTool) {
                modifyTerrain();
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            isMouseDown = false;
            if (currentTool) saveToHistory();
        }

        function updateTouchPosition(touch) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function initEventListeners() {
            try {
                // åœ°å½¢å·¥å…·æŒ‰éˆ•äº‹ä»¶ç›£è½
                document.querySelectorAll('.terrain-toolbar .tool-button[data-tool]').forEach(button => {
                    button.addEventListener('click', () => {
                        // å¦‚æœç•¶å‰å·¥å…·å·²ç¶“è¢«é¸ä¸­ï¼Œå‰‡å–æ¶ˆé¸ä¸­
                        if (currentTool === button.dataset.tool) {
                            currentTool = null;
                            button.classList.remove('active');
                            controls.enabled = true;
                            if (radiusIndicator) radiusIndicator.visible = false;
                            if (mouseHelper) mouseHelper.visible = false;
                            if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
                            return;
                        }

                        // é‡ç½®æ‰€æœ‰å·¥å…·æŒ‰éˆ•çš„ç‹€æ…‹
                        resetTerrainTools();

                        // è¨­ç½®æ–°çš„å·¥å…·ç‹€æ…‹
                        currentTool = button.dataset.tool;
                        button.classList.add('active');
                        controls.enabled = false;
                        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
                    });
                });

                // æ¨™è¨»æŒ‰éˆ•äº‹ä»¶ç›£è½
                const addMarkerBtn = document.getElementById('addMarkerBtn');
                if (addMarkerBtn) {
                    addMarkerBtn.addEventListener('click', () => {
                        resetTerrainTools();
                        currentTool = 'addMarker';
                        controls.enabled = false;
                        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
                        if (isMobile) {
                            alert('è«‹é»æ“Šåœ°åœ–ä½ç½®ä¾†æ·»åŠ æ¨™è¨˜');
                        }
                    });
                }

                let renderContainer = renderer.domElement;

                if (isMobile) {
                    renderContainer.addEventListener('touchstart', onTouchStart);
                    renderContainer.addEventListener('touchmove', onTouchMove);
                    renderContainer.addEventListener('touchend', onTouchEnd);
                } else {
                    renderContainer.addEventListener('pointerdown', onMouseDown);
                    renderContainer.addEventListener('pointermove', onMouseMove);
                    renderContainer.addEventListener('pointerup', onMouseUp);
                }

                // ä¿å­˜æŒ‰éˆ•äº‹ä»¶
                const saveBtn = document.getElementById('save-btn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => {
                        saveTerrain();
                    });
                }

                // è¼‰å…¥æŒ‰éˆ•äº‹ä»¶
                const loadBtn = document.getElementById('load-btn');
                if (loadBtn) {
                    loadBtn.addEventListener('click', () => {
                        document.getElementById('file-input').click();
                    });
                }

                // æ–‡ä»¶è¼¸å…¥äº‹ä»¶
                const fileInput = document.getElementById('file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', loadTerrain);
                }

                // é‡è¨­æŒ‰éˆ•äº‹ä»¶
                const resetBtn = document.getElementById('reset-btn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        resetTerrain();
                    });
                }

                // è¨­ç½®æŒ‰éˆ•äº‹ä»¶
                const settingsBtn = document.getElementById('settings-btn');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', () => {
                        const panel = document.querySelector('.settings-panel');
                        panel.classList.toggle('show');
                    });
                }

                // ç¸±å‰–é¢æŒ‰éˆ•äº‹ä»¶
                const profileToggleBtn = document.getElementById('profile-toggle');
                if (profileToggleBtn) {
                    profileToggleBtn.addEventListener('click', () => {
                        toggleProfileMode();
                    });
                }

                // ç¸±å‰–é¢é—œé–‰æŒ‰éˆ•äº‹ä»¶
                const profileCloseBtn = document.getElementById('profile-close');
                if (profileCloseBtn) {
                    profileCloseBtn.addEventListener('click', () => {
                        hideProfilePanel();
                    });
                }

                // éµç›¤äº‹ä»¶
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (keys.hasOwnProperty(key)) {
                        keys[key] = true;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (keys.hasOwnProperty(key)) {
                        keys[key] = false;
                    }
                });

                // çª—å£å¤§å°èª¿æ•´äº‹ä»¶
                window.addEventListener('resize', () => {
                    if (camera) {
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                    }
                    if (renderer) {
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                    if (drawingCanvas) {
                        drawingCanvas.width = window.innerWidth;
                        drawingCanvas.height = window.innerHeight;
                        if (historyIndex >= 0 && drawingHistory[historyIndex] && drawingHistory[historyIndex].canvas) {
                            drawingContext.drawImage(drawingHistory[historyIndex].canvas, 0, 0);
                        }
                    }
                });

            } catch (error) {
                console.error("åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨éŒ¯èª¤:", error);
            }
        }

        // åœ¨ç¸±å‰–é¢ç•«å¸ƒä¸Šæ·»åŠ æ»‘é¼ ç§»å‹•ç›£è½
        function addProfileHoverEffect() {
            const profileCanvas = document.getElementById('profile-canvas');
            let debounceTimer;

            profileCanvas.addEventListener('mousemove', (e) => {
                if (profilePoints.length !== 2) return;

                // æ¸…é™¤ä¹‹å‰çš„è¨ˆæ™‚å™¨
                clearTimeout(debounceTimer);

                // è¨­ç½®æ–°çš„è¨ˆæ™‚å™¨
                debounceTimer = setTimeout(() => {
                    isProfileHovering = true;

                    // ç²å–æ»‘é¼ åœ¨ç•«å¸ƒä¸Šçš„ä½ç½®
                    const rect = profileCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;

                    // è¨ˆç®—ç•«å¸ƒå…§å®¹å€åŸŸ
                    const margin = {
                        top: 20,
                        right: 20,
                        bottom: 40,
                        left: 60
                    };
                    const contentWidth = profileCanvas.width - margin.left - margin.right;
                    const contentLeft = margin.left;

                    // è¨ˆç®—æ»‘é¼ åœ¨å…§å®¹å€åŸŸçš„ç›¸å°ä½ç½®(0-1)
                    let relativeX = (x - contentLeft) / contentWidth;
                    relativeX = Math.max(0, Math.min(1, relativeX)); // ç¢ºä¿åœ¨0-1ç¯„åœå…§

                    // åœ¨åœ°åœ–ä¸Šæ›´æ–°é«˜äº®é»
                    updateHighlightPoint(relativeX);
                }, 10); // 10æ¯«ç§’çš„é˜²æŠ–å»¶é²
            });

            profileCanvas.addEventListener('mouseout', () => {
                isProfileHovering = false;
                clearTimeout(debounceTimer);
                // ç§»é™¤é«˜äº®é»
                profileHighlightPoint = null;
                // æ¸…é™¤é«˜äº®å±¤
                if (highlightContext) {
                    highlightContext.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                }
            });
        }

        // åœ¨åœ°åœ–ä¸Šæ›´æ–°é«˜äº®é»ä½ç½®
        function updateHighlightPoint(relativePosition) {
            // åŸºæ–¼ç›¸å°ä½ç½®è¨ˆç®—å…©é»ä¹‹é–“çš„ä½ç½®
            const p1 = profilePoints[0];
            const p2 = profilePoints[1];

            // ä¿å­˜æ’å€¼å› å­ï¼Œè¿™æ˜¯é«˜äº®ç‚¹åœ¨çº¿æ®µä¸Šçš„ç›¸å¯¹ä½ç½®
            const t = relativePosition;

            // ä½¿ç”¨adjustedXå’ŒadjustedYï¼ˆå·²åœ¨drawProfileLineå‡½æ•°ä¸­è®¡ç®—ï¼‰
            // è¿™äº›æ˜¯è€ƒè™‘äº†ç¼©æ”¾å› å­çš„è°ƒæ•´åæ ‡
            const x1 = p1.adjustedX !== undefined ? p1.adjustedX : p1.transformedX;
            const y1 = p1.adjustedY !== undefined ? p1.adjustedY : p1.transformedY;
            const x2 = p2.adjustedX !== undefined ? p2.adjustedX : p2.transformedX;
            const y2 = p2.adjustedY !== undefined ? p2.adjustedY : p2.transformedY;

            // è®¡ç®—çº¿æ€§æ’å€¼ä½ç½®
            const highlightX = x1 + (x2 - x1) * t;
            const highlightY = y1 + (y2 - y1) * t;

            // ä¿å­˜é«˜äº®é»ä½ç½®å’Œæ’å€¼å› å­
            profileHighlightPoint = {
                x: highlightX,
                y: highlightY,
                t: t  // ä¿å­˜æ’å€¼å› å­ä»¥ä¾¿åœ¨ç¼©æ”¾å˜åŒ–æ—¶é‡æ–°è®¡ç®—ä½ç½®
            };

            // ä½¿ç”¨è¦†è“‹å±¤ç¹ªè£½é«˜äº®é»
            drawHighlightPointOnly();
        }

        function drawHighlightPointOnly() {
            if (!isProfileMode || !isProfileHovering || !profileHighlightPoint || !highlightContext) return;

            // æ¸…é™¤æ•´å€‹é«˜äº®å±¤
            highlightContext.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            // ä¿å­˜ç•¶å‰ç•«å¸ƒç‹€æ…‹
            highlightContext.save();

            // æ‡‰ç”¨èˆ‡åœ°åœ–ç›¸åŒçš„è®Šæ›
            // é€™è£¡çš„é—œéµæ˜¯ä½¿ç”¨èˆ‡drawProfileLineä¸­ç›¸åŒçš„è®Šæ›
            highlightContext.translate(mapOffset.x, mapOffset.y);
            highlightContext.translate(highlightCanvas.width / 2, highlightCanvas.height / 2);
            highlightContext.scale(currentScale, currentScale);
            highlightContext.translate(-highlightCanvas.width / 2, -highlightCanvas.height / 2);

            // ä½¿ç”¨æ’å€¼å› å­tæ¥ç¡®å®šé«˜äº®ç‚¹åœ¨çº¿æ®µä¸Šçš„ä½ç½®
            let x, y;

            if (profileHighlightPoint.t !== undefined && profilePoints.length === 2) {
                const t = profileHighlightPoint.t;

                // ä½¿ç”¨adjustedXå’ŒadjustedYï¼ˆåœ¨drawProfileLineä¸­è®¡ç®—å¥½çš„åæ ‡ï¼‰
                const p1 = profilePoints[0];
                const p2 = profilePoints[1];

                const x1 = p1.adjustedX !== undefined ? p1.adjustedX : p1.transformedX;
                const y1 = p1.adjustedY !== undefined ? p1.adjustedY : p1.transformedY;
                const x2 = p2.adjustedX !== undefined ? p2.adjustedX : p2.transformedX;
                const y2 = p2.adjustedY !== undefined ? p2.adjustedY : p2.transformedY;

                // çº¿æ€§æ’å€¼è®¡ç®—é«˜äº®ç‚¹ä½ç½®
                x = x1 + (x2 - x1) * t;
                y = y1 + (y2 - y1) * t;
            } else {
                // å¦‚æœæ²¡æœ‰æ’å€¼å› å­ï¼Œç›´æ¥ä½¿ç”¨ä¿å­˜çš„åæ ‡
                x = profileHighlightPoint.x;
                y = profileHighlightPoint.y;
            }

            // ç»˜åˆ¶é»„è‰²é«˜äº®ç‚¹
            highlightContext.beginPath();
            highlightContext.arc(x, y, 8 / currentScale, 0, 2 * Math.PI);
            highlightContext.fillStyle = '#ffff00'; // é»ƒè‰²
            highlightContext.strokeStyle = '#000000'; // é»‘è‰²é‚Šæ¡†
            highlightContext.lineWidth = 2 / currentScale;
            highlightContext.fill();
            highlightContext.stroke();

            // æ¢å¾©ç•«å¸ƒç‹€æ…‹
            highlightContext.restore();
        }

        function onMouseDown(event) {
            event.preventDefault();

            if (currentTool === 'addMarker') {
                addMarker(event);
                currentTool = null;
                controls.enabled = true;
                if (radiusIndicator) radiusIndicator.visible = false;
                if (mouseHelper) mouseHelper.visible = false;
                return;
            }

            if (currentTool) {
                isMouseDown = true;
                updateMousePosition(event);
                modifyTerrain();
            }
        }

         function onMouseMove(event) {
             event.preventDefault();
               updateMousePosition(event);
                   // æ›´æ–°ç‹€æ…‹æ¬„
                updateStatusBar(event);
               //  åœ¨æ¨™è¨»æ¨¡å¼ä¸‹ï¼Œéš±è—æ»‘é¼ å·¥å…·
                if(currentTool === 'addMarker') {
                   radiusIndicator.visible = false;
                   mouseHelper.visible = false;
                   return;
                }

               // åªåœ¨é¸æ“‡äº†å·¥å…·çš„æƒ…æ³ä¸‹é¡¯ç¤ºæŒ‡ç¤ºå™¨
                if (currentTool) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(terrain);
                    if (intersects.length > 0) {
                        updateRadiusIndicator(intersects[0].point);
                    } else {
                        radiusIndicator.visible = false;
                        mouseHelper.visible = false;
                    }

                   // å¦‚æœæ»‘é¼ æŒ‰ä½ï¼ŒæŒçºŒä¿®æ”¹åœ°å½¢
                    if (isMouseDown) {
                        modifyTerrain();
                    }
                }
           }

        function onMouseUp(event) {
               event.preventDefault();
               isMouseDown = false;
                if (currentTool) saveToHistory();
           }

        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function addMarker(event) {
            try {
                // è½‰æ›è§¸æ‘¸æˆ–æ»‘é¼ äº‹ä»¶åˆ°é©ç•¶çš„åº§æ¨™
                const coordinates = getEventCoordinates(event);

                // æ›´æ–°æ»‘é¼ ä½ç½®
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((coordinates.x - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((coordinates.y - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrain);

                if (intersects.length > 0) {
                    const point = intersects[0].point;

                    const markerDiv = document.createElement('div');
                    markerDiv.classList.add('marker');
                    markerDiv.style.position = 'absolute';
                    document.getElementById('canvas-container').appendChild(markerDiv);

                    const markerLabel = document.createElement('div');
                    markerLabel.classList.add('marker-label');
                    markerDiv.appendChild(markerLabel);

                    const markerTriangle = document.createElement('div');
                    markerTriangle.classList.add('marker-triangle');
                    markerDiv.appendChild(markerTriangle);

                    // ç‚ºè§¸æ§è¨­å‚™æ·»åŠ ç‰¹æ®Šçš„äº‹ä»¶è™•ç†
                    markerDiv.addEventListener('contextmenu', handleMarkerContextMenu);
                    markerDiv.addEventListener('touchstart', handleMarkerTouchStart);
                    markerDiv.addEventListener('touchend', handleMarkerTouchEnd);

                    let markerName = prompt('è«‹è¼¸å…¥æ¨™è¨˜åç¨±:', 'æ–°æ¨™è¨˜');
                    if (markerName === null || markerName === '') {
                        markerDiv.remove();
                        return;
                    }
                    markerLabel.textContent = markerName;

                    const newMarker = {
                        element: markerDiv,
                        position: point,
                        label: markerName
                    };

                    markers.push(newMarker);
                    updateMarkerPositions();
                }
            } catch (error) {
                console.error("æ·»åŠ æ¨™è¨˜éŒ¯èª¤:", error);
                alert("æ·»åŠ æ¨™è¨˜æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚");
            }
        }

        function getEventCoordinates(event) {
            if (event.touches && event.touches.length > 0) {
                return {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
            return {
                x: event.clientX,
                y: event.clientY
            };
        }

        // æ·»åŠ è§¸æ§äº‹ä»¶è™•ç†
        let touchTimer = null;
        let touchStartX = 0;
        let touchStartY = 0;

        function handleMarkerTouchStart(event) {
            event.preventDefault();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;

            touchTimer = setTimeout(() => {
                handleMarkerContextMenu({
                    preventDefault: () => {},
                    clientX: touchStartX,
                    clientY: touchStartY,
                    currentTarget: event.currentTarget,
                    stopPropagation: () => {}
                });
            }, 500);
        }

        function handleMarkerTouchEnd(event) {
            event.preventDefault();
            if (touchTimer) {
                clearTimeout(touchTimer);
            }

            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            const moveDistance = Math.sqrt(
                Math.pow(touchEndX - touchStartX, 2) +
                Math.pow(touchEndY - touchStartY, 2)
            );

            if (moveDistance < 10) {
                // å¯ä»¥æ·»åŠ è¼•è§¸è™•ç†é‚è¼¯
            }
        }


          function updateMarkerPositions() {
              markers.forEach(marker => {
                  // å°‡ 3D åæ¨™æŠ•å½±åˆ° 2D è¢å¹•åæ¨™
                  const screenPosition = marker.position.clone().project(camera);
                  const canvasRect = renderer.domElement.getBoundingClientRect();
                  const x = (screenPosition.x + 1) / 2 * canvasRect.width;
                  const y = (1 - screenPosition.y) / 2 * canvasRect.height;

                  // ä½¿ç”¨å°„ç·šæŠ•å°„é‡æ–°ç²å–æ¨™è¨»ä½ç½®çš„åœ°å½¢é«˜åº¦
                   raycaster.setFromCamera(screenPosition, camera);
                   const intersects = raycaster.intersectObject(terrain);

                  let markerWorldY = 0;
                  if(intersects.length > 0){
                       markerWorldY = intersects[0].point.y;
                   } else {
                          markerWorldY = marker.position.y;
                      }

                   const worldToScreen = marker.position.clone().project(camera);
                   const markerYOnScreen =  (1 - worldToScreen.y) / 2 * canvasRect.height;
                  const markerHeightOnScreen = (1 - (markerWorldY  - 0.01) - camera.position.y) / (camera.far - camera.near) * canvasRect.height;


                   // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
                  const distanceToCamera = camera.position.distanceTo(marker.position);
                  const baseScale = 1.5; // èª¿æ•´æ¨™è¨»é»˜èªå¤§å°
                  const scaleFactor = baseScale / (distanceToCamera * 0.008 + 1);

                   // æ›´æ–°æ¨™è¨»ä½ç½®ï¼Œä½¿ç”¨æ–°çš„é«˜åº¦è¨ˆç®—å’Œç¸®æ”¾
                   marker.element.style.left = `${x}px`;
                   marker.element.style.top = `${markerYOnScreen}px`;
                   marker.element.style.transform = `translate(-50%, calc(-100% + ${markerHeightOnScreen}px)) scale(${scaleFactor})`;
                  marker.element.style.pointerEvents = 'auto';
              });
          }

        function handleMarkerContextMenu(event) {
             event.preventDefault();
              // æ‰¾å‡ºé»æ“Šçš„æ¨™è¨˜
               const clickedMarker = markers.find(marker => marker.element === event.currentTarget);
              if (!clickedMarker) return;
               activeMarker = clickedMarker; // å„²å­˜ç›®å‰é»æ“Šçš„æ¨™è¨˜

             // é¡¯ç¤ºå³éµèœå–®
              const contextMenu = document.getElementById('contextMenu');
              contextMenu.style.display = 'block';
              contextMenu.style.left = `${event.clientX}px`;
              contextMenu.style.top = `${event.clientY}px`;

              // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°ç•«å¸ƒï¼Œé¿å…è§¸ç™¼å…¶ä»–äº‹ä»¶
             event.stopPropagation();
         }

         // ç·¨è¼¯æ¨™è¨˜äº‹ä»¶
        document.getElementById('editMarker').addEventListener('click', () => {
            if(activeMarker) {
                  const newLabel = prompt('è«‹è¼¸å…¥æ–°çš„æ¨™è¨˜åç¨±:', activeMarker.label);
                  if(newLabel !== null) {
                       activeMarker.label = newLabel;
                       activeMarker.element.querySelector('.marker-label').textContent = newLabel;
                  }
            }
            hideContextMenu();
        });

        // åˆªé™¤æ¨™è¨˜äº‹ä»¶
         document.getElementById('deleteMarker').addEventListener('click', () => {
             if (activeMarker) {
                  activeMarker.element.remove();
                 markers = markers.filter(marker => marker !== activeMarker);
             }
              hideContextMenu();
         });

        // é»æ“Šå…¶ä»–åœ°æ–¹éš±è—å³éµèœå–®
         document.addEventListener('click', hideContextMenu);

         // å®šç¾©éš±è—å³éµé¸å–®çš„å‡½æ•¸
         function hideContextMenu() {
             document.getElementById('contextMenu').style.display = 'none';
             activeMarker = null;
         }

        function modifyTerrain() {
             if (!currentTool || !isMouseDown) return;
             raycaster.setFromCamera(mouse, camera);
             const intersects = raycaster.intersectObject(terrain);
             if (intersects.length > 0) {
                 const intersection = intersects[0];
                 const positions = terrain.geometry.attributes.position.array;
                 const toolStrength = document.getElementById('tool-strength').value / 250;
                 const toolRadius = document.getElementById('tool-radius').value / 5;

                 const clickPosition = intersection.point;
                 const localClickPosition = clickPosition.clone();
                 terrain.worldToLocal(localClickPosition);

                 let terrainModified = false;

                 for (let i = 0; i < positions.length; i += 3) {
                     const vertexX = positions[i];
                     const vertexY = positions[i + 1];

                     const dx = vertexX - localClickPosition.x;
                     const dy = vertexY - localClickPosition.y;
                     const distance = Math.sqrt(dx * dx + dy * dy);

                     if (distance < toolRadius) {
                          const influence = Math.cos((distance / toolRadius) * Math.PI * 0.5);
                          const strength = toolStrength * influence;
                          let localModified = 0; // è¿½è¹¤å€åŸŸä¿®æ”¹é‡

                         switch (currentTool) {
                             case 'raise':
                                 localModified += strength;
                                 break;
                             case 'lower':
                                 localModified -= strength;
                                 break;
                             case 'smooth':
                                 const averageHeight = getAverageHeight(i, positions, toolRadius);
                                 localModified += (averageHeight - positions[i + 2]) * strength;
                                 break;
                          }
                           positions[i+2] += localModified;
                            terrainModified = true;
                     }
                 }


                 if (terrainModified) {
                    terrain.geometry.attributes.position.needsUpdate = true;
                    terrain.geometry.computeVertexNormals();
                    updateTerrainMaterial();
                 }
              }
         }

        function getAverageHeight(index, positions, radius) {
            let sum = 0;
            let count = 0;
            const vertexCount = positions.length / 3;
            const gridSize = Math.sqrt(vertexCount);
            const x = Math.floor((index / 3) % gridSize);
            const y = Math.floor((index / 3) / gridSize);

            const currentX = positions[index];
            const currentY = positions[index + 1];

            for (let i = 0; i < positions.length; i += 3) {
                const otherX = positions[i];
                const otherY = positions[i + 1];

                const dx = otherX - currentX;
                const dy = otherY - currentY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius) {
                    sum += positions[i + 2];
                    count++;
                }
            }

            return count > 0 ? sum / count : positions[index + 2];
        }

        function updateTerrainMaterial() {
            if (terrain && terrain.material.uniforms) {
                const positions = terrain.geometry.attributes.position.array;
                let minHeight = Infinity;
                let maxHeight = -Infinity;

                for (let i = 2; i < positions.length; i += 3) {
                    minHeight = Math.min(minHeight, positions[i]);
                    maxHeight = Math.max(maxHeight, positions[i]);
                }

                // å°‡ç­‰é«˜ç·šé–“è·å›ºå®šç‚º 20 ç±³ï¼ˆå› ç‚ºæœ‰ 10 å€çš„é«˜åº¦å€æ•¸ï¼Œæ‰€ä»¥é€™è£¡è¨­ç‚º 2.0ï¼‰
                terrain.material.uniforms.contourInterval.value = 2.0;  // æ”¹é€™è£¡
                terrain.material.uniforms.heightScale.value = 1.0;
                terrain.material.uniforms.maxHeight.value = maxHeight;
            }
        }

        function updateStatusBar(event) {
            const heightMultiplier = 10;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(terrain);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                const gridSpacing = 25;
                const eastingBase = 10;
                const northingBase = 65;

                // å°‡åº§æ¨™è½‰æ›ç‚ºæ­£æ•¸
                const gridX = point.x + 50;
                const gridZ = -point.z + 50;

                // 1. è¨ˆç®—æ±è¡Œç·šç·¨è™Ÿï¼ˆå‰å…©ä½æ•¸ï¼‰
                 const eastingLineNumber = Math.floor(gridX / gridSpacing) + eastingBase;

                // 2. è¨ˆç®—æ±è¡Œæ ¼ç¶²å…§çš„å°è¡Œä½ç½®ï¼ˆç¬¬ä¸‰ä½æ•¸ï¼Œä½¿ç”¨é¤˜æ•¸è¨ˆç®—åç§»é‡ï¼‰
                let eastingOffset = gridX % gridSpacing;
                let eastingSubLine = Math.floor((eastingOffset / gridSpacing) * 9) + 1;
                if (eastingSubLine > 9) eastingSubLine = 9;


               // 3. è¨ˆç®—åŒ—è¡Œç·šç·¨è™Ÿï¼ˆå¾Œå…©ä½æ•¸ï¼‰
                const northingLineNumber = Math.floor(gridZ / gridSpacing) + northingBase;

               // 4. è¨ˆç®—åŒ—è¡Œæ ¼ç¶²å…§çš„å°è¡Œä½ç½®ï¼ˆç¬¬å…­ä½æ•¸ï¼Œä½¿ç”¨é¤˜æ•¸è¨ˆç®—åç§»é‡ï¼Œä¸¦ç¢ºä¿ç”±å—åˆ°åŒ—éå¢ï¼‰
                let northingOffset = gridZ % gridSpacing;
                let northingSubLine = Math.floor((northingOffset / gridSpacing) * 9) + 1;
                if (northingSubLine > 9) northingSubLine = 9;

                 // 5. çµ„åˆå…­ä½æ•¸åº§æ¨™
                const eastingStr = String(eastingLineNumber).padStart(2, '0');
                const eastingSubLineStr = String(eastingSubLine).padStart(1, '0');
                const northingStr = String(northingLineNumber).padStart(2, '0');
                const northingSubLineStr = String(northingSubLine).padStart(1, '0');

                const gridCoordinate = `${eastingStr}${eastingSubLineStr}${northingStr}${northingSubLineStr}`;


                const heightValue = point.y * heightMultiplier;
                const z = heightValue.toFixed(1);

                const face = intersects[0].face;
                const normal = face.normal.clone();
                normal.applyQuaternion(terrain.quaternion);
                const slope = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0))) * (180 / Math.PI);

                const statusBar = document.querySelector('.status-bar');
                statusBar.textContent = `åº§æ¨™: ${gridCoordinate},  é«˜åº¦: ${z}m | å¡åº¦: ${slope.toFixed(1)}Â°`;
            }
        }

        function saveTerrain() {
            try {
                const positions = terrain.geometry.attributes.position.array;

                const terrainData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    vertexCount: positions.length,
                    positions: Array.from(positions),
                    metadata: {
                        gridSize: Math.sqrt(positions.length / 3),
                        terrainWidth: 100,
                        terrainHeight: 100
                    }
                };

                const jsonString = JSON.stringify(terrainData);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `terrain_${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.json`;

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                alert('åœ°å½¢å„²å­˜æˆåŠŸï¼');
            } catch (error) {
                console.error('å„²å­˜åœ°å½¢æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('å„²å­˜åœ°å½¢æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼');
            }
        }

        function loadTerrain(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const terrainData = JSON.parse(e.target.result);

                        if (!terrainData.version || !terrainData.positions) {
                            throw new Error('ç„¡æ•ˆçš„åœ°å½¢æ•¸æ“šæ ¼å¼');
                        }

                        const positions = terrain.geometry.attributes.position.array;
                        if (positions.length !== terrainData.positions.length) {
                            throw new Error('åœ°å½¢æ•¸æ“šå¤§å°ä¸åŒ¹é…');
                        }

                        for (let i = 0; i < positions.length; i++) {
                            positions[i] = terrainData.positions[i];
                        }

                        terrain.geometry.attributes.position.needsUpdate = true;
                        terrain.geometry.computeVertexNormals();
                        updateTerrainMaterial();

                        alert('åœ°å½¢è¼‰å…¥æˆåŠŸï¼');
                    } catch (error) {
                        console.error('è¼‰å…¥åœ°å½¢æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        alert('è¼‰å…¥åœ°å½¢æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            } catch (error) {
                console.error('è®€å–æ–‡ä»¶éŒ¯èª¤:', error);
                alert('è®€å–æ–‡ä»¶éŒ¯èª¤ï¼');
            }
        }

        function resetTerrain() {
           try {
               if (!confirm('ç¢ºå®šè¦é‡è¨­åœ°å½¢å—ï¼Ÿé€™å°‡æ¸…é™¤æ‰€æœ‰ä¿®æ”¹ã€‚')) return;

               const positions = terrain.geometry.attributes.position.array;
               for (let i = 0; i < positions.length; i++) {
                   positions[i] = initialTerrainPositions[i];
               }

               terrain.geometry.attributes.position.needsUpdate = true;
               terrain.geometry.computeVertexNormals();
               updateTerrainMaterial();

               terrainHistory = [];
               terrainHistoryIndex = -1;
               saveToHistory();

               alert('åœ°å½¢å·²é‡è¨­ï¼');
           } catch (error) {
               console.error('é‡è¨­åœ°å½¢éŒ¯èª¤:', error);
               alert('é‡è¨­åœ°å½¢æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼');
           }
        }

        // æª¢æŸ¥ç€è¦½å™¨æ˜¯å¦æ”¯æŒå…¨å±æ¨¡å¼
        function getFullscreenElement() {
            return document.fullscreenElement ||
                   document.webkitFullscreenElement ||
                   document.mozFullScreenElement ||
                   document.msFullscreenElement;
        }

        // è«‹æ±‚å…¨å±
        function requestFullscreen(element) {
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }

        // é€€å‡ºå…¨å±
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }

        // åˆ‡æ›å…¨å±æ¨¡å¼
        function toggleFullscreen() {
            if (!getFullscreenElement()) {
                requestFullscreen(document.documentElement);
                fullscreenBtn.classList.add('active-exit'); // ä½¿ç”¨é¡ååˆ‡æ›æ¨£å¼
            } else {
                exitFullscreen();
                fullscreenBtn.classList.remove('active-exit');
            }
        }

        // ç›£è½å…¨å±è®ŠåŒ–äº‹ä»¶
        function handleFullscreenChange() {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            if (!getFullscreenElement()) {
                fullscreenBtn.innerHTML = 'ğŸ”²<span class="tool-tooltip">å…¨å±æ¨¡å¼</span>';
            } else {
                fullscreenBtn.innerHTML = 'â›¶<span class="tool-tooltip">é€€å‡ºå…¨å±</span>';
            }
        }

        function initDrawingTools() {
            try {
                let lastX = 0;
                let lastY = 0;
                isDrawing = false;

                // å‰µå»ºç¹ªåœ–ç•«å¸ƒ
                drawingCanvas = document.createElement('canvas');
                drawingCanvas.style.position = 'absolute';
                drawingCanvas.style.top = '0';
                drawingCanvas.style.left = '0';
                // åˆå§‹æ™‚ç¦ç”¨ç¹ªåœ–åŠŸèƒ½ï¼Œè®“é¼ æ¨™äº‹ä»¶ç©¿é€åˆ° 3D å ´æ™¯
                drawingCanvas.style.pointerEvents = 'none';
                drawingCanvas.style.zIndex = '1';
                document.getElementById('canvas-container').appendChild(drawingCanvas);

                // è¨­ç½®ç•«å¸ƒå¤§å°
                function resizeCanvas() {
                    drawingCanvas.width = window.innerWidth;
                    drawingCanvas.height = window.innerHeight;
                    drawingContext = drawingCanvas.getContext('2d');
                    drawingContext.lineCap = 'round';
                    drawingContext.lineJoin = 'round';
                    drawingContext.lineWidth = 3;
                    drawingContext.globalCompositeOperation = 'source-over';

                    // é‡ç¹ªæ­·å²å…§å®¹
                    if (historyIndex >= 0 && drawingHistory[historyIndex] && drawingHistory[historyIndex].canvas) {
                        drawingContext.drawImage(drawingHistory[historyIndex].canvas, 0, 0);
                    }
                }

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // ç¹ªåœ–äº‹ä»¶è™•ç†
                function getEventCoordinates(e) {
                    if (e.touches && e.touches[0]) {
                        const rect = drawingCanvas.getBoundingClientRect();
                        return {
                            x: e.touches[0].clientX - rect.left,
                            y: e.touches[0].clientY - rect.top
                        };
                    }
                    return {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                }

                // æ·»åŠ  3D ç¹ªåœ–æ¨¡å¼åˆ‡æ›æŒ‰éˆ•äº‹ä»¶
                const draw3dToggleBtn = document.getElementById('draw3d-toggle');
                if (draw3dToggleBtn) {
                    draw3dToggleBtn.addEventListener('click', () => {
                        is3DDrawingMode = !is3DDrawingMode;
                        draw3dToggleBtn.classList.toggle('active');

                        // å¦‚æœé—œé–‰ 3D ç¹ªåœ–æ¨¡å¼ï¼Œæ¸…é™¤ç•¶å‰æœªå®Œæˆçš„ 3D ç·šæ¢
                        if (!is3DDrawingMode && tube3DMesh) {
                            scene.remove(tube3DMesh);
                            tube3DMesh = null;
                        }
                    });
                }

                // ç¹ªåœ–äº‹ä»¶è™•ç†
                function startDraw(e) {
                    e.preventDefault();
                    if (currentTool) return;
                    if (!document.querySelector('.color-btn.active') && !isErasing) return;

                    isDrawing = true;
                    const coords = getEventCoordinates(e);
                    [lastX, lastY] = [coords.x, coords.y];

                    if (is3DDrawingMode && !isErasing) {
                        // é–‹å§‹æ–°çš„ 3D ç¹ªåœ–ï¼Œä½†ä¸åˆªé™¤ä¹‹å‰çš„ç·šæ¢
                        drawingPoints = []; // åªé‡ç½®ç•¶å‰ç¹ªåœ–é»
                        const point = get3DPointFromMouse(coords);
                        if (point) {
                            drawingPoints.push(point);
                        }
                    } else {
                        // åŸæœ‰çš„ 2D ç¹ªåœ–é‚è¼¯
                        drawingContext.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
                        drawingContext.lineWidth = isErasing ? document.getElementById('eraser-size').value * 2 : 3;
                        if(historyIndex === -1) saveToHistory();
                    }
                }

                function draw(e) {
                    e.preventDefault();
                    if (!isDrawing || currentTool) return;

                    const coords = getEventCoordinates(e);

                    if (is3DDrawingMode && !isErasing) {
                        // 3D ç¹ªåœ–
                        const point = get3DPointFromMouse(coords);
                        if (point) {
                            drawingPoints.push(point);
                            update3DTube();
                        }
                    } else {
                        // åŸæœ‰çš„ 2D ç¹ªåœ–é‚è¼¯
                        drawingContext.beginPath();
                        drawingContext.moveTo(lastX, lastY);
                        drawingContext.lineTo(coords.x, coords.y);
                        drawingContext.strokeStyle = isErasing ? 'rgba(0,0,0,1)' : currentColor;
                        drawingContext.stroke();
                        [lastX, lastY] = [coords.x, coords.y];
                    }
                }

                function stopDraw() {
                    if (isDrawing) {
                        isDrawing = false;
                        if (is3DDrawingMode && tube3DMesh) {
                            tube3DMeshes.push(tube3DMesh);
                            save3DHistory();
                            tube3DMesh = null;
                        } else if (!is3DDrawingMode) {
                            saveToHistory();
                        }
                    }
                }

                // ç¶å®šé¼ æ¨™äº‹ä»¶
                drawingCanvas.addEventListener('mousedown', startDraw);
                drawingCanvas.addEventListener('mousemove', draw);
                drawingCanvas.addEventListener('mouseup', stopDraw);
                drawingCanvas.addEventListener('mouseout', stopDraw);

                // ç¶å®šè§¸æ§äº‹ä»¶
                drawingCanvas.addEventListener('touchstart', startDraw, { passive: false });
                drawingCanvas.addEventListener('touchmove', draw, { passive: false });
                drawingCanvas.addEventListener('touchend', stopDraw);
                drawingCanvas.addEventListener('touchcancel', stopDraw);

                // æ·»åŠ æ©¡çš®æ“¦ç¯„åœæŒ‡ç¤ºå™¨
                const eraserIndicator = document.createElement('div');
                eraserIndicator.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    border: 2px solid rgba(0, 0, 0, 0.8);
                    border-radius: 50%;
                    display: none;
                    z-index: 1000;
                `;
                document.body.appendChild(eraserIndicator);

                // æ›´æ–°æ©¡çš®æ“¦æŒ‡ç¤ºå™¨ä½ç½®å’Œå¤§å°çš„å‡½æ•¸
                function updateEraserIndicator(e) {
                    if (isErasing) {
                        const size = document.getElementById('eraser-size').value * 2;
                        eraserIndicator.style.width = `${size}px`;
                        eraserIndicator.style.height = `${size}px`;
                        eraserIndicator.style.left = `${e.clientX - size/2}px`;
                        eraserIndicator.style.top = `${e.clientY - size/2}px`;
                        eraserIndicator.style.display = 'block';
                    } else {
                        eraserIndicator.style.display = 'none';
                    }
                }

                // åœ¨ç•«å¸ƒä¸Šæ·»åŠ é¼ æ¨™ç§»å‹•äº‹ä»¶
                drawingCanvas.addEventListener('mousemove', updateEraserIndicator);
                drawingCanvas.addEventListener('mouseenter', updateEraserIndicator);
                drawingCanvas.addEventListener('mouseleave', () => {
                    eraserIndicator.style.display = 'none';
                });

                // æ©¡çš®æ“¦æŒ‰éˆ•äº‹ä»¶
                const eraserBtn = document.getElementById('eraser-btn');
                if (eraserBtn) {
                    eraserBtn.addEventListener('click', () => {
                        if (is3DDrawingMode) {
                            isErasing = !isErasing;
                            eraserBtn.classList.toggle('active');

                            // æ›´æ–°é¼ æ¨™æ¨£å¼
                            renderer.domElement.style.cursor = isErasing ? 'crosshair' : 'default';

                            // ç¦ç”¨/å•Ÿç”¨è»Œé“æ§åˆ¶å™¨
                            controls.enabled = !isErasing;

                            // é‡ç½®å…¶ä»–å·¥å…·ç‹€æ…‹
                            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                            drawingCanvas.style.pointerEvents = 'none';
                        } else {
                            // åŸæœ‰çš„ 2D æ©¡çš®æ“¦é‚è¼¯
                            isErasing = !isErasing;
                            eraserBtn.classList.toggle('active');
                            drawingCanvas.style.cursor = isErasing ? 'crosshair' : 'default';
                        }
                    });
                }

                // ç‚ºæ©¡çš®æ“¦å¤§å°æ»‘å¡Šæ·»åŠ äº‹ä»¶ç›£è½å™¨
                const eraserSize = document.getElementById('eraser-size');
                if (eraserSize) {
                    eraserSize.addEventListener('input', (e) => {
                        if (isErasing) {
                            const size = e.target.value * 2;
                            eraserIndicator.style.width = `${size}px`;
                            eraserIndicator.style.height = `${size}px`;
                            drawingContext.lineWidth = size;
                        }
                    });
                }

                // ä¿®æ”¹é¡è‰²æŒ‰éˆ•äº‹ä»¶
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // å¦‚æœç•¶å‰é¡è‰²å·²ç¶“è¢«é¸ä¸­ï¼Œå‰‡å–æ¶ˆé¸ä¸­ä¸¦æ¢å¾©é»˜èªç‹€æ…‹
                        if (btn.classList.contains('active')) {
                            btn.classList.remove('active');
                            drawingCanvas.style.pointerEvents = 'none';
                            controls.enabled = true;
                            isDrawing = false;
                            return;
                        }

                        // é‡ç½®æ‰€æœ‰å·¥å…·ç‹€æ…‹
                        resetTerrainTools();

                        // è¨­ç½®æ–°çš„ç¹ªåœ–ç‹€æ…‹
                        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentColor = btn.dataset.color;
                        isErasing = false;
                        document.getElementById('eraser-btn').classList.remove('active');

                        // å•Ÿç”¨ç¹ªåœ–åŠŸèƒ½
                        drawingCanvas.style.pointerEvents = 'auto';
                        controls.enabled = false;
                        isDrawing = false;
                    });
                });

                // ä¸Šä¸€æ­¥æŒ‰éˆ•
                const undoBtn = document.getElementById('undo-btn');
                if (undoBtn) {
                    undoBtn.addEventListener('click', () => {
                        if (is3DDrawingMode && tube3DMeshHistoryIndex > 0) {
                            tube3DMeshHistoryIndex--;

                            // æ¸…é™¤ç•¶å‰å ´æ™¯ä¸­çš„æ‰€æœ‰ 3D ç·šæ¢
                            tube3DMeshes.forEach(mesh => scene.remove(mesh));
                            tube3DMeshes = [];

                            // æ¢å¾©ä¸Šä¸€å€‹ç‹€æ…‹
                            const previousState = tube3DMeshHistory[tube3DMeshHistoryIndex];
                            previousState.forEach(meshData => {
                                const mesh = new THREE.Mesh(
                                    meshData.geometry,
                                    meshData.material
                                );
                                mesh.position.copy(meshData.position);
                                mesh.rotation.copy(meshData.rotation);
                                mesh.scale.copy(meshData.scale);
                                scene.add(mesh);
                                tube3DMeshes.push(mesh);
                            });
                        } else if (!is3DDrawingMode) {
                            // åŸæœ‰çš„ 2D ä¸Šä¸€æ­¥é‚è¼¯
                            if (historyIndex > 0) {
                                historyIndex--;
                                redrawCanvas();
                            }
                        }
                    });
                }

                // ä¸‹ä¸€æ­¥æŒ‰éˆ•
                const redoBtn = document.getElementById('redo-btn');
                if (redoBtn) {
                    redoBtn.addEventListener('click', () => {
                        if (is3DDrawingMode && tube3DMeshHistoryIndex < tube3DMeshHistory.length - 1) {
                            tube3DMeshHistoryIndex++;

                            // æ¸…é™¤ç•¶å‰å ´æ™¯ä¸­çš„æ‰€æœ‰ 3D ç·šæ¢
                            tube3DMeshes.forEach(mesh => scene.remove(mesh));
                            tube3DMeshes = [];

                            // æ¢å¾©ä¸‹ä¸€å€‹ç‹€æ…‹
                            const nextState = tube3DMeshHistory[tube3DMeshHistoryIndex];
                            nextState.forEach(meshData => {
                                const mesh = new THREE.Mesh(
                                    meshData.geometry,
                                    meshData.material
                                );
                                mesh.position.copy(meshData.position);
                                mesh.rotation.copy(meshData.rotation);
                                mesh.scale.copy(meshData.scale);
                                scene.add(mesh);
                                tube3DMeshes.push(mesh);
                            });
                        } else if (!is3DDrawingMode) {
                            // åŸæœ‰çš„ 2D ä¸‹ä¸€æ­¥é‚è¼¯
                            if (historyIndex < drawingHistory.length - 1) {
                                historyIndex++;
                                redrawCanvas();
                            }
                        }
                    });
                }

                // æ¸…é™¤æŒ‰éˆ•
                const clearBtn = document.getElementById('clear-btn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰ç¹ªåœ–å…§å®¹å—ï¼Ÿ')) {
                            if (is3DDrawingMode) {
                                // æ¸…é™¤æ‰€æœ‰ 3D ç·šæ¢
                                tube3DMeshes.forEach(mesh => scene.remove(mesh));
                                tube3DMeshes = [];
                                if (tube3DMesh) {
                                    scene.remove(tube3DMesh);
                                    tube3DMesh = null;
                                }

                                // æ›´æ–°æ­·å²è¨˜éŒ„
                                save3DHistory();
                            } else {
                                // æ¸…é™¤ 2D ç¹ªåœ–
                                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                                drawingHistory = [];
                                historyIndex = -1;
                                saveToHistory();
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("åˆå§‹åŒ–ç¹ªåœ–å·¥å…·éŒ¯èª¤:", error);
            }
        }

        function saveToHistory() {
            try {
                // è¤‡è£½åœ°å½¢æ•¸æ“š
                if (terrain && terrain.geometry && terrain.geometry.attributes.position) {
                    const terrainPositions = terrain.geometry.attributes.position.array;
                    const newTerrainPositions = new Float32Array(terrainPositions);

                    if (currentTool === 'raise' || currentTool === 'lower' || currentTool === 'smooth') {
                        // ç§»é™¤ç•¶å‰ä½ç½®ä¹‹å¾Œçš„åœ°å½¢æ­·å²è¨˜éŒ„
                        terrainHistory = terrainHistory.slice(0, terrainHistoryIndex + 1);
                        terrainHistory.push({
                            type: 'terrain',
                            data: newTerrainPositions,
                            drawingIndex: historyIndex, // å„²å­˜ç¹ªåœ–ç´¢å¼•
                        });
                        terrainHistoryIndex++;
                    } else if (drawingCanvas && drawingContext) {
                        // ç§»é™¤ç•¶å‰ä½ç½®ä¹‹å¾Œçš„ç¹ªåœ–æ­·å²è¨˜éŒ„
                        drawingHistory = drawingHistory.slice(0, historyIndex + 1);

                        // å‰µå»ºæ–°çš„ç•«å¸ƒä¸¦è¤‡è£½ç•¶å‰å…§å®¹
                        const newCanvas = document.createElement('canvas');
                        newCanvas.width = drawingCanvas.width || 0;
                        newCanvas.height = drawingCanvas.height || 0;

                        // åªæœ‰ç•¶ç•«å¸ƒæœ‰å°ºå¯¸æ™‚æ‰è¤‡è£½
                        if (newCanvas.width > 0 && newCanvas.height > 0) {
                            newCanvas.getContext('2d').drawImage(drawingCanvas, 0, 0);
                        }

                        // æ·»åŠ åˆ°æ­·å²è¨˜éŒ„ (åŒ…å«ç•«å¸ƒ)
                        drawingHistory.push({
                            type: 'drawing',
                            canvas: newCanvas,
                            terrainIndex: terrainHistoryIndex, //å„²å­˜åœ°å½¢ç´¢å¼•
                        });
                        historyIndex++;
                    }
                }
            } catch (error) {
                console.error("ä¿å­˜æ­·å²è¨˜éŒ„éŒ¯èª¤:", error);
            }
        }


        function redrawCanvas() {
            try {
                if (currentTool === 'raise' || currentTool === 'lower' || currentTool === 'smooth') {
                    // é‚„åŸåœ°å½¢æ•¸æ“š
                    if (terrainHistoryIndex >= 0 && terrainHistory[terrainHistoryIndex]?.data) {
                        const terrainPositions = terrain.geometry.attributes.position.array;
                        const savedTerrainPositions = terrainHistory[terrainHistoryIndex].data;

                        for (let i = 0; i < terrainPositions.length; i++) {
                            terrainPositions[i] = savedTerrainPositions[i];
                        }
                        terrain.geometry.attributes.position.needsUpdate = true;
                        terrain.geometry.computeVertexNormals();
                        updateTerrainMaterial();

                        if (terrainHistory[terrainHistoryIndex].drawingIndex !== undefined &&
                            terrainHistory[terrainHistoryIndex].drawingIndex !== -1) {
                            historyIndex = terrainHistory[terrainHistoryIndex].drawingIndex;
                        }
                    }
                } else if (drawingCanvas && drawingContext) {
                    drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    if (historyIndex >= 0 && drawingHistory[historyIndex]?.canvas) {
                        const canvas = drawingHistory[historyIndex].canvas;
                        if (canvas.width > 0 && canvas.height > 0) { // ç¢ºä¿ç•«å¸ƒæœ‰å°ºå¯¸
                            drawingContext.drawImage(canvas, 0, 0);
                        }
                        if (drawingHistory[historyIndex].terrainIndex !== undefined) {
                            terrainHistoryIndex = drawingHistory[historyIndex].terrainIndex;
                        }
                    }
                }
            } catch (error) {
                console.error("é‡ç¹ªç•«å¸ƒéŒ¯èª¤:", error);
            }
        }

        // 2Dåœ°åœ–ç¹ªåœ–å·¥å…·åˆå§‹åŒ–
        function initMapDrawingTools() {
            try {
                // åˆå§‹åŒ– 2D åœ°åœ–ç¹ªåœ–ç•«å¸ƒ
                mapDrawingCanvas = document.getElementById('map-drawing-canvas');
                mapDrawingContext = mapDrawingCanvas.getContext('2d');
                // ç¡®ä¿ç»˜å›¾ç”»å¸ƒä¸åœ°å›¾ç”»å¸ƒæœ‰ç›¸åŒçš„å˜æ¢åŸç‚¹
                mapDrawingCanvas.style.transformOrigin = '0 0';

                // è¨­ç½®ç•«å¸ƒå¤§å°
                function resizeMapCanvas() {
                    const mapContainer = document.getElementById('map-container');
                    mapDrawingCanvas.width = mapContainer.offsetWidth;
                    mapDrawingCanvas.height = mapContainer.offsetHeight;

                    // è¨­ç½®ç¹ªåœ–ä¸Šä¸‹æ–‡å±¬æ€§
                    mapDrawingContext.lineCap = 'round';
                    mapDrawingContext.lineJoin = 'round';
                    mapDrawingContext.lineWidth = 3;

                    // é‡ç¹ªæ­·å²å…§å®¹
                    if (mapHistoryIndex >= 0 && mapDrawingHistory[mapHistoryIndex]) {
                        mapDrawingContext.drawImage(mapDrawingHistory[mapHistoryIndex], 0, 0);
                    }
                }

                // åˆå§‹èª¿æ•´ç•«å¸ƒå¤§å°
                resizeMapCanvas();

                // ç•¶çª—å£å¤§å°æ”¹è®Šæ™‚é‡æ–°èª¿æ•´
                window.addEventListener('resize', resizeMapCanvas);

                // ç¹ªåœ–å·¥å…·æ¬„
                const mapDrawingToolbar = document.querySelector('.map-drawing-toolbar');

                // ç¹ªåœ–äº‹ä»¶è®Šé‡
                let lastMapX = 0;
                let lastMapY = 0;

                // å–å¾—äº‹ä»¶åæ¨™
                function getMapEventCoordinates(e) {
                    if (e.touches && e.touches[0]) {
                        const rect = mapDrawingCanvas.getBoundingClientRect();
                        return {
                            x: e.touches[0].clientX - rect.left,
                            y: e.touches[0].clientY - rect.top
                        };
                    }
                    return {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                }

                // é–‹å§‹ç¹ªåœ–
                function startMapDraw(e) {
                    if (isProfileMode || isPolylineMode) return;

                    if (!document.querySelector('.map-color-btn.active') && !isMapErasing) return;

                    e.preventDefault();
                    e.stopPropagation();

                    isMapDrawing = true;
                    isDraggingMap = false;

                    const coords = getMapEventCoordinates(e);
                    [lastMapX, lastMapY] = [coords.x, coords.y];

                    // è¨­ç½®ç¹ªåœ–æ¨¡å¼
                    mapDrawingContext.globalCompositeOperation = isMapErasing ? 'destination-out' : 'source-over';
                    mapDrawingContext.lineWidth = isMapErasing ? document.getElementById('eraser-size').value * 2 : 3;

                    // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ç¹ªåœ–ï¼Œä¿å­˜åˆå§‹ç©ºç™½ç‹€æ…‹
                    if (mapHistoryIndex === -1) {
                        saveMapDrawingToHistory();
                    }
                }

                // ç¹ªåœ–éç¨‹
                function mapDraw(e) {
                    if (!isMapDrawing) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const coords = getMapEventCoordinates(e);

                    mapDrawingContext.beginPath();
                    mapDrawingContext.moveTo(lastMapX, lastMapY);
                    mapDrawingContext.lineTo(coords.x, coords.y);
                    mapDrawingContext.strokeStyle = isMapErasing ? 'rgba(0,0,0,1)' : mapCurrentColor;
                    mapDrawingContext.stroke();

                    [lastMapX, lastMapY] = [coords.x, coords.y];
                }

                // çµæŸç¹ªåœ–
                function stopMapDraw(e) {
                    if (isMapDrawing) {
                        e.preventDefault();
                        e.stopPropagation();

                        isMapDrawing = false;
                        saveMapDrawingToHistory();
                    }
                }

                // ä¿å­˜ç¹ªåœ–æ­·å²
                function saveMapDrawingToHistory() {
                    // ç§»é™¤ç•¶å‰ä½ç½®ä¹‹å¾Œçš„æ­·å²è¨˜éŒ„
                    mapDrawingHistory = mapDrawingHistory.slice(0, mapHistoryIndex + 1);

                    // å‰µå»ºæ–°çš„ç•«å¸ƒä¸¦è¤‡è£½ç•¶å‰å…§å®¹
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = mapDrawingCanvas.width;
                    newCanvas.height = mapDrawingCanvas.height;

                    // åªæœ‰ç•¶ç•«å¸ƒæœ‰å°ºå¯¸æ™‚æ‰è¤‡è£½
                    if (newCanvas.width > 0 && newCanvas.height > 0) {
                        newCanvas.getContext('2d').drawImage(mapDrawingCanvas, 0, 0);
                    }

                    // æ·»åŠ åˆ°æ­·å²è¨˜éŒ„
                    mapDrawingHistory.push(newCanvas);
                    mapHistoryIndex++;
                }

                // é‡ç¹ªç•«å¸ƒ
                function redrawMapDrawing() {
                    mapDrawingContext.clearRect(0, 0, mapDrawingCanvas.width, mapDrawingCanvas.height);

                    if (mapHistoryIndex >= 0 && mapDrawingHistory[mapHistoryIndex]) {
                        const canvas = mapDrawingHistory[mapHistoryIndex];
                        if (canvas.width > 0 && canvas.height > 0) {
                            mapDrawingContext.drawImage(canvas, 0, 0);
                        }
                    }
                }

                // æ·»åŠ äº‹ä»¶ç›£è½å™¨
                mapDrawingCanvas.addEventListener('mousedown', startMapDraw);
                mapDrawingCanvas.addEventListener('mousemove', mapDraw);
                mapDrawingCanvas.addEventListener('mouseup', stopMapDraw);
                mapDrawingCanvas.addEventListener('mouseleave', stopMapDraw);

                // è§¸æ§äº‹ä»¶
                mapDrawingCanvas.addEventListener('touchstart', startMapDraw, { passive: false });
                mapDrawingCanvas.addEventListener('touchmove', mapDraw, { passive: false });
                mapDrawingCanvas.addEventListener('touchend', stopMapDraw, { passive: false });
                mapDrawingCanvas.addEventListener('touchcancel', stopMapDraw, { passive: false });

                // æ·»åŠ æ©¡çš®æ“¦ç¯„åœæŒ‡ç¤ºå™¨
                const mapEraserIndicator = document.createElement('div');
                mapEraserIndicator.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    border: 2px solid rgba(0, 0, 0, 0.8);
                    border-radius: 50%;
                    display: none;
                    z-index: 1000;
                `;
                document.body.appendChild(mapEraserIndicator);

                // æ›´æ–°æ©¡çš®æ“¦æŒ‡ç¤ºå™¨
                function updateMapEraserIndicator(e) {
                    if (isMapErasing) {
                        const size = document.getElementById('eraser-size').value * 2;
                        mapEraserIndicator.style.width = `${size}px`;
                        mapEraserIndicator.style.height = `${size}px`;
                        mapEraserIndicator.style.left = `${e.clientX - size/2}px`;
                        mapEraserIndicator.style.top = `${e.clientY - size/2}px`;
                        mapEraserIndicator.style.display = 'block';
                    } else {
                        mapEraserIndicator.style.display = 'none';
                    }
                }

                // æ©¡çš®æ“¦äº‹ä»¶
                mapDrawingCanvas.addEventListener('mousemove', updateMapEraserIndicator);
                mapDrawingCanvas.addEventListener('mouseenter', updateMapEraserIndicator);
                mapDrawingCanvas.addEventListener('mouseleave', () => {
                    mapEraserIndicator.style.display = 'none';
                });

                // ç¹ªåœ–æŒ‰éˆ•é»æ“Šäº‹ä»¶
                document.querySelectorAll('.map-color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // å¦‚æœç•¶å‰é¡è‰²å·²é¸ä¸­ï¼Œå‰‡å–æ¶ˆé¸ä¸­
                        if (btn.classList.contains('active')) {
                            btn.classList.remove('active');
                            mapDrawingCanvas.style.pointerEvents = 'none';
                            isMapDrawing = false;
                            return;
                        }

                        // é‡ç½®å…¶ä»–å·¥å…·ç‹€æ…‹
                        resetMapDrawingTools();

                        // è¨­ç½®æ–°çš„ç¹ªåœ–ç‹€æ…‹
                        document.querySelectorAll('.map-color-btn').forEach(b =>
                            b.classList.remove('active'));
                        btn.classList.add('active');
                        mapCurrentColor = btn.dataset.color;
                        isMapErasing = false;

                        const mapEraserBtn = document.getElementById('map-eraser-btn');
                        if (mapEraserBtn) mapEraserBtn.classList.remove('active');

                        // å•Ÿç”¨ç¹ªåœ–åŠŸèƒ½
                        mapDrawingCanvas.style.pointerEvents = 'auto';
                        mapDrawingCanvas.style.cursor = 'crosshair';
                    });
                });

                // æ©¡çš®æ“¦æŒ‰éˆ•äº‹ä»¶
                const mapEraserBtn = document.getElementById('map-eraser-btn');
                if (mapEraserBtn) {
                    mapEraserBtn.addEventListener('click', () => {
                        resetMapDrawingTools();

                        isMapErasing = !isMapErasing;
                        mapEraserBtn.classList.toggle('active');

                        if (isMapErasing) {
                            mapDrawingCanvas.style.pointerEvents = 'auto';
                            mapDrawingCanvas.style.cursor = 'crosshair';
                        } else {
                            mapDrawingCanvas.style.pointerEvents = 'none';
                            mapDrawingCanvas.style.cursor = 'default';
                        }
                    });
                }

                // æ’¤éŠ·æŒ‰éˆ•äº‹ä»¶
                const mapUndoBtn = document.getElementById('map-undo-btn');
                if (mapUndoBtn) {
                    mapUndoBtn.addEventListener('click', () => {
                        if (mapHistoryIndex > 0) {
                            mapHistoryIndex--;
                            redrawMapDrawing();
                        }
                    });
                }

                // é‡åšæŒ‰éˆ•äº‹ä»¶
                const mapRedoBtn = document.getElementById('map-redo-btn');
                if (mapRedoBtn) {
                    mapRedoBtn.addEventListener('click', () => {
                        if (mapHistoryIndex < mapDrawingHistory.length - 1) {
                            mapHistoryIndex++;
                            redrawMapDrawing();
                        }
                    });
                }

                // æ¸…é™¤æŒ‰éˆ•äº‹ä»¶
                const mapClearBtn = document.getElementById('map-clear-btn');
                if (mapClearBtn) {
                    mapClearBtn.addEventListener('click', () => {
                        if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰ç¹ªåœ–å…§å®¹å—ï¼Ÿ')) {
                            mapDrawingContext.clearRect(0, 0, mapDrawingCanvas.width, mapDrawingCanvas.height);
                            mapDrawingHistory = [];
                            mapHistoryIndex = -1;
                            saveMapDrawingToHistory();
                        }
                    });
                }
            } catch (error) {
                console.error("åˆå§‹åŒ–åœ°åœ–ç¹ªåœ–å·¥å…·éŒ¯èª¤:", error);
            }
        }

        // é‡ç½®2Dåœ°åœ–ç¹ªåœ–å·¥å…·ç‹€æ…‹
        function resetMapDrawingTools() {
            isMapDrawing = false;
            isMapErasing = false;

            // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
            document.querySelectorAll('.map-drawing-toolbar .tool-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // ç¦ç”¨ç¹ªåœ–åŠŸèƒ½
            const mapDrawingCanvas = document.getElementById('map-drawing-canvas');
            if (mapDrawingCanvas) {
                mapDrawingCanvas.style.pointerEvents = 'none';
                mapDrawingCanvas.style.cursor = 'default';
            }

            // éš±è—æ©¡çš®æ“¦æŒ‡ç¤ºå™¨
            const mapEraserIndicator = document.querySelector('div[style*="border-radius: 50%"]');
            if (mapEraserIndicator) {
                mapEraserIndicator.style.display = 'none';
            }
        }

        // æ·»åŠ ä¸€å€‹è¼”åŠ©å‡½æ•¸ä¾†é‡ç½®åœ°å½¢å·¥å…·ç‹€æ…‹
        function resetTerrainTools() {
            currentTool = null;
            isDrawing = false;  // æ·»åŠ é€™è¡Œ

            // é‡ç½®æ‰€æœ‰å·¥å…·æŒ‰éˆ•ç‹€æ…‹ï¼ˆåŒ…æ‹¬åœ°å½¢å·¥å…·å’Œç¹ªåœ–å·¥å…·ï¼‰
            document.querySelectorAll('.tool-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // åœç”¨ç¹ªåœ–åŠŸèƒ½
            drawingCanvas.style.pointerEvents = 'none';
            isErasing = false;

            // å•Ÿç”¨ç›¸æ©Ÿæ§åˆ¶
            if (controls) controls.enabled = true;

            // éš±è—åœ°å½¢å·¥å…·æŒ‡ç¤ºå™¨
            if (radiusIndicator) radiusIndicator.visible = false;
            if (mouseHelper) mouseHelper.visible = false;

            // éš±è—æ©¡çš®æ“¦æŒ‡ç¤ºå™¨
            const eraserIndicator = document.querySelector('div[style*="border-radius: 50%"]');
            if (eraserIndicator) {
                eraserIndicator.style.display = 'none';
            }
        }

        // æ·»åŠ 2Dåœ°å›¾çš„é¼ æ ‡ç§»åŠ¨äº‹ä»¶ç›‘å¬å™¨
        mapCanvas.addEventListener('mousemove', (e) => {
            // å§‹ç»ˆæ›´æ–°é¼ æ ‡æ ·å¼ï¼Œç¡®ä¿æ•´ä¸ªç”»å¸ƒéƒ½æ˜¯grabæ ·å¼
            if (!isDraggingMap && !isProfileMode && !isMapDrawing && !isMapErasing && !isPolylineMode) {
                mapCanvas.style.cursor = 'grab';
            }

            // æ›´æ–°çŠ¶æ€æ ï¼Œå³ä½¿åœ¨æ‹–åŠ¨çŠ¶æ€ä¹Ÿæ˜¾ç¤ºåæ ‡
            if (isMapMode) {
                updateMapStatusBar(e);
            }
        });

        // æ›´æ–°2Dåœ°å›¾çŠ¶æ€æ å‡½æ•°
        function updateMapStatusBar(event) {
            try {
                const mapCanvas = document.getElementById('map-canvas');
                const rect = mapCanvas.getBoundingClientRect();

                // è·å–é¼ æ ‡åœ¨è§†çª—ä¸­çš„ä½ç½®
                const clientX = event.clientX;
                const clientY = event.clientY;

                // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºå˜æ¢åç”»å¸ƒçš„ä½ç½®
                const mouseX = clientX - rect.left;
                const mouseY = clientY - rect.top;

                // å› ä¸ºç”»å¸ƒæ˜¯ç»è¿‡ç¼©æ”¾å’Œå¹³ç§»çš„ï¼Œéœ€è¦å°†é¼ æ ‡åæ ‡è½¬å›"ç”»å¸ƒåæ ‡ç³»"
                const canvasCenterX = mapCanvas.width / 2;
                const canvasCenterY = mapCanvas.height / 2;

                // ç§»é™¤åç§»å¹¶è€ƒè™‘ç¼©æ”¾
                const withoutOffsetX = mouseX - mapOffset.x;
                const withoutOffsetY = mouseY - mapOffset.y;

                // è€ƒè™‘ç¼©æ”¾ï¼ˆç›¸å¯¹äºä¸­å¿ƒç‚¹ï¼‰
                const transformedX = canvasCenterX + (withoutOffsetX - canvasCenterX) / currentScale;
                const transformedY = canvasCenterY + (withoutOffsetY - canvasCenterY) / currentScale;

                // ä»¥ä¸‹è®¡ç®—åœ°å½¢åæ ‡
                const gridSegments = 100;
                const terrainSizeMeters = 100;

                // è®¡ç®—åŸºæœ¬ç»˜åˆ¶å°ºå¯¸å’Œåç§»
                const maxSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                const pixelSize = maxSize / gridSegments;
                const offsetX = (mapCanvas.width - gridSegments * pixelSize) / 2;
                const offsetY = (mapCanvas.height - gridSegments * pixelSize) / 2;

                // å°†ç”»å¸ƒåæ ‡è½¬æ¢ä¸ºåœ°å½¢åæ ‡
                const terrainX = ((transformedX - offsetX) / pixelSize) * (terrainSizeMeters / gridSegments) - 50;
                const terrainZ = -((transformedY - offsetY) / pixelSize) * (terrainSizeMeters / gridSegments) + 50; {

                  // ä»åœ°å½¢æ•°æ®è·å–é«˜åº¦
                  const positions = terrain.geometry.attributes.position.array;

                  // è®¡ç®—åœ°å½¢ä¸Šçš„ç´¢å¼•
                  const normalizedX = (terrainX + 50) / terrainSizeMeters * gridSegments;
                  const normalizedZ = (terrainZ + 50) / terrainSizeMeters * gridSegments;

                  // ä½¿ç”¨åŒçº¿æ€§æ’å€¼è·å–é«˜åº¦
                  const height = bilinearInterpolate(positions, gridSegments + 1, normalizedX, normalizedZ) * heightMultiplier;

                    // è®¡ç®—å…­ä½æ•°åæ ‡
                    const gridSpacing = 25;
                    const eastingBase = 10;
                    const northingBase = 65;

                    // å°†åœ°å½¢åæ ‡è½¬æ¢ä¸ºæ­£æ•°
                    const gridX = terrainX + 50;
                    const gridZ = terrainZ + 50;

                    // 1. è®¡ç®—ä¸œè¡Œçº¿ç¼–å·ï¼ˆå‰ä¸¤ä½æ•°ï¼‰
                    const eastingLineNumber = Math.floor(gridX / gridSpacing) + eastingBase;

                    // 2. è®¡ç®—ä¸œè¡Œæ ¼ç½‘å†…çš„å°è¡Œä½ç½®ï¼ˆç¬¬ä¸‰ä½æ•°ï¼‰
                    let eastingOffset = gridX % gridSpacing;
                    let eastingSubLine = Math.floor((eastingOffset / gridSpacing) * 9) + 1;
                    if (eastingSubLine > 9) eastingSubLine = 9;

                    // 3. è®¡ç®—åŒ—è¡Œçº¿ç¼–å·ï¼ˆåä¸¤ä½æ•°ï¼‰
                    const northingLineNumber = Math.floor(gridZ / gridSpacing) + northingBase;

                    // 4. è®¡ç®—åŒ—è¡Œæ ¼ç½‘å†…çš„å°è¡Œä½ç½®ï¼ˆç¬¬å…­ä½æ•°ï¼‰
                    let northingOffset = gridZ % gridSpacing;
                    let northingSubLine = Math.floor((northingOffset / gridSpacing) * 9) + 1;
                    if (northingSubLine > 9) northingSubLine = 9;

                    // 5. ç»„åˆå…­ä½æ•°åæ ‡
                    const eastingStr = String(eastingLineNumber).padStart(2, '0');
                    const eastingSubLineStr = String(eastingSubLine).padStart(1, '0');
                    const northingStr = String(northingLineNumber).padStart(2, '0');
                    const northingSubLineStr = String(northingSubLine).padStart(1, '0');

                    const gridCoordinate = `${eastingStr}${eastingSubLineStr}${northingStr}${northingSubLineStr}`;

                    // è®¡ç®—å¡åº¦ - åœ¨2Dåœ°å›¾ä¸­æˆ‘ä»¬éœ€è¦ä½¿ç”¨ç›¸é‚»ç‚¹æ¥è¿‘ä¼¼è®¡ç®—
                    let slope = 0;
                    try {
                        // è·å–å››ä¸ªç›¸é‚»ç‚¹çš„é«˜åº¦
                        const x1 = Math.floor(normalizedX);
                        const x2 = Math.min(x1 + 1, gridSegments);
                        const z1 = Math.floor(normalizedZ);
                        const z2 = Math.min(z1 + 1, gridSegments);

                        const h1 = positions[(z1 * (gridSegments + 1) + x1) * 3 + 2] * heightMultiplier;
                        const h2 = positions[(z1 * (gridSegments + 1) + x2) * 3 + 2] * heightMultiplier;
                        const h3 = positions[(z2 * (gridSegments + 1) + x1) * 3 + 2] * heightMultiplier;
                        const h4 = positions[(z2 * (gridSegments + 1) + x2) * 3 + 2] * heightMultiplier;

                        // è®¡ç®— X å’Œ Z æ–¹å‘çš„æ¢¯åº¦
                        const dx = (h2 - h1) / (terrainSizeMeters / gridSegments);
                        const dz = (h3 - h1) / (terrainSizeMeters / gridSegments);

                        // è®¡ç®—æ³•å‘é‡
                        const normal = new THREE.Vector3(-dx, 1, -dz).normalize();

                        // è®¡ç®—ä¸å‚ç›´æ–¹å‘çš„å¤¹è§’
                        slope = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0))) * (180 / Math.PI);
                    } catch (error) {
                        console.error("è®¡ç®—å¡åº¦é”™è¯¯:", error);
                        slope = 0;
                    }

                    // æ›´æ–°çŠ¶æ€æ 
                    const statusBar = document.querySelector('.status-bar');
                    statusBar.textContent = `åº§æ¨™: ${gridCoordinate}, é«˜åº¦: ${height.toFixed(1)}m | å¡åº¦: ${slope.toFixed(1)}Â°`;
                }
            } catch (error) {
                console.error("æ›´æ–°2Dåœ°å›¾çŠ¶æ€æ é”™è¯¯:", error);
            }
        }

        function initMapMode() {
            try {
                const mapModeBtn = document.getElementById('map-mode-btn');
                const return3dBtn = document.getElementById('return-3d-btn');
                const measurementToolbar = document.querySelector('.measurement-toolbar');
                const terrainToolbar = document.querySelector('.terrain-toolbar');
                const drawingToolbar = document.querySelector('.drawing-toolbar');
                const mapDrawingToolbar = document.querySelector('.map-drawing-toolbar');
                const mapContainer = document.getElementById('map-container');
                const mapCanvas = document.getElementById('map-canvas');
                const polylineToggleBtn = document.getElementById('polyline-toggle'); //å–å¾—é€£ç·šæŒ‰éˆ•
                const polylineClearBtn = document.getElementById('polyline-clear');  //å–å¾—æ¸…é™¤é€£ç·šæŒ‰éˆ•
                const profileToggleBtn = document.getElementById('profile-toggle'); // å–å¾—ç¸±å‰–é¢æŒ‰éˆ•

                // æ·»åŠ æ”¾å¤§ç¸®å°æŒ‰éˆ•çš„äº‹ä»¶ç›£è½
                const zoomInBtn = document.getElementById('zoom-in');
                const zoomOutBtn = document.getElementById('zoom-out');

                // æ”¹é€²æ”¾å¤§å’Œç¸®å°æŒ‰éˆ•åŠŸèƒ½
                if (zoomInBtn) {
                  zoomInBtn.addEventListener('click', () => {
                      // ä¿å­˜åŸå§‹ä½ç½®
                      const oldScale = currentScale;
                      // æ”¾å¤§ 20%
                      currentScale *= 1.2;
                      // èª¿æ•´åç§»é‡ï¼Œä¿æŒè¦–åœ–ä¸­å¿ƒ
                      mapOffset.x = mapOffset.x * (currentScale / oldScale);
                      mapOffset.y = mapOffset.y * (currentScale / oldScale);

                      // é‡æ–°ç”Ÿæˆåœ°å›¾ (å·²åŒ…å«çºµå‰–é¢çº¿ç»˜åˆ¶é€»è¾‘)
                      generate2DMap();
                  });
                }

                if (zoomOutBtn) {
                  zoomOutBtn.addEventListener('click', () => {
                      // ä¿å­˜åŸå§‹ä½ç½®
                      const oldScale = currentScale;
                      // ç¸®å° 20%
                      currentScale *= 0.8;
                      // èª¿æ•´åç§»é‡ï¼Œä¿æŒè¦–åœ–ä¸­å¿ƒ
                      mapOffset.x = mapOffset.x * (currentScale / oldScale);
                      mapOffset.y = mapOffset.y * (currentScale / oldScale);

                      // é‡æ–°ç”Ÿæˆåœ°å›¾ (å·²åŒ…å«çºµå‰–é¢çº¿ç»˜åˆ¶é€»è¾‘)
                      generate2DMap();
                  });


                    // ç¡®ä¿åœ°å›¾å®¹å™¨å¯è§ä¸”æ­£ç¡®è®¾ç½®
                    if (mapContainer) {
                        mapContainer.style.position = 'absolute';
                        mapContainer.style.top = '0';
                        mapContainer.style.left = '0';
                        mapContainer.style.width = '100%';
                        mapContainer.style.height = '100%';
                        mapContainer.style.zIndex = '2';
                    }

                    // ç¡®ä¿åœ°å›¾ç”»å¸ƒå¯æ‹–åŠ¨
                    if (mapCanvas) {
                        mapCanvas.style.position = 'absolute';
                        mapCanvas.style.top = '0';
                        mapCanvas.style.left = '0';
                        mapCanvas.style.cursor = 'grab';
                    }

                    // ç¡®ä¿ç»˜å›¾ç”»å¸ƒä¸ä¼šæ‹¦æˆªæ‹–åŠ¨äº‹ä»¶
                    const mapDrawingCanvas = document.getElementById('map-drawing-canvas');
                    if (mapDrawingCanvas) {
                        mapDrawingCanvas.style.position = 'absolute';
                        mapDrawingCanvas.style.top = '0';
                        mapDrawingCanvas.style.left = '0';
                        mapDrawingCanvas.style.zIndex = '2';
                        mapDrawingCanvas.style.pointerEvents = 'none'; // åˆå§‹æ—¶ç¦ç”¨é¼ æ ‡äº‹ä»¶
                    }

                }

                // æ»šè½®ç¼©æ”¾é€»è¾‘ä¿®æ”¹
                if (mapContainer) {
                  mapContainer.addEventListener('wheel', (e) => {
                      e.preventDefault();

                      // ä¿å­˜åŸå§‹ä½ç½®
                      const oldScale = currentScale;

                      // èª¿æ•´ç¸®æ”¾æ¯”ä¾‹
                      if (e.deltaY > 0) {
                          // å‘ä¸‹æ»¾å‹•ï¼Œç¸®å°
                          currentScale *= 0.9;
                      } else {
                          // å‘ä¸Šæ»¾å‹•ï¼Œæ”¾å¤§
                          currentScale *= 1.1;
                      }

                      // é™åˆ¶ç¸®æ”¾ç¯„åœ
                      currentScale = Math.max(0.5, Math.min(currentScale, 3));

                      // èª¿æ•´åç§»é‡ä»¥ä¿æŒè¦–åœ–ä¸­å¿ƒ
                      mapOffset.x = mapOffset.x * (currentScale / oldScale);
                      mapOffset.y = mapOffset.y * (currentScale / oldScale);

                      // é‡æ–°ç”Ÿæˆåœ°å›¾ (å·²åŒ…å«çºµå‰–é¢çº¿ç»˜åˆ¶é€»è¾‘)
                      generate2DMap();
                  });
                }

                if (!mapCanvas || !mapContainer) {
                    console.error('æ‰¾ä¸åˆ°åœ°åœ–å®¹å™¨æˆ–ç•«å¸ƒå…ƒç´ ');
                    return;
                }

                if (!return3dBtn) {
                    console.error('æ‰¾ä¸åˆ°è¿”å›æŒ‰éˆ•å…ƒç´ ');
                    return;
                }

                return3dBtn.addEventListener('click', () => {
                    console.log('é»æ“Šè¿”å›æŒ‰éˆ•');
                    isMapMode = false;
                    mapModeBtn.classList.remove('active');
                    renderer.domElement.style.display = 'block';
                    mapContainer.style.display = 'none';
                    measurementToolbar.style.display = 'none';
                    terrainToolbar.style.display = 'flex';
                    drawingToolbar.style.display = 'flex';
                    mapDrawingToolbar.style.display = 'none';
                    resetPolylineTool();
                    resetProfileTool();
                    resetMapDrawingTools();

                    // é‡ç½®çŠ¶æ€æ 
                    const statusBar = document.querySelector('.status-bar');
                    statusBar.textContent = 'åº§æ¨™: X: 0, Y: 0, Z: 0 | é«˜åº¦: 0m | å¡åº¦: 0Â°';
                });

                mapModeBtn.addEventListener('click', () => {
                    try {
                        isMapMode = !isMapMode;
                        mapModeBtn.classList.toggle('active');

                        if (isMapMode) {
                            console.log('åˆ‡æ›åˆ°åœ°åœ–æ¨¡å¼');
                            renderer.domElement.style.display = 'none';
                            mapContainer.style.display = 'block';
                            generate2DMap();
                            measurementToolbar.style.display = 'flex';
                            mapDrawingToolbar.style.display = 'flex';
                            terrainToolbar.style.display = 'none';
                            drawingToolbar.style.display = 'none';
                            resetTerrainTools();

                            // é‡è¨­é«˜äº®å±¤
                            if (highlightCanvas) {
                                highlightContext.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                                highlightCanvas.style.display = 'block';
                            }
                        } else {
                            console.log('è¿”å›3Dæ¨¡å¼');
                            renderer.domElement.style.display = 'block';
                            mapContainer.style.display = 'none';
                            measurementToolbar.style.display = 'none';
                            mapDrawingToolbar.style.display = 'none';
                            terrainToolbar.style.display = 'flex';
                            drawingToolbar.style.display = 'flex';
                            resetProfileTool();
                            resetMapDrawingTools();

                            // éš±è—é«˜äº®å±¤
                            if (highlightCanvas) {
                                highlightCanvas.style.display = 'none';
                            }
                        }
                    } catch (error) {
                        console.error('åˆ‡æ›åœ°åœ–æ¨¡å¼æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        alert('åˆ‡æ›åœ°åœ–æ¨¡å¼æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼');
                        isMapMode = false;
                        mapModeBtn.classList.remove('active');
                        renderer.domElement.style.display = 'block';
                        mapContainer.style.display = 'none';
                        measurementToolbar.style.display = 'none';
                        mapDrawingToolbar.style.display = 'none';
                        terrainToolbar.style.display = 'flex';
                        drawingToolbar.style.display = 'flex';
                    }
                }); // è¿™é‡Œæ·»åŠ æ­£ç¡®çš„é—­åˆæ‹¬å·


                // å¤šé»é€£ç·šæŒ‰éˆ•äº‹ä»¶
                if (polylineToggleBtn) {
                    polylineToggleBtn.addEventListener('click', () => {
                        isPolylineMode = !isPolylineMode;
                        resetTerrainTools(); // é‡è¨­å…¶ä»–å·¥å…·
                        resetMapDrawingTools(); // é‡è¨­åœ°åœ–ç¹ªåœ–å·¥å…·
                        resetProfileTool(); // é‡è¨­ç¸±å‰–é¢å·¥å…·
                        polylineToggleBtn.classList.toggle('active');
                        if(isPolylineMode) {
                            mapCanvas.style.cursor = 'crosshair'; //æ”¹è®Šæ»‘é¼ æ¨£å¼
                            hideProtractor();
                        } else {
                            mapCanvas.style.cursor = 'default';
                        }
                    });
                }

                // å‰µå»ºé«˜äº®é»è¦†è“‹å±¤ç•«å¸ƒ
                highlightCanvas = document.createElement('canvas');
                highlightCanvas.style.position = 'absolute';
                highlightCanvas.style.top = '0';
                highlightCanvas.style.left = '0';
                highlightCanvas.style.pointerEvents = 'none'; // ä¸æ””æˆªé¼ æ¨™äº‹ä»¶
                highlightCanvas.style.zIndex = '3'; // ç¢ºä¿åœ¨å…¶ä»–ç•«å¸ƒä¸Šæ–¹
                mapContainer.appendChild(highlightCanvas);
                highlightContext = highlightCanvas.getContext('2d');

                // æ¸…é™¤é€£ç·šæŒ‰éˆ•äº‹ä»¶
                if (polylineClearBtn) {
                    polylineClearBtn.addEventListener('click', () => {
                        resetPolylineTool();
                    });
                }

                // å‰µå»ºé«˜äº®é»è¦†è“‹å±¤ç•«å¸ƒ
                highlightCanvas = document.createElement('canvas');
                highlightCanvas.style.position = 'absolute';
                highlightCanvas.style.top = '0';
                highlightCanvas.style.left = '0';
                highlightCanvas.style.pointerEvents = 'none'; // ä¸æ””æˆªé¼ æ¨™äº‹ä»¶
                highlightCanvas.style.zIndex = '3'; // ç¢ºä¿åœ¨å…¶ä»–ç•«å¸ƒä¸Šæ–¹
                mapContainer.appendChild(highlightCanvas);
                highlightContext = highlightCanvas.getContext('2d');

                mapCanvas.addEventListener('click', handleMapClick);
                polylineLayer = document.createElement('canvas');
                polylineLayer.style.position = 'absolute';
                polylineLayer.style.top = '0';
                polylineLayer.style.left = '0';
                document.getElementById('map-container').appendChild(polylineLayer);
            } catch (error) {
                console.error("åˆå§‹åŒ–åœ°åœ–æ¨¡å¼éŒ¯èª¤:", error);
            }
        }

        function resetRulerTool() {
            // é€™æ˜¯è‡¨æ™‚çš„ç©ºå¯¦ç¾ï¼Œä»¥é˜²æ­¢å‡ºéŒ¯
            console.log("é‡ç½®å°ºè¦å·¥å…·");
        }

        function resetProtractorTool() {
            hideProtractor();
        }

        function resetPolylineTool() {
            polylinePoints = [];
            totalDistance = 0;
            isPolylineMode = false;
            const polylineToggleBtn = document.getElementById('polyline-toggle');
            if(polylineToggleBtn) polylineToggleBtn.classList.remove('active');

            const mapCanvas = document.getElementById('map-canvas');
            if (mapCanvas) mapCanvas.style.cursor = 'default';
            updateStatusBarWithDistance(0);  // é‡ç½®è·é›¢è³‡è¨Š
            generate2DMap(); // æ¸…é™¤åœ–å±¤å¾Œï¼Œé‡æ–°ç¹ªè£½åœ°åœ–
        }

        function handleMapClick(event) {
            // å¦‚æœåœ¨ç¸±å‰–é¢æ¨¡å¼ä¸­ï¼Œæ”¹ç”¨ç¸±å‰–é¢è™•ç†å‡½æ•¸
            if (isProfileMode) {
                try {
                    handleProfileClick(event);
                } catch (error) {
                    console.error("ç¸±å‰–é¢é»æ“Šè™•ç†éŒ¯èª¤:", error);
                }
                return;
            }

            // å¦‚æœåœ¨ç¹ªåœ–æ¨¡å¼ï¼Œè·³éé€£ç·šé»æ·»åŠ 
            if (isMapDrawing || document.querySelector('.map-color-btn.active') || isMapErasing) {
                return;
            }

            if (!isPolylineMode) return;
             const mapCanvas = document.getElementById('map-canvas');
             if (!mapCanvas) return;

             const rect = mapCanvas.getBoundingClientRect();
             // è·å–å±å¹•ç‚¹å‡»åæ ‡
             const screenX = event.clientX - rect.left;
             const screenY = event.clientY - rect.top;

             // åœ°å›¾ä¸­å¿ƒç‚¹
             const canvasCenterX = mapCanvas.width / 2;
             const canvasCenterY = mapCanvas.height / 2;

             // è®¡ç®—è½¬æ¢åçš„åæ ‡ï¼ˆè€ƒè™‘åœ°å›¾çš„åç§»å’Œç¼©æ”¾ï¼‰
             // 1. ç§»é™¤åç§»å½±å“
             const withoutOffsetX = screenX - mapOffset.x;
             const withoutOffsetY = screenY - mapOffset.y;

             // 2. è€ƒè™‘ç¼©æ”¾ï¼ˆç›¸å¯¹äºä¸­å¿ƒç‚¹ï¼‰
             const transformedX = canvasCenterX + (withoutOffsetX - canvasCenterX) / currentScale;
             const transformedY = canvasCenterY + (withoutOffsetY - canvasCenterY) / currentScale;

             // ä¿å­˜åŸå§‹åæ ‡å’Œå˜æ¢åçš„åæ ‡
             polylinePoints.push({
                 screenX: screenX,
                 screenY: screenY,
                 transformedX: transformedX,
                 transformedY: transformedY
             });

             // é‡æ–°ç¹ªè£½åœ°åœ–å’Œé€£ç·š
             generate2DMap();
             calculateDistance();
         }

        function displayDistance(context, offsetX, offsetY) {
            let accumulatedDistance = 0;
            for (let i = 0; i < polylinePoints.length - 1; i++) {
                const p1 = polylinePoints[i];
                const p2 = polylinePoints[i + 1];
                const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                // ä½¿ç”¨å…¨å±€çš„ pixelSize ä¸¦è€ƒæ…® currentScale
                const distance = dist / (pixelSize * currentScale);
                accumulatedDistance += distance;
            }

            if (polylinePoints.length < 2 || accumulatedDistance === 0) return; // ç¢ºä¿æœ‰å…©å€‹é»

            context.font = 'bold 16px Arial';
            context.fillStyle = 'black';
            context.textAlign = 'left';
            context.textBaseline = 'top';
            context.fillText(`${accumulatedDistance.toFixed(1)} m`, offsetX, offsetY + 10);
        }

        function calculateDistance() {
            totalDistance = 0;
            if (polylinePoints.length < 2) {
                updateStatusBarWithDistance(totalDistance); // ç¢ºä¿æ²’æœ‰é»æ™‚ä¹Ÿæ›´æ–°ç‹€æ…‹æ¬„
                return;
            }

            for (let i = 0; i < polylinePoints.length - 1; i++) {
                const p1 = polylinePoints[i];
                const p2 = polylinePoints[i + 1];

                // ä½¿ç”¨å˜æ¢åçš„åæ ‡è®¡ç®—è·ç¦»
                const dist = Math.hypot(
                    p2.transformedX - p1.transformedX,
                    p2.transformedY - p1.transformedY
                );

                // ä½¿ç”¨å…¨å±€çš„ pixelSize è¨ˆç®—å¯¦éš›è·é›¢
                const distance = dist / pixelSize;
                totalDistance += distance;
            }
            updateStatusBarWithDistance(totalDistance); // æ›´æ–°çŠ¶æ€æ 
        }

        function updateStatusBarWithDistance(distance) {
            const statusBar = document.querySelector('.status-bar');
            const originalText = statusBar.textContent.split('|')[0]; // ä¿ç•™åŸæœ¬çš„ç‹€æ…‹è³‡è¨Š
            const distanceText = ` | é€£ç·šè·é›¢: ${distance.toFixed(1)}m`;

            statusBar.textContent = originalText + distanceText;
        }

        function drawPolyline(context, offsetX, offsetY) {
            if (polylinePoints.length < 2) return;

            // ä¿å­˜ä¸Šä¸‹æ–‡çŠ¶æ€
            context.save();

            context.strokeStyle = 'red';
            context.lineWidth = 2;

            context.beginPath();
            // ä½¿ç”¨å˜æ¢åçš„åæ ‡ç»˜åˆ¶çº¿æ¡
            context.moveTo(polylinePoints[0].transformedX, polylinePoints[0].transformedY);
            for (let i = 1; i < polylinePoints.length; i++) {
                context.lineTo(polylinePoints[i].transformedX, polylinePoints[i].transformedY);
            }
            context.stroke();

            // ç¹ªè£½æ¯å€‹é»ï¼Œè®“ä½¿ç”¨è€…çŸ¥é“ä»–å€‘é»æ“Šçš„ä½ç½®
            context.fillStyle = 'black';
            for (let i = 0; i < polylinePoints.length; i++) {
                context.beginPath();
                context.arc(
                    polylinePoints[i].transformedX,
                    polylinePoints[i].transformedY,
                    4 / currentScale, // æ ¹æ®ç¼©æ”¾è°ƒæ•´ç‚¹çš„å¤§å°
                    0,
                    2 * Math.PI
                );
                context.fill();
            }

            // æ¢å¤ä¸Šä¸‹æ–‡çŠ¶æ€
            context.restore();
        }

        function getHeightColor(height, minHeight, maxHeight) {
            // è¨ˆç®—æ¨™æº–åŒ–é«˜åº¦ (0-1ç¯„åœ)
            const normalizedHeight = (height - minHeight) / (maxHeight - minHeight);

            // å®šç¾©é¡è‰²å€é–“
            const colors = [
                { height: 0, color: { r: 0, g: 70, b: 255 } },     // æ·±è—ï¼ˆæ°´ï¼‰
                { height: 0.2, color: { r: 0, g: 159, b: 0 } },    // æ·±ç¶ ï¼ˆä½åœ°ï¼‰
                { height: 0.4, color: { r: 85, g: 255, b: 0 } },   // æ·ºç¶ ï¼ˆå¹³åŸï¼‰
                { height: 0.6, color: { r: 255, g: 255, b: 0 } },  // é»ƒè‰²ï¼ˆä¸˜é™µï¼‰
                { height: 0.8, color: { r: 160, g: 82, b: 45 } },  // æ£•è‰²ï¼ˆå±±åœ°ï¼‰
                { height: 1, color: { r: 255, g: 250, b: 250 } }   // ç™½è‰²ï¼ˆå±±é ‚ï¼‰
            ];

            // æ‰¾å‡ºç•¶å‰é«˜åº¦æ‰€åœ¨çš„å€é–“
            let i = 0;
            while (i < colors.length - 1 && normalizedHeight > colors[i + 1].height) {
                i++;
            }

            // åœ¨å…©å€‹é¡è‰²ä¹‹é–“é€²è¡Œæ’å€¼
            const lowerColor = colors[i].color;
            const upperColor = colors[i + 1].color;
            const rangePct = (normalizedHeight - colors[i].height) /
                            (colors[i + 1].height - colors[i].height);

            // è¨ˆç®—æ’å€¼å¾Œçš„é¡è‰²
            return {
                r: Math.floor(lowerColor.r + (upperColor.r - lowerColor.r) * rangePct),
                g: Math.floor(lowerColor.g + (upperColor.g - lowerColor.g) * rangePct),
                b: Math.floor(lowerColor.b + (upperColor.b - lowerColor.b) * rangePct)
            };
        }

        function generate2DMap() {
            try {
                console.time('generate2DMap');

                // ç²å–ç•«å¸ƒå’Œä¸Šä¸‹æ–‡
                const mapCanvas = document.getElementById('map-canvas');
                const mapContext = mapCanvas.getContext('2d');
                const mapContainer = document.getElementById('map-container');

                // ç²å–èª¿è©¦æ¨™èªŒ
                const debugMode = document.getElementById('debug-water-boundary').checked;

                // è¨­ç½®ç•«å¸ƒå°ºå¯¸
                mapCanvas.width = mapContainer.offsetWidth;
                mapCanvas.height = mapContainer.offsetHeight;

                // åŒæ­¥æ›´æ–°å…¶ä»–ç•«å¸ƒå°ºå¯¸
                if (mapDrawingCanvas) {
                    mapDrawingCanvas.width = mapCanvas.width;
                    mapDrawingCanvas.height = mapCanvas.height;

                    if (mapHistoryIndex >= 0 && mapDrawingHistory[mapHistoryIndex]) {
                        const mapDrawingContext = mapDrawingCanvas.getContext('2d');
                        mapDrawingContext.drawImage(mapDrawingHistory[mapHistoryIndex], 0, 0);
                    }
                }

                if (highlightCanvas) {
                    highlightCanvas.width = mapCanvas.width;
                    highlightCanvas.height = mapCanvas.height;
                    highlightCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
                }

                // æ¸…é™¤æ•´å€‹ç•«å¸ƒä¸¦è¨­ç½®ç‚ºç´”ç™½è‰²
                mapContext.fillStyle = '#ffffff';
                mapContext.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

                // ä¿å­˜ç•«å¸ƒç‹€æ…‹ä¸¦æ‡‰ç”¨è®Šæ›
                mapContext.save();
                mapContext.translate(mapOffset.x, mapOffset.y);
                mapContext.translate(mapCanvas.width / 2, mapCanvas.height / 2);
                mapContext.scale(currentScale, currentScale);
                mapContext.translate(-mapCanvas.width / 2, -mapCanvas.height / 2);

                // è¨ˆç®—åœ°åœ–ç¹ªè£½åƒæ•¸
                const positions = terrain.geometry.attributes.position.array;
                const gridSegments = 100;
                const gridSize = gridSegments + 1;

                // è¨ˆç®—ç•«å¸ƒä¸Šçš„ç¹ªè£½å°ºå¯¸
                const maxSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                pixelSize = maxSize / gridSegments;
                const offsetX = (mapCanvas.width - gridSegments * pixelSize) / 2;
                const offsetY = (mapCanvas.height - gridSegments * pixelSize) / 2;

                // å‰µå»ºçµ±ä¸€çš„é«˜åº¦æ•¸æ“šç¶²æ ¼
                const heightData = createUnifiedHeightGrid(positions, gridSize);

                // å…ˆç¹ªè£½ä¸€å€‹å®Œå…¨ç´”ç™½çš„èƒŒæ™¯çŸ©å½¢ (è¦†è“‹æ•´å€‹åœ°åœ–å€åŸŸ)
                mapContext.fillStyle = '#ffffff';
                mapContext.fillRect(offsetX, offsetY, gridSegments * pixelSize, gridSegments * pixelSize);

                // å¦‚æœæœªå•Ÿç”¨èª¿è©¦æ¨¡å¼ï¼Œåªç¹ªè£½ç­‰é«˜ç·šï¼›å¦å‰‡ç¹ªè£½åœ°å½¢é¡è‰²
                if (!debugMode) {
                    // åªç¹ªè£½ç­‰é«˜ç·šï¼Œä¸æ¸²æŸ“åœ°å½¢é¡è‰²
                    drawOnlyContours(mapContext, heightData, offsetX, offsetY, pixelSize);
                } else {
                    // èª¿è©¦æ¨¡å¼ï¼šå®Œæ•´æ¸²æŸ“åœ°å½¢é¡è‰²å’Œç­‰é«˜ç·š
                    if (typeof drawExactContours === 'function') {
                        drawExactContours(mapContext, heightData, offsetX, offsetY, pixelSize);
                    } else {
                        console.warn('drawExactContours å‡½æ•¸ä¸å­˜åœ¨ï¼Œä½¿ç”¨æ›¿ä»£æ–¹æ³•');
                        drawSmoothContours(mapContext, positions, gridSize, heightData.minHeight, heightData.maxHeight, offsetX, offsetY, pixelSize);
                    }
                }

                // ç¹ªè£½ç¶²æ ¼å’Œå…¶ä»–å…ƒç´ 
                drawGrid(mapContext, gridSegments, offsetX, offsetY, pixelSize, 25);
                drawScaleBar(mapContext, offsetX, offsetY + gridSegments * pixelSize + 30, gridSegments, pixelSize);

                // ç¹ªè£½æ¨™è¨˜
                drawMarkersOnMap(mapContext, offsetX, offsetY, pixelSize);

                // ç¹ªè£½é€£ç·šå’Œå‰–é¢é»
                if (isPolylineMode) {
                    drawPolyline(mapContext, offsetX, offsetY);
                }

                if (isProfileMode && profilePoints.length > 0) {
                    if (profilePoints.length === 2) {
                        // åªè°ƒç”¨drawProfileLineï¼Œå› ä¸ºå®ƒå·²ç»åŒ…å«äº†ç»˜åˆ¶ç‚¹çš„é€»è¾‘
                        drawProfileLine();
                    } else if (profilePoints.length === 1) {
                        // åªç»˜åˆ¶ç¬¬ä¸€ä¸ªç‚¹
                        drawProfilePoints(mapContext);
                    }
                }

                // æ¢å¾©ç•«å¸ƒç‹€æ…‹
                mapContext.restore();

                // æ›´æ–°ç¹ªåœ–ç•«å¸ƒä½ç½®
                if (mapDrawingCanvas) {
                    mapDrawingCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
                }

                console.timeEnd('generate2DMap');
            } catch (error) {
                console.error('ç”Ÿæˆåœ°åœ–æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            }
        }

        // æ–°å¢å°ˆé–€åªç¹ªè£½ç­‰é«˜ç·šçš„å‡½æ•¸ï¼Œä¸æ¸²æŸ“ä»»ä½•åœ°å½¢é¡è‰²
        function drawOnlyContours(context, heightData, offsetX, offsetY, pixelSize) {
            try {
                // ç­‰é«˜ç·šç¹ªè£½è¨­ç½®
                const contourInterval = 20; // 20ç±³ç­‰é«˜ç·šé–“éš”
                const zeroLineWidth = 1.5;  // 0ç±³ç­‰é«˜ç·šå¯¬åº¦
                const majorLineWidth = 1.5; // ä¸»ç­‰é«˜ç·šå¯¬åº¦
                const minorLineWidth = 0.8; // æ¬¡ç­‰é«˜ç·šå¯¬åº¦

                // è¨­ç½®ç·šæ¢æ¨£å¼
                context.lineCap = 'round';
                context.lineJoin = 'round';

                // å„²å­˜ç­‰é«˜ç·šé»
                const contourPoints = new Map();
                const gridSize = heightData.grid.length;

                // æƒææ‰€æœ‰ç¶²æ ¼å–®å…ƒå°‹æ‰¾ç­‰é«˜ç·šäº¤é»
                for (let y = 0; y < gridSize - 1; y++) {
                    for (let x = 0; x < gridSize - 1; x++) {
                        // ç²å–å–®å…ƒæ ¼å››å€‹è§’çš„é«˜åº¦
                        const z1 = heightData.grid[y][x];
                        const z2 = heightData.grid[y][x+1];
                        const z3 = heightData.grid[y+1][x];
                        const z4 = heightData.grid[y+1][x+1];

                        // æ‰¾å‡ºå–®å…ƒæ ¼å…§çš„æœ€ä½å’Œæœ€é«˜é«˜åº¦
                        const minZ = Math.min(z1, z2, z3, z4);
                        const maxZ = Math.max(z1, z2, z3, z4);

                        // è¨ˆç®—å–®å…ƒæ ¼å…§ç¶“éçš„æ‰€æœ‰ç­‰é«˜ç·šé«˜åº¦
                        const startHeight = Math.floor(minZ / contourInterval) * contourInterval;
                        const endHeight = Math.ceil(maxZ / contourInterval) * contourInterval;

                        // è™•ç†æ¯ä¸€æ¢å¯èƒ½çš„ç­‰é«˜ç·š
                        for (let h = startHeight; h <= endHeight; h += contourInterval) {
                            // åˆå§‹åŒ–é«˜åº¦å°æ‡‰çš„é»é›†åˆ
                            if (!contourPoints.has(h)) {
                                contourPoints.set(h, []);
                            }

                            // æª¢æŸ¥å››æ¢é‚Šæ˜¯å¦èˆ‡è©²ç­‰é«˜ç·šç›¸äº¤
                            let points = [];

                            // å·¦é‚Š
                            if ((z1 <= h && h <= z3) || (z3 <= h && h <= z1)) {
                                const t = Math.abs(z3 - z1) < 0.0001 ? 0.5 : (h - z1) / (z3 - z1);
                                points.push({
                                    x: offsetX + x * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }

                            // å³é‚Š
                            if ((z2 <= h && h <= z4) || (z4 <= h && h <= z2)) {
                                const t = Math.abs(z4 - z2) < 0.0001 ? 0.5 : (h - z2) / (z4 - z2);
                                points.push({
                                    x: offsetX + (x + 1) * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }

                            // ä¸Šé‚Š
                            if ((z1 <= h && h <= z2) || (z2 <= h && h <= z1)) {
                                const t = Math.abs(z2 - z1) < 0.0001 ? 0.5 : (h - z1) / (z2 - z1);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + y * pixelSize
                                });
                            }

                            // ä¸‹é‚Š
                            if ((z3 <= h && h <= z4) || (z4 <= h && h <= z3)) {
                                const t = Math.abs(z4 - z3) < 0.0001 ? 0.5 : (h - z3) / (z4 - z3);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + (y + 1) * pixelSize
                                });
                            }

                            // åªæ·»åŠ æœ‰2å€‹äº¤é»çš„ç·šæ®µ
                            if (points.length === 2) {
                                contourPoints.get(h).push(points);
                            }
                        }
                    }
                }

                // ç¹ªè£½æ‰€æœ‰ç­‰é«˜ç·š
                contourPoints.forEach((pointSets, height) => {
                    // åˆ¤æ–·ç­‰é«˜ç·šé¡å‹
                    const isMajorContour = Math.abs(height) % 100 === 0;
                    const isZeroContour = Math.abs(height) < contourInterval / 2;
                    const isDepthContour = height < 0 && !isZeroContour; // æ°´ä¸‹ç­‰æ·±ç·š

                    // è¨­ç½®ç·šæ¢æ¨£å¼
                    context.beginPath();
                    // æ ¹æ“šé«˜åº¦è¨­ç½®ä¸åŒé¡è‰²
                    if (isZeroContour) {
                        context.strokeStyle = '#000000'; // 0ç±³ç­‰é«˜ç·šä¿æŒé»‘è‰²
                    } else if (isDepthContour) {
                        context.strokeStyle = '#87CEEB'; // ç­‰æ·±ç·šè¨­ç‚ºæ·ºè—è‰²
                    } else {
                        context.strokeStyle = '#8b4513'; // ç­‰é«˜ç·šä¿æŒéè¤è‰²
                    }
                    context.lineWidth = isZeroContour ? zeroLineWidth : (isMajorContour ? majorLineWidth : minorLineWidth);

          // ç¹ªè£½è©²é«˜åº¦çš„æ‰€æœ‰ç·šæ®µ
          pointSets.forEach(points => {
              context.moveTo(points[0].x, points[0].y);
              context.lineTo(points[1].x, points[1].y);
          });

          context.stroke();

          // ç‚ºä¸»è¦ç­‰é«˜ç·š/ç­‰æ·±ç·šæ·»åŠ æ¨™ç±¤
          if ((isMajorContour || isZeroContour) && pointSets.length > 0) {

                        // é¸æ“‡æœ€é•·ç·šæ®µä½œç‚ºæ¨™ç±¤ä½ç½®
                        let longestSegment = pointSets[0];
                        let maxLength = 0;

                        pointSets.forEach(points => {
                            const length = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
                            if (length > maxLength) {
                                maxLength = length;
                                longestSegment = points;
                            }
                        });

                        // è¨ˆç®—æ¨™ç±¤ä½ç½®å’Œè§’åº¦
                        const midX = (longestSegment[0].x + longestSegment[1].x) / 2;
                        const midY = (longestSegment[0].y + longestSegment[1].y) / 2;
                        const angle = Math.atan2(
                            longestSegment[1].y - longestSegment[0].y,
                            longestSegment[1].x - longestSegment[0].x
                        );

                        // ç¹ªè£½æ¨™ç±¤
                        context.save();
                        context.translate(midX, midY);

                        // èª¿æ•´æ–‡å­—æ–¹å‘
                        if (angle > Math.PI/2 || angle < -Math.PI/2) {
                            context.rotate(angle + Math.PI);
                        } else {
                            context.rotate(angle);
                        }

                        // æº–å‚™æ–‡å­—
                        let text;
                        if (height < 0) {
                            text = `${Math.abs(height)}m`;  // ç­‰æ·±ç·šé¡¯ç¤ºç‚ºæ­£æ•¸
                        } else {
                            text = `${height}m`;
                        }
                        const metrics = context.measureText(text);

                        // ç¹ªè£½èƒŒæ™¯
                        context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        context.fillRect(
                            -metrics.width/2 - 3,
                            -10,
                            metrics.width + 6,
                            18
                        );

                        // ç¹ªè£½æ–‡å­—
                        if (isZeroContour) {
                            context.fillStyle = '#000000'; // 0ç±³æ¨™ç±¤ç‚ºé»‘è‰²
                        } else if (isDepthContour) {
                            context.fillStyle = '#87CEEB'; // ç­‰æ·±ç·šæ¨™ç±¤ç‚ºæ·ºè—è‰²
                        } else {
                            context.fillStyle = '#8b4513'; // ç­‰é«˜ç·šæ¨™ç±¤ç‚ºéè¤è‰²
                        }
                        context.font = 'bold 12px Arial';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(text, 0, 0);

                        context.restore();
                    }
                });
            } catch (error) {
                console.error('ç¹ªè£½ç­‰é«˜ç·šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            }
        }

        function renderTerrainWithExactCoordinates(context, heightData, offsetX, offsetY, pixelSize, gridSegments) {
            // åœ°å½¢é¡è‰²æ¸²æŸ“å’Œç­‰é«˜ç·šç¹ªè£½ä½¿ç”¨å®Œå…¨ç›¸åŒçš„åº§æ¨™ç³»çµ±

            // 1. å…ˆåœ¨é›¢å±ç•«å¸ƒä¸Šæ¸²æŸ“åœ°å½¢é¡è‰²
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = gridSegments * pixelSize;
            offscreenCanvas.height = gridSegments * pixelSize;
            const offscreenContext = offscreenCanvas.getContext('2d');

            // ä½¿ç”¨ç²¾ç¢ºçš„åƒç´ æ˜ å°„
            for (let y = 0; y < gridSegments; y++) {
                for (let x = 0; x < gridSegments; x++) {
                    // ç¢ºä¿æ¯å€‹ç¶²æ ¼å–®å…ƒä½¿ç”¨çµ±ä¸€çš„åº§æ¨™è¨ˆç®—
                    const subSize = pixelSize + 0.5; // é˜²æ­¢åƒç´ é–“éš™

                    // ä½¿ç”¨ç¶²æ ¼ä¸­å¿ƒé»çš„é«˜åº¦å€¼ç¢ºå®šé¡è‰²
                    const height = exactInterpolate(heightData.grid, x + 0.5, y + 0.5);
                    const color = getExactColor(height, heightData.minHeight, heightData.maxHeight);

                    // å¡«å……ç¶²æ ¼å–®å…ƒ
                    offscreenContext.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    offscreenContext.fillRect(x * pixelSize, y * pixelSize, subSize, subSize);
                }
            }

            // å°‡é¡è‰²å±¤è¤‡è£½åˆ°ä¸»ç•«å¸ƒ
            context.drawImage(offscreenCanvas, offsetX, offsetY);

            // 2. ä½¿ç”¨ç›¸åŒçš„é«˜åº¦è³‡æ–™ç¹ªè£½ç­‰é«˜ç·š
            drawContours(context, heightData, offsetX, offsetY, pixelSize);
        }

        // æ–°çš„çµ±ä¸€é«˜åº¦æ•¸æ“šå‰µå»ºå‡½æ•¸
        function createUnifiedHeightGrid(positions, gridSize) {
            const grid = new Array(gridSize);
            let minHeight = Infinity;
            let maxHeight = -Infinity;
            const heightOffset = 0.01; // æ·»åŠ 0.01ç±³çš„åç§»é‡

            // å¡«å……ç¶²æ ¼ä¸¦è¨ˆç®—é«˜åº¦ç¯„åœ
            for (let y = 0; y < gridSize; y++) {
                grid[y] = new Array(gridSize);
                for (let x = 0; x < gridSize; x++) {
                    // å¾3Dæ¨¡å‹ä¸­ç²å–ç¢ºåˆ‡çš„é«˜åº¦å€¼ï¼Œç¢ºä¿ç´¢å¼•è¨ˆç®—ä¸€è‡´
                    const idx = (y * gridSize + x) * 3 + 2;
                    const originalHeight = positions[idx] * heightMultiplier;

                    // å°é™¸åœ°éƒ¨åˆ†æ·»åŠ åç§»ï¼ˆåªå°å¤§æ–¼ç­‰æ–¼0çš„é«˜åº¦å€¼æ·»åŠ åç§»ï¼‰
                    const adjustedHeight = originalHeight >= 0 ? originalHeight + heightOffset : originalHeight;

                    grid[y][x] = adjustedHeight;
                    minHeight = Math.min(minHeight, adjustedHeight);
                    maxHeight = Math.max(maxHeight, adjustedHeight);
                }
            }

            return { grid, minHeight, maxHeight };
        }

        function bilinearInterpolate(positions, gridSize, x, y) {
            // ç¡®ä¿åæ ‡åœ¨ç½‘æ ¼èŒƒå›´å†…
            const clampedX = Math.max(0, Math.min(x, gridSize - 1.001));
            const clampedY = Math.max(0, Math.min(y, gridSize - 1.001));

            // è·å–æ’å€¼ç‚¹å‘¨å›´çš„å››ä¸ªç½‘æ ¼ç‚¹åæ ‡
            const x0 = Math.floor(clampedX);
            const y0 = Math.floor(clampedY);
            const x1 = Math.min(x0 + 1, gridSize - 1);
            const y1 = Math.min(y0 + 1, gridSize - 1);

            // è®¡ç®—æ’å€¼æƒé‡
            const wx = clampedX - x0;
            const wy = clampedY - y0;

            // è·å–å››ä¸ªè§’çš„é«˜åº¦å€¼
            const h00 = positions[(y0 * gridSize + x0) * 3 + 2];
            const h10 = positions[(y0 * gridSize + x1) * 3 + 2];
            const h01 = positions[(y1 * gridSize + x0) * 3 + 2];
            const h11 = positions[(y1 * gridSize + x1) * 3 + 2];

            // åŒçº¿æ€§æ’å€¼è®¡ç®—
            const h0 = h00 * (1 - wx) + h10 * wx;
            const h1 = h01 * (1 - wx) + h11 * wx;

            return h0 * (1 - wy) + h1 * wy;
        }

        function drawMarkersOnMap(context, offsetX, offsetY, pixelSize) {
            markers.forEach(marker => {
                const mapCanvas = document.getElementById('map-canvas');
                const centerX = mapCanvas.width / 2;
                const centerY = mapCanvas.height / 2;
                const terrainSizeMeters = 100;  // åœ°å½¢å°ºå¯¸ï¼ˆå…¬å°ºï¼‰
                const gridSegments = 100; //ç¶²æ ¼æ•¸
                const mapSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                pixelSize = mapSize / gridSegments; // ä½¿ç”¨ gridSegments
                // å–å¾—åœ°å½¢çš„ä¸–ç•Œä¸­å¿ƒé»
                const terrainCenter = new THREE.Vector3(0, 0, 0);
                terrain.localToWorld(terrainCenter);

                // å°‡æ¨™è¨»çš„ä¸–ç•Œåæ¨™è½‰æ›ç‚ºä»¥ä¸­å¿ƒç‚ºåŸºæº–çš„åº§æ¨™
                const relativePosition = marker.position.clone().sub(terrainCenter);


                // å°‡3Dä¸–ç•Œåº§æ¨™è½‰æ›ç‚º2Dåœ°åœ–åº§æ¨™ (æ—‹è½‰90åº¦)
                const mapX = (relativePosition.x  / terrainSizeMeters * gridSegments * pixelSize) + offsetX + (gridSegments * pixelSize) /2 ;
                const mapY = (relativePosition.z / terrainSizeMeters * gridSegments * pixelSize) + offsetY + (gridSegments * pixelSize) /2 ;



                // ç¹ªè£½æ¨™è¨»é»ï¼ˆå¯æ ¹æ“šéœ€è¦ä¿®æ”¹æ¨£å¼ï¼‰
                context.fillStyle = 'red';
                context.beginPath();
                context.arc(mapX, mapY, 4 * currentScale, 0, 2 * Math.PI);
                context.fill();

                // ç¹ªè£½æ¨™ç±¤
                context.font = `${10 * currentScale}px Arial`; // èª¿æ•´å­—é«”å¤§å°
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.textBaseline = 'bottom';
                const text = marker.label;
                context.fillText(text, mapX, mapY - 8 * currentScale); //  è®“æ¨™ç±¤åœ¨é»çš„ä¸Šæ–¹
            });
        }

        function drawSmoothContours(context, positions, gridSize, minHeight, maxHeight, offsetX, offsetY, pixelSize) {
            try {
                // è¨­ç½®å›ºå®šçš„ç­‰é«˜ç·šé–“è·ç‚º20ç±³
                const contourInterval = 20;  // ç›´æ¥è¨­ç‚º20ç±³

                // è¨­ç½®ç­‰é«˜ç·šæ¨£å¼
                context.lineCap = 'round';
                context.lineJoin = 'round';

                // å‰µå»ºä¸€å€‹ç”¨æ–¼å­˜å„²ç­‰é«˜ç·šé»çš„æ•¸çµ„
                let contourPoints = new Map();

                // éæ­·æ¯å€‹ç¶²æ ¼å–®å…ƒ
                for (let y = 0; y < gridSize - 1; y++) {
                    for (let x = 0; x < gridSize - 1; x++) {
                        // åœ¨drawSmoothContourså‡½æ•°ä¸­
                        // è·å–ç½‘æ ¼å››ä¸ªè§’çš„é«˜åº¦å¹¶ä¹˜ä»¥å€æ•°å› å­
                        const z1 = positions[(y * gridSize + x) * 3 + 2] * heightMultiplier;
                        const z2 = positions[(y * gridSize + x + 1) * 3 + 2] * heightMultiplier;
                        const z3 = positions[((y + 1) * gridSize + x) * 3 + 2] * heightMultiplier;
                        const z4 = positions[((y + 1) * gridSize + x + 1) * 3 + 2] * heightMultiplier;

                        // è¨ˆç®—é€™å€‹ç¶²æ ¼ä¸­æ‡‰è©²ç¶“éçš„ç­‰é«˜ç·š
                        const minZ = Math.min(z1, z2, z3, z4);
                        const maxZ = Math.max(z1, z2, z3, z4);

                        // å°æ–¼æ¯å€‹å¯èƒ½çš„ç­‰é«˜ç·šé«˜åº¦
                        for (let h = Math.floor(minZ / contourInterval) * contourInterval;
                             h <= maxZ;
                             h += contourInterval) {

                            if (!contourPoints.has(h)) {
                                contourPoints.set(h, []);
                            }

                            // åœ¨ç¶²æ ¼é‚Šç·£å°‹æ‰¾ç­‰é«˜ç·šäº¤é»
                            let points = [];

                            // æª¢æŸ¥å››å€‹é‚Š
                            // å·¦é‚Š
                            if ((z1 <= h && h <= z3) || (z3 <= h && h <= z1)) {
                                const t = (h - z1) / (z3 - z1);
                                points.push({
                                    x: offsetX + x * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }
                            // å³é‚Š
                            if ((z2 <= h && h <= z4) || (z4 <= h && h <= z2)) {
                                const t = (h - z2) / (z4 - z2);
                                points.push({
                                    x: offsetX + (x + 1) * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }
                            // ä¸Šé‚Š
                            if ((z1 <= h && h <= z2) || (z2 <= h && h <= z1)) {
                                const t = (h - z1) / (z2 - z1);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + y * pixelSize
                                });
                            }
                            // ä¸‹é‚Š
                            if ((z3 <= h && h <= z4) || (z4 <= h && h <= z3)) {
                                const t = (h - z3) / (z4 - z3);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + (y + 1) * pixelSize
                                });
                            }

                            if (points.length === 2) {
                                contourPoints.get(h).push(points);
                            }
                        }
                    }
                }

                // ç¹ªè£½æ‰€æœ‰ç­‰é«˜ç·š
                contourPoints.forEach((pointSets, height) => {
                    // æ¯100ç±³ï¼ˆ5å€‹é–“éš”ï¼‰ä½œç‚ºä¸»ç­‰é«˜ç·š
                    const isMajorContour = Math.round(height / 100) * 100 === height;

                    context.beginPath();
                    context.strokeStyle = 'black'; // è¨­å®šç‚ºé»‘è‰²
                    context.lineWidth = isMajorContour ? 2 : 1; // ä¸»ç­‰é«˜ç·š 2px, æ¬¡ç­‰é«˜ç·š 1px

                    pointSets.forEach(points => {
                        context.moveTo(points[0].x, points[0].y);
                        context.lineTo(points[1].x, points[1].y);
                    });

                    context.stroke();

                    // ç‚ºä¸»ç­‰é«˜ç·šæ·»åŠ é«˜åº¦æ¨™ç±¤ï¼ˆæ¯æ¢ç­‰é«˜ç·šåªé¡¯ç¤ºä¸€æ¬¡ï¼‰
                    if (isMajorContour && pointSets.length > 0) {
                        // é¸æ“‡æœ€é•·çš„ç·šæ®µä¾†æ”¾ç½®æ¨™ç±¤
                        let longestSegment = pointSets[0];
                        let maxLength = 0;

                        pointSets.forEach(points => {
                            const length = Math.hypot(
                                points[1].x - points[0].x,
                                points[1].y - points[0].y
                            );
                            if (length > maxLength) {
                                maxLength = length;
                                longestSegment = points;
                            }
                        });

                        // åœ¨æœ€é•·ç·šæ®µçš„ä¸­é»æ”¾ç½®æ¨™ç±¤
                        const midX = (longestSegment[0].x + longestSegment[1].x) / 2;
                        const midY = (longestSegment[0].y + longestSegment[1].y) / 2;

                        // è¨ˆç®—ç·šæ®µçš„è§’åº¦
                        const angle = Math.atan2(
                            longestSegment[1].y - longestSegment[0].y,
                            longestSegment[1].x - longestSegment[0].x
                        );

                        // ä¿å­˜ç•¶å‰ä¸Šä¸‹æ–‡ç‹€æ…‹
                        context.save();

                        // ç§»å‹•åˆ°æ¨™ç±¤ä½ç½®ä¸¦æ—‹è½‰
                        context.translate(midX, midY);
                        if (angle > Math.PI/2 || angle < -Math.PI/2) {
                            context.rotate(angle + Math.PI);
                        } else {
                            context.rotate(angle);
                        }

                        // è¨­ç½®æ¨™ç±¤æ¨£å¼
                        context.font = 'bold 10px Arial';
                        context.fillStyle = 'rgba(101, 67, 33, 0.9)';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';

                        // ç¹ªè£½ç™½è‰²èƒŒæ™¯
                        const text = Math.round(height) + 'm';
                        const metrics = context.measureText(text);
                        context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        context.fillRect(
                            -metrics.width/2 - 2,
                            -6,
                            metrics.width + 4,
                            12
                        );

                        // ç¹ªè£½æ–‡å­—
                        context.fillStyle = 'rgba(101, 67, 33, 0.9)';
                        context.fillText(text, 0, 0);

                        // æ¢å¾©ä¸Šä¸‹æ–‡ç‹€æ…‹
                        context.restore();
                    }
                });

            } catch (error) {
                console.error('ç¹ªè£½ç­‰é«˜ç·šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            }
        }

        // é›™ç·šæ€§æ’å€¼å‡½æ•¸
        // æ”¹é€²é›™ç·šæ€§æ’å€¼å‡½æ•¸ï¼ˆå¢åŠ å¿«å–ï¼‰
        const interpolationCache = new Map(); // å…¨å±€å¿«å–

        // æ–°çš„çµ±ä¸€æ’å€¼å‡½æ•¸
        function unifiedInterpolate(grid, x, y) {
            const gridSize = grid.length;

            // ç¢ºä¿åº§æ¨™åœ¨æœ‰æ•ˆç¯„åœå…§
            const safeX = Math.max(0, Math.min(x, gridSize - 1.001));
            const safeY = Math.max(0, Math.min(y, gridSize - 1.001));

            // å–å¾—å››å€‹æœ€è¿‘çš„ç¶²æ ¼é»
            const x1 = Math.floor(safeX);
            const x2 = Math.min(x1 + 1, gridSize - 1);
            const y1 = Math.floor(safeY);
            const y2 = Math.min(y1 + 1, gridSize - 1);

            // è¨ˆç®—æ’å€¼æ¬Šé‡
            const wx = safeX - x1;
            const wy = safeY - y1;

            // é›™ç·šæ€§æ’å€¼è¨ˆç®—
            const h11 = grid[y1][x1];
            const h21 = grid[y1][x2];
            const h12 = grid[y2][x1];
            const h22 = grid[y2][x2];

            return h11 * (1-wx) * (1-wy) + h21 * wx * (1-wy) + h12 * (1-wx) * wy + h22 * wx * wy;
        }

        function renderTerrainColors(context, heightData, offsetX, offsetY, pixelSize, gridSegments) {
            // ä½¿ç”¨ç¦»å±ç”»å¸ƒæé«˜æ€§èƒ½
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = gridSegments * pixelSize;
            offscreenCanvas.height = gridSegments * pixelSize;
            const offscreenContext = offscreenCanvas.getContext('2d');

            const resolution = 2; // é™ä½åˆ†è¾¨ç‡ä»¥æé«˜æ€§èƒ½
            const subPixelSize = pixelSize / resolution;

            // é€åƒç´ æ¸²æŸ“åœ°å½¢é¢œè‰²
            for (let y = 0; y < gridSegments; y++) {
                for (let x = 0; x < gridSegments; x++) {
                    for (let subY = 0; subY < resolution; subY++) {
                        for (let subX = 0; subX < resolution; subX++) {
                            // è®¡ç®—ç²¾ç¡®ä½ç½®
                            const fx = x + subX / resolution;
                            const fy = y + subY / resolution;

                            // ä½¿ç”¨ç»Ÿä¸€æ’å€¼å‡½æ•°è®¡ç®—é«˜åº¦
                            const height = exactInterpolate(heightData.grid, fx, fy, heightData.grid.length);

                            // ä¸¥æ ¼æ˜ å°„é«˜åº¦åˆ°é¢œè‰²
                            const color = getExactTerrainColor(height, heightData.minHeight, heightData.maxHeight);

                            // å¡«å……åƒç´ 
                            offscreenContext.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                            offscreenContext.fillRect(
                                x * pixelSize + subX * subPixelSize,
                                y * pixelSize + subY * subPixelSize,
                                subPixelSize,
                                subPixelSize
                            );
                        }
                    }
                }
            }

            // å°†ç¦»å±ç”»å¸ƒå¤åˆ¶åˆ°ä¸»ç”»å¸ƒ
            context.drawImage(offscreenCanvas, offsetX, offsetY);
        }


        // ç¹ªè£½ç­‰é«˜ç·š
        function drawContourLine(context, positions, gridSize, height, offsetX, offsetY, pixelSize) {
            context.beginPath();
            let isFirstPoint = true;

            for (let y = 0; y < gridSize - 1; y++) {
                for (let x = 0; x < gridSize - 1; x++) {
                    const idx = (y * gridSize + x) * 3;
                    const h = positions[idx + 2];

                    if (Math.abs(h - height) < 0.1) {
                        if (isFirstPoint) {
                            context.moveTo(offsetX + x * pixelSize, offsetY + y * pixelSize);
                            isFirstPoint = false;
                        } else {
                            context.lineTo(offsetX + x * pixelSize, offsetY + y * pixelSize);
                        }
                    }
                }
            }
            context.stroke();
        }

        // ç¹ªè£½ç¶²æ ¼
        function drawGrid(context, gridSegments, offsetX, offsetY, pixelSize, gridIntervalMeters) {
            const totalSize = gridSegments * pixelSize;
            const gridCount = 4;
            const gridLines = gridSegments / gridCount;
            const eastingLabels = [];
            for (let i = 10; i < 10 + (gridCount + 1); i++) { // å¾10é–‹å§‹
                eastingLabels.push(String(i).padStart(2, '0'));
            }

            const northingLabels = [];
            for (let i = 65; i < 65 + (gridCount + 1); i++) {
                northingLabels.push(String(i).padStart(2, '0'));
            }
            northingLabels.reverse();

            context.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            context.lineWidth = 1;

            for (let i = 0; i <= gridSegments; i += gridLines) {
                context.beginPath();
                context.moveTo(offsetX + i * pixelSize, offsetY);
                context.lineTo(offsetX + i * pixelSize, offsetY + totalSize);
                context.stroke();

                context.beginPath();
                context.moveTo(offsetX, offsetY + i * pixelSize);
                context.lineTo(offsetX + totalSize, offsetY + i * pixelSize);
                context.stroke();

                // æ·»åŠ æ ¼ç¶²ç·¨è™Ÿ
                context.fillStyle = 'black';
                context.font = 'bold 16px Arial';

                const labelIndex = Math.round(i / gridLines);

                // æ±è¡Œç·šæ•¸å­—ä½ç½®ï¼šåœ¨ä¸Šæ–¹
                context.fillText(
                    eastingLabels[labelIndex],
                    offsetX + i * pixelSize - 6,
                    offsetY - 20
                );

                // åŒ—è¡Œç·šæ•¸å­—ä½ç½®ï¼šåœ¨å·¦æ–¹
                context.fillText(
                    northingLabels[labelIndex],
                    offsetX - 30,
                    offsetY + i * pixelSize + 6
                );
            }
        }

        // ç¹ªè£½æ¯”ä¾‹å°º
        function drawScaleBar(context, x, y, gridSegments, pixelSize) {
            const scaleHeight = 3;
            const totalMeters = 100; // åœ°åœ–ç¸½å¯¬åº¦ï¼ˆç±³ï¼‰
            const gridCount = 4;
            const gridInterval = totalMeters / gridCount;

            // åœ°åœ–ç¸½å¯¬åº¦ï¼ˆåƒç´ ï¼‰
            const mapWidthPixels = gridSegments * pixelSize;

            // ç¹ªè£½æ¯”ä¾‹å°ºèƒŒæ™¯
            context.fillStyle = 'rgba(255, 255, 255, 0.8)';
            context.fillRect(x - 5, y - 5, mapWidthPixels + 10, 35);

            // ç¹ªè£½æ¯”ä¾‹å°ºä¸»ç·š
            context.fillStyle = 'black';
            context.fillRect(x, y, mapWidthPixels, scaleHeight);

            // ç¹ªè£½åˆ»åº¦èˆ‡æ¨™ç±¤
            for (let i = 0; i <= gridCount; i++) {
                const xPos = x + (mapWidthPixels / gridCount) * i;

                // ç¹ªè£½åˆ»åº¦ç·š
                context.fillRect(xPos, y - 5, 1, 15);

                // ç¹ªè£½åˆ»åº¦æ¨™ç±¤
                context.font = '12px Arial';
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.fillText(`${gridInterval * i}m`, xPos, y + 20);
            }
        }

        function drawDebugInfo(context) {
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®è®Šæ›
            context.font = '12px Arial';
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillText(`Scale: ${currentScale.toFixed(2)}, Offset: X=${mapOffset.x.toFixed(0)}, Y=${mapOffset.y.toFixed(0)}`, 10, 20);
            context.restore();
        }

        // åœ¨generate2DMapå‡½æ•¸çµå°¾è™•èª¿ç”¨
        drawDebugInfo(mapContext);

        function animate() {
            requestAnimationFrame(animate);
            if (isMouseDown && currentTool) {
                modifyTerrain(); // ç¢ºä¿åœ¨æ»‘é¼ æŒ‰ä½æ™‚æŒçºŒæ›´æ–°åœ°å½¢
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrain);
                if (intersects.length > 0) {
                    updateRadiusIndicator(intersects[0].point);
                } else {
                    radiusIndicator.visible = false;
                    mouseHelper.visible = false;
                }
            }
            // ç§»å‹•è¨­å‚™çš„æ§åˆ¶é‚è¼¯
            if (isMobile && joystickActive) {
                const moveSpeed = 1.0;

                // ç²å–ç›¸æ©Ÿå‰æ–¹å‘å’Œå³æ–¹å‘
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(forward);
                right.crossVectors(forward, camera.up).normalize();

                // å°‡å‰æ–¹å‘æŠ•å½±åˆ°æ°´å¹³é¢ä¸Š
                forward.y = 0;
                forward.normalize();

                // æ ¹æ“šæ–æ¡¿ä½ç½®ç§»å‹•ç›¸æ©Ÿ
                const moveX = currentJoystickPos.x * moveSpeed;
                const moveZ = -currentJoystickPos.y * moveSpeed;

                camera.position.addScaledVector(right, moveX);
                camera.position.addScaledVector(forward, moveZ);
                controls.target.addScaledVector(right, moveX);
                controls.target.addScaledVector(forward, moveZ);
            }

            // åŸæœ‰çš„éµç›¤æ§åˆ¶é‚è¼¯ä¿æŒä¸è®Š
            if (!isMobile) {
                const moveSpeed = 1.0;
                const rotateSpeed = 0.02;

                // ç²å–ç›¸æ©Ÿå‰æ–¹å‘å’Œå³æ–¹å‘
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(forward);
                right.crossVectors(forward, camera.up).normalize();

                // å°‡å‰æ–¹å‘æŠ•å½±åˆ°æ°´å¹³é¢ä¸Š
                forward.y = 0;
                forward.normalize();

                // WASD ç§»å‹•
                if (keys.w) {
                    camera.position.addScaledVector(forward, moveSpeed);
                    controls.target.addScaledVector(forward, moveSpeed);
                }
                if (keys.s) {
                    camera.position.addScaledVector(forward, -moveSpeed);
                    controls.target.addScaledVector(forward, -moveSpeed);
                }
                if (keys.a) {
                    camera.position.addScaledVector(right, -moveSpeed);
                    controls.target.addScaledVector(right, -moveSpeed);
                }
                if (keys.d) {
                    camera.position.addScaledVector(right, moveSpeed);
                    controls.target.addScaledVector(right, moveSpeed);
                }

                // Z/C èª¿æ•´è¦–è§’
                if (keys.z) {
                    // å‘ä¸Šæ—‹è½‰ï¼ˆé™ä½è¦–è§’ï¼‰
                    const rotation = new THREE.Quaternion().setFromAxisAngle(right, rotateSpeed);
                    const cameraToTarget = camera.position.clone().sub(controls.target);
                    cameraToTarget.applyQuaternion(rotation);
                    camera.position.copy(controls.target).add(cameraToTarget);
                    camera.lookAt(controls.target);
                }
                if (keys.c) {
                    // å‘ä¸‹æ—‹è½‰ï¼ˆæé«˜è¦–è§’ï¼‰
                    const rotation = new THREE.Quaternion().setFromAxisAngle(right, -rotateSpeed);
                    const cameraToTarget = camera.position.clone().sub(controls.target);
                    cameraToTarget.applyQuaternion(rotation);
                    camera.position.copy(controls.target).add(cameraToTarget);
                    camera.lookAt(controls.target);
                }
            }
            updateMarkerPositions(); //æ¯æ¬¡éƒ½æ›´æ–°æ¨™è¨»ä½ç½®
            controls.update();
            renderer.render(scene, camera);
        }

        // æ–°å¢çš„è¼”åŠ©å‡½æ•¸
        function get3DPointFromMouse(coords) {
            // å°‡æ»‘é¼ åº§æ¨™è½‰æ›ç‚º 3D ç©ºé–“ä¸­çš„é»
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((coords.x - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((coords.y - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            const intersects = raycaster.intersectObject(terrain);

            if (intersects.length > 0) {
                return intersects[0].point.clone();
            }
            return null;
        }

        function update3DTube() {
            if (drawingPoints.length < 2) return;

            // å‰µå»ºå¹³æ»‘çš„æ›²ç·š
            const curve = new THREE.CatmullRomCurve3(drawingPoints);

            // å‰µå»ºç®¡ç‹€å¹¾ä½•é«”
            const tubeGeometry = new THREE.TubeGeometry(
                curve,
                drawingPoints.length * 10, // åˆ†æ®µæ•¸
                0.3, // ç®¡é“åŠå¾‘
                8, // ç®¡é“æˆªé¢åˆ†æ®µæ•¸
                false // æ˜¯å¦é–‰åˆ
            );

            // å‰µå»ºæè³ª
            const tubeMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(currentColor),
                metalness: 0.3,
                roughness: 0.7,
            });

            // å‰µå»ºæ–°çš„ç¶²æ ¼ä¸¦åŠ å…¥å ´æ™¯
            const newTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(newTube);

            // æ›´æ–°ç•¶å‰ç¹ªè£½ä¸­çš„ç®¡ç‹€ç‰©é«”
            if (tube3DMesh) {
                scene.remove(tube3DMesh);
            }
            tube3DMesh = newTube;
        }

        renderer.domElement.addEventListener('click', (event) => {
            if (is3DDrawingMode && isErasing) {
                const rect = renderer.domElement.getBoundingClientRect();
                const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
                const intersects = raycaster.intersectObjects(tube3DMeshes);

                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    scene.remove(mesh);
                    const index = tube3DMeshes.indexOf(mesh);
                    if (index > -1) {
                        tube3DMeshes.splice(index, 1);
                        save3DHistory();
                    }
                }
            }
        });

        // ä¿®æ”¹ 3D ç·šæ¢çš„æ­·å²è¨˜éŒ„ç®¡ç†
        function save3DHistory() {
            // å‰µå»ºç•¶å‰å ´æ™¯ä¸­æ‰€æœ‰ 3D ç·šæ¢çš„æ·±åº¦æ‹·è²
            const currentState = tube3DMeshes.map(mesh => ({
                geometry: mesh.geometry.clone(),
                material: mesh.material.clone(),
                position: mesh.position.clone(),
                rotation: mesh.rotation.clone(),
                scale: mesh.scale.clone()
            }));

            // æ¸…é™¤å¾Œé¢çš„æ­·å²è¨˜éŒ„
            tube3DMeshHistory = tube3DMeshHistory.slice(0, tube3DMeshHistoryIndex + 1);
            tube3DMeshHistory.push(currentState);
            tube3DMeshHistoryIndex++;
        }
    </script>
</body>
</html>
