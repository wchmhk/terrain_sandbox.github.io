<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="地形沙箱">
    <link rel="apple-touch-icon" href="圖標URL.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地形沙箱</title>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <style>
    canvas {
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .tool-button {
        cursor: pointer;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }
    .mobile-only {
        display: none;
    }

    @media (max-width: 768px) {
        .mobile-only {
            display: block;
        }
    }

    #developer-info {
       position: fixed;
       top: 10px;
       left: 10px;
       z-index: 1001; /* 確保文字在其他元素之上 */
       font-size: 12px;
       color: rgba(0, 0, 0, 0.6);
       pointer-events: none; /* 防止文字遮擋其他元素的事件 */
      }

    #mobile-controls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 1000;
    }

    #joystick-container {
        width: 120px;
        height: 120px;
        position: relative;
    }

    #joystick-base {
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        position: relative;
    }

    #joystick-knob {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .terrain-toolbar {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 45px; /* 與 drawing-toolbar 相同 */
        }
        .terrain-toolbar .tool-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .terrain-toolbar .tool-group:not(:last-child),
        .drawing-toolbar .tool-group:not(:last-child) {
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .tool-button {
             width: 35px;
             height: 35px;
             padding: 0;
             background: #4CAF50;
             border: none;
             border-radius: 4px;
             color: white;
             cursor: pointer;
             transition: all 0.3s;
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative;
             font-size: 24px; /*  調整此數值以改變 emoji 大小 */
         }

        .tool-button:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        .tool-button.active {
            background: #367c39;
            transform: scale(1.1);
        }

        .tool-tooltip {
            position: absolute;
            left: 45px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1001;
            pointer-events: none;
        }
        .tool-button:hover .tool-tooltip {
            opacity: 1;
        }
        .status-bar {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 12px;
        }
        .settings-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
        }
        .settings-panel.show {
            display: block;
        }
        .drawing-toolbar {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 45px;
        }

        .drawing-toolbar .tool-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .terrain-toolbar .tool-group:not(:last-child),
        .drawing-toolbar .tool-group:not(:last-child) {
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .color-btn {
            width: 35px;
            height: 35px;
            padding: 0;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-btn.active {
            border-color: #000;
            transform: scale(1.1);
        }
        .measurement-toolbar {
            position: fixed;
            top: 50%;
            left: 20px; /* 修改這裡 */
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 45px;
        }

        .map-drawing-toolbar {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
            flex-direction: column;
            gap: 10px;
            width: 45px;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .ruler {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #000;
            cursor: move;
            z-index: 3;
        }

        .protractor-tool {
            position: fixed;
            width: 300px; /* 確保 HTML 和 CSS 尺寸一致 */
            height: 300px;
            border: 2px solid #000;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0); /* 完全透明 */
            cursor: move;
            z-index: 1002; /* 確保在其他元素之上 */
            touch-action: none; /* 添加這行 */
            -webkit-user-select: none; /* 添加這行 */
            user-select: none; /* 添加這行 */
        }

        .protractor-tool.hidden {
            display: none;
        }

        /* 縱剖面面板樣式 */
        .profile-panel {
            position: fixed;
            /* 移除底部固定位置 */
            /* bottom: 20px; */
            /* left: 50%; */
            /* transform: translateX(-50%); */
            width: 80%;
            max-width: 800px;
            height: 250px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1010;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .profile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            cursor: grab; /* 添加抓取光标 */
            background: rgba(240, 240, 240, 0.95); /* 标题栏背景 */
        }

        .profile-title {
            font-weight: bold;
            font-size: 16px;
        }

        .profile-close {
            cursor: pointer;
            font-size: 20px;
            color: #666;
        }

        .profile-content {
            flex: 1;
            padding: 10px;
            position: relative;
        }

        .profile-canvas {
            width: 100%;
            height: 100%;
        }

        .profile-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .profile-point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: red;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            z-index: 1002;
        }

        .grid-number {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        #map-container {
            position: relative;
            overflow: visible;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* 降低 z-index */
        }
        #map-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab; /* 當鼠標懸停時顯示抓取手勢 */
            background-color: #ffffff
        }
        #map-drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        #file-input {
            display: none;
        }
        #addMarkerBtn {
          /* 按鈕樣式，可以根據需求調整 */
          border: 1px solid #ccc;
          padding: 8px;
          cursor: pointer;
          margin: 5px;
        }
        /* 標註樣式 */
        /* 標註樣式 */
        /* 標註樣式 */
        .marker {
            position: absolute;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            transform: translate(-50%, -10px); /* 調整標記位置 */
            cursor: pointer; /* 指標樣式 */
            z-index: 10; /* 確保標記在地圖之上 */
        }

        .marker-triangle {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 20px solid white;
            align-self: center;
        }

        .marker-label {
            background-color: white;
            padding: 2px 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            white-space: nowrap;
            font-size: 12px;
            text-align: center;
            position: relative; /* 相對於 .marker 定位 */
             left: 50%; /* 将左边缘移动到 .marker 的中心 */
             transform: translateX(-50%); /* 将 label 的中心对齐到 .marker 的中心 */
        }

        /* 右鍵菜單樣式（已存在，確保位置屬性合理） */
        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            z-index: 1000;
            display: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
        }
        .context-menu-item:hover {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
<input type="checkbox" id="debug-water-boundary" style="display:none">
<div id="developer-info">開發者：黃智軒老師</div>
    <div id="loading-screen">載入中...</div>
    <div id="map-container" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;">
    <canvas id="map-canvas"></canvas>
    <canvas id="map-drawing-canvas"></canvas>
</div>
<!-- 右鍵菜單 -->
<div id="contextMenu" class="context-menu">
    <div class="context-menu-item" id="editMarker">編輯標記</div>
    <div class="context-menu-item" id="deleteMarker">刪除標記</div>
</div>
    <div id="canvas-container"></div>
    <div id="mobile-controls" class="mobile-only">
        <div id="joystick-container">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
    </div>
    <div id="protractor-tool" class="protractor-tool hidden">
    <canvas id="protractor-canvas" width="300" height="300"></canvas>
</div>

<!-- 縱剖面面板 -->
<div class="profile-panel" id="profile-panel">
    <div class="profile-header">
        <div class="profile-title">縱剖面分析</div>
        <div class="profile-close" id="profile-close">×</div>
    </div>
    <div class="profile-content">
        <canvas class="profile-canvas" id="profile-canvas"></canvas>
        <div class="profile-info" id="profile-info">
            距離: 0m | 平均坡度: 0°
        </div>
    </div>
</div>

    <div class="terrain-toolbar">
        <div class="tool-group">
            <button class="tool-button" data-tool="raise">
                ⬆️
                <span class="tool-tooltip">抬升地形</span>
            </button>
            <button class="tool-button" data-tool="lower">
                ⬇️
                <span class="tool-tooltip">降低地形</span>
            </button>
            <button class="tool-button" data-tool="smooth">
                🔄
                <span class="tool-tooltip">平滑地形</span>
            </button>
            <button class="tool-button" id="map-mode-btn">
                🗺️
                <span class="tool-tooltip">地圖介面</span>
            </button>
            <button class="tool-button" id="addMarkerBtn">
                📌
                <span class="tool-tooltip">標註</span>
            </button>

        </div>
        <div class="tool-group">
            <button class="tool-button" id="settings-btn">
                ⚙️
                <span class="tool-tooltip">設置</span>
            </button>
            <button class="tool-button" id="save-btn">
                💾
                <span class="tool-tooltip">保存地形</span>
            </button>
            <button class="tool-button" id="load-btn">
                📂
                <span class="tool-tooltip">讀取地形</span>
            </button>
            <button class="tool-button" id="reset-btn">
                🔄
                <span class="tool-tooltip">重設</span>
            </button>
            <button class="tool-button" id="fullscreen-btn">
                🔲
                <span class="tool-tooltip">全屏模式</span>
            </button>
        </div>
    </div>
        <div class="drawing-toolbar">
            <div class="tool-group">
                <button class="tool-button color-btn" data-color="#ff0000" style="background: #ff0000;">
                    <span class="tool-tooltip">紅色筆</span>
                </button>
                <button class="tool-button color-btn" data-color="#0000ff" style="background: #0000ff;">
                    <span class="tool-tooltip">藍色筆</span>
                </button>
                <button class="tool-button color-btn" data-color="#ffff00" style="background: #ffff00;">
                    <span class="tool-tooltip">黃色筆</span>
                </button>
                <button class="tool-button color-btn" data-color="#00ff00" style="background: #00ff00;">
                    <span class="tool-tooltip">綠色筆</span>
                </button>
                <button class="tool-button color-btn" data-color="#ffffff" style="background: #ffffff;">
                    <span class="tool-tooltip">白色筆</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="draw3d-toggle">
                    🧵
                    <span class="tool-tooltip">3D繪圖模式</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="eraser-btn">
                    🧽
                    <span class="tool-tooltip">橡皮擦</span>
                </button>
                <button class="tool-button" id="undo-btn">
                    ↩️
                    <span class="tool-tooltip">上一步</span>
                </button>
                <button class="tool-button" id="redo-btn">
                    ↪️
                    <span class="tool-tooltip">下一步</span>
                </button>
                <button class="tool-button" id="clear-btn">
                    🗑️
                    <span class="tool-tooltip">清除全部</span>
                </button>
            </div>
        </div>

        <!-- 地圖模式的測量工具欄 -->
        <div class="measurement-toolbar" style="display: none;">
            <div class="tool-group">
                <button class="tool-button" id="return-3d-btn">
                    🔙
                    <span class="tool-tooltip">返回3D模式</span>
                </button>
            </div>
            <div class="tool-group">
              <button class="tool-button" id="polyline-toggle">
                   🔗
                 <span class="tool-tooltip">多點連線</span>
             </button>
             <button class="tool-button" id="polyline-clear">
                 🗑️
                 <span class="tool-tooltip">清除連線</span>
             </button>
                <button class="tool-button" id="protractor-toggle">
                    📐
                    <span class="tool-tooltip">量角器工具</span>
                </button>
                <button class="tool-button" id="profile-toggle">
                    📊
                    <span class="tool-tooltip">縱剖面分析</span>
                </button>
            </div>
            <div class="tool-group protractor-controls" style="display: none;">
                <button class="tool-button" id="protractor-recall">
                    📍
                    <span class="tool-tooltip">呼喚量角器</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="zoom-in">
                    🔍+
                    <span class="tool-tooltip">放大</span>
                </button>
                <button class="tool-button" id="zoom-out">
                    🔍-
                    <span class="tool-tooltip">縮小</span>
                </button>
            </div>
        </div>

        <!-- 地圖模式繪圖工具欄 -->
        <div class="map-drawing-toolbar">
            <div class="tool-group">
                <button class="tool-button map-color-btn" data-color="#ff0000" style="background: #ff0000;">
                    <span class="tool-tooltip">紅色筆</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#0000ff" style="background: #0000ff;">
                    <span class="tool-tooltip">藍色筆</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#ffff00" style="background: #ffff00;">
                    <span class="tool-tooltip">黃色筆</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#00ff00" style="background: #00ff00;">
                    <span class="tool-tooltip">綠色筆</span>
                </button>
                <button class="tool-button map-color-btn" data-color="#ffffff" style="background: #ffffff;">
                    <span class="tool-tooltip">白色筆</span>
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-button" id="map-eraser-btn">
                    🧽
                    <span class="tool-tooltip">橡皮擦</span>
                </button>
                <button class="tool-button" id="map-undo-btn">
                    ↩️
                    <span class="tool-tooltip">上一步</span>
                </button>
                <button class="tool-button" id="map-redo-btn">
                    ↪️
                    <span class="tool-tooltip">下一步</span>
                </button>
                <button class="tool-button" id="map-clear-btn">
                    🗑️
                    <span class="tool-tooltip">清除全部</span>
                </button>
            </div>
        </div>
    </div>

    <div class="settings-panel">
        <h4>參數設置</h4>
        <label>工具強度: <input type="range" id="tool-strength" min="1" max="100" value="40"></label>
        <label>工具範圍: <input type="range" id="tool-radius" min="1" max="100" value="40"></label>
        <label>橡皮擦大小: <input type="range" id="eraser-size" min="1" max="50" value="40"></label>
    </div>

    <div class="status-bar">
        座標: X: 0, Y: 0, Z: 0 | 高度: 0m | 坡度: 0°
    </div>
    <input type="file" id="file-input" accept=".json">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, terrain;
        let raycaster, mouse;
        let currentTool = null;
        let isMouseDown = false;
        let radiusIndicator, mouseHelper;
        let isDrawing = false;
        let isErasing = false;
        let currentColor = '#ff0000';
        let drawingHistory = [];
        let historyIndex = -1;
        let drawingCanvas, drawingContext;
        let isMapMode = false;
        let showGrid = false;
        let showDrawings = true;
        let ruler = null;
        let protractor = null;
        let gridOverlay = null;
        let currentScale = 1;
        let targetPosition = new THREE.Vector3(0, 0, 0);
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let joystickActive = false;
        let joystickBase = null;
        let joystickKnob = null;
        let joystickCenter = { x: 0, y: 0 };
        let currentJoystickPos = { x: 0, y: 0 };
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            z: false,
            c: false
        };
        let initialTerrainPositions; // 在這裡宣告 initialTerrainPositions 變數
        let terrainHistory = [];
        let terrainHistoryIndex = -1;
        let isPolylineMode = false;
        let polylinePoints = [];
        let totalDistance = 0;
        let polylineLayer = null;
        let pixelSize = 1;
        let protractorVisible = false;
        let isDraggingMap = false; // 是否正在拖移地圖
        let dragStart = { x: 0, y: 0 }; // 拖移開始的位置
        let mapOffset = { x: 0, y: 0 }; // 地圖的偏移量
        let activeMarker = null; //目前選定的標註
        let markers = []; // 儲存所有標記的陣列

        // 添加新的全局變量
        let is3DDrawingMode = false;
        let tube3DMeshes = []; // 改為陣列來存儲多個管狀物體
        let drawingPoints = [];

        // 在全局變量區域添加
        let tube3DMeshHistory = [[]]; // 存儲 3D 線條的歷史記錄
        let tube3DMeshHistoryIndex = 0; // 3D 線條歷史索引
        let tube3DMesh = null; // 當前正在繪製的 3D 線條

        // 縱剖面相關變量
        let isProfileMode = false;
        let profilePoints = [];
        let profileLine = null;
        let heightMultiplier = 10; // 高度縮放因子
        let controlPoint = null; // 初始化 controlPoint
        let isProfileCalculating = false;
        let profileTimeoutId = null;

        // 添加這些新變量來跟踪高亮點
        let profileHighlightPoint = null; // 用於存儲高亮點在地圖上的位置
        let isProfileHovering = false; // 用於標記滑鼠是否正在縱剖面圖上懸停
        // 添加高亮層畫布變量
        let highlightCanvas;
        let highlightContext;

        // 2D地圖繪圖相關變量
        let mapDrawingCanvas, mapDrawingContext;
        let mapDrawingHistory = [];
        let mapHistoryIndex = -1;
        let isMapDrawing = false;
        let isMapErasing = false;
        let mapCurrentColor = '#ff0000';

        // 初始化入口函數，確保DOM完全載入後才執行
        window.addEventListener('load', init);

        function init() {
            try {
                // 初始化3D場景
                initScene();

                // 初始化事件監聽器
                initEventListeners();

                // 創建半徑指示器
                createRadiusIndicator();

                // 初始化繪圖工具
                initDrawingTools();

                // 初始化地圖模式
                initMapMode();

                // 初始化量角器
                initProtractor();

                // 初始化2D地圖繪圖功能
                initMapDrawingTools();

                // 保存初始地形狀態
                const terrainPositions = terrain.geometry.attributes.position.array;
                const newTerrainPositions = new Float32Array(terrainPositions);
                terrainHistory.push({
                    type: 'terrain',
                    data: newTerrainPositions,
                    drawingIndex: -1,
                });
                terrainHistoryIndex++;

                // 保存初始狀態到歷史記錄
                saveToHistory();

                // 開始動畫循環
                animate();

                // 隱藏加載屏
                document.getElementById('loading-screen').style.display = 'none';
            } catch (error) {
                console.error('初始化錯誤:', error);
                document.getElementById('loading-screen').textContent = '載入失敗: ' + error.message;
            }

            // 移動設備初始化
            if (isMobile) {
                initMobileControls();
            }
        }

        const mapCanvas = document.getElementById('map-canvas');

        // 地圖拖動處理
        // 修改地图画布的mousedown事件处理器
        mapCanvas.addEventListener('mousedown', (e) => {
            // 对于纵剖面模式，改为只通过click事件处理，不在mousedown时处理
            if (isProfileMode) {
                // 仅更新鼠标样式，实际点击处理由click事件完成
                mapCanvas.style.cursor = 'crosshair';
                return;
            }

            // 只有在没有激活任何绘图工具和测量工具时才启用拖移
            if (isMapDrawing || isMapErasing || isPolylineMode) {
                return;
            }

            // 阻止事件冒泡和默認行為
            e.preventDefault();
            e.stopPropagation();

            // 明確設置拖移狀態
            isDraggingMap = true;

            // 保存點擊時的初始位置
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            mapCanvas.style.cursor = 'grabbing';

            console.log("開始拖移地圖", isDraggingMap);
        });

        // 修改mousemove事件处理器
        document.addEventListener('mousemove', (e) => {
            if (isDraggingMap) {
                // 計算拖動的距離
                const deltaX = e.clientX - dragStart.x;
                const deltaY = e.clientY - dragStart.y;

                // 更新地圖偏移量
                mapOffset.x += deltaX;
                mapOffset.y += deltaY;

                // 更新拖動起始點
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;

                // 使用CSS变换移动地图容器，而不是重绘
                updateMapContainerPosition();
            }
        });

        // 修改mouseup事件处理器
        document.addEventListener('mouseup', (e) => {
            if (isDraggingMap) {
                e.preventDefault();
                e.stopPropagation();
                console.log("結束拖移地圖");
            }

            isDraggingMap = false;
            if (isProfileMode) {
                mapCanvas.style.cursor = 'crosshair';
            } else {
                mapCanvas.style.cursor = 'grab';
            }
        });

        function updateMapContainerPosition() {
            const mapCanvas = document.getElementById('map-canvas');
            const mapDrawingCanvas = document.getElementById('map-drawing-canvas');

            // 使用CSS变换移动地图
            if (mapCanvas) {
                mapCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }

            // 同步移动绘图画布，使笔迹跟随地图
            if (mapDrawingCanvas) {
                mapDrawingCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }

            // 同步移動高亮層畫布
            if (highlightCanvas) {
                highlightCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }
        }

        function updateMapPosition() {
            // 更新地圖偏移並重新繪製地圖
            updateMapContainerPosition();


            // 清除繪圖畫布的樣式變換，因為我們在 Canvas 繪圖中應用了偏移
            const mapDrawingCanvas = document.getElementById('map-drawing-canvas');
            // 绘图画布需要与主画布同步变换
            if (mapDrawingCanvas) {
                mapDrawingCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
            }
        }

        // 獲取量角尺相關元素
        const protractorTool = document.getElementById('protractor-tool');
        const protractorCanvas = document.getElementById('protractor-canvas');
        const protractorCtx = protractorCanvas.getContext('2d');

        // 縱剖面相關元素
        const profilePanel = document.getElementById('profile-panel');
        const profileCanvas = document.getElementById('profile-canvas');
        const profileCtx = profileCanvas.getContext('2d');
        const profileInfo = document.getElementById('profile-info');
        const profileClose = document.getElementById('profile-close');

        // 初始化量角尺
        function initProtractor() {
            drawProtractor();
        }

        // 繪製量角尺
        function drawProtractor() {
            console.log('繪製量角尺開始');
            const ctx = protractorCtx;
            const canvasWidth = protractorCanvas.width;
            const canvasHeight = protractorCanvas.height;
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const radius = (Math.min(centerX, centerY) - 10) * currentScale;
            const crosshairSize = 20 * currentScale;
            const controlPointAngle = 45;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.globalAlpha = 1;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * currentScale;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerX - crosshairSize, centerY);
            ctx.lineTo(centerX + crosshairSize, centerY);
            ctx.moveTo(centerX, centerY - crosshairSize);
            ctx.lineTo(centerX, centerY + crosshairSize);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2 * currentScale;
            ctx.stroke();


            for (let angle = 0; angle < 360; angle += 1) {
                const adjustedAngle = angle - 90;
                const rad = adjustedAngle * (Math.PI / 180);
                let inner, outer, lineWidth, strokeStyle;

                if (angle % 30 === 0) {
                    inner = crosshairSize + 0 * currentScale;
                    outer = radius;
                    lineWidth = 2 * currentScale;
                    strokeStyle = '#000';
                } else if (angle % 10 === 0) {
                    inner = crosshairSize + 5 * currentScale;
                    outer = radius * currentScale;
                    lineWidth = 1.5 * currentScale;
                    strokeStyle = '#555';
                } else if (angle % 2 === 0) {
                     inner = crosshairSize + 105 * currentScale;
                    outer = radius * currentScale;
                   lineWidth = 0.5 * currentScale;
                    strokeStyle = '#000';
               }

               ctx.beginPath();
               ctx.moveTo(
                   centerX + inner * Math.cos(rad),
                   centerY + inner * Math.sin(rad)
               );
                ctx.lineTo(
                   centerX + outer * Math.cos(rad),
                    centerY + outer * Math.sin(rad)
                );
               ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
               ctx.stroke();


              if (angle % 30 === 0) {
                   const labelRadius = outer - (25 * currentScale);
                    const labelX = centerX + labelRadius * Math.cos(rad);
                   const labelY = centerY + labelRadius * Math.sin(rad);
                  ctx.font = `${14 * currentScale}px Arial`;
                  ctx.fillStyle = '#000';
                   ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                   const displayAngle = (angle === 0) ? '0' : angle.toString();
                    ctx.fillText(displayAngle, labelX, labelY);
                }
            }

            // 繪製縮放控制點 (45度處)
            const rad = (controlPointAngle - 90) * (Math.PI / 180);
            const pointX = centerX + (radius * Math.cos(rad));
            const pointY = centerY + (radius * Math.sin(rad));
            const pointRadius = 5 * currentScale;

            ctx.beginPath();
            ctx.arc(pointX, pointY, pointRadius, 0, 2 * Math.PI);
            ctx.fillStyle = '#00ff00'; // 控制點顏色 (綠色)
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1 * currentScale;
            ctx.stroke();

            // 設置 controlPoint 對象
            controlPoint = {
                x: pointX,
                y: pointY,
                radius: pointRadius
            };

            // 移除事件監聽器
           protractorCanvas.removeEventListener('mousedown', startControlPointDrag);
           protractorCanvas.removeEventListener('touchstart', startControlPointDrag);
           document.removeEventListener('mousemove', handleControlPointDrag);
           document.removeEventListener('touchmove', handleControlPointDrag);
           document.removeEventListener('mouseup', stopControlPointDrag);
           document.removeEventListener('touchend', stopControlPointDrag);

           // 添加事件監聽器
           protractorCanvas.addEventListener('mousedown', startControlPointDrag);
           protractorCanvas.addEventListener('touchstart', startControlPointDrag, { passive: false });
           document.addEventListener('mousemove', handleControlPointDrag);
            document.addEventListener('touchmove', handleControlPointDrag, { passive: false });
           document.addEventListener('mouseup', stopControlPointDrag);
          document.addEventListener('touchend', stopControlPointDrag);


            console.log('繪製量角尺完成');
        }

        // 顯示量角尺
        function showProtractor() {
            protractorTool.classList.remove('hidden');
            protractorVisible = true;
        }

        // 隱藏量角尺
        function hideProtractor() {
            protractorTool.classList.add('hidden');
            protractorVisible = false;
        }

        // 切換量角尺顯示狀態
        function toggleProtractor() {
            if(protractorVisible){
                hideProtractor();
            } else {
                showProtractor();
            }
        }

        // 監聽量角尺按鈕
        document.getElementById('protractor-toggle').addEventListener('click', () => {
            toggleProtractor();
        });

        // 使量角尺可拖拽
        let isDragging = false;
        let offset = { x: 0, y: 0 };

        // 滑鼠事件
        protractorTool.addEventListener('mousedown', (e) => {
            isDragging = true;
            offset.x = e.clientX - protractorTool.getBoundingClientRect().left;
            offset.y = e.clientY - protractorTool.getBoundingClientRect().top;
        });

        // 觸摸事件
        protractorTool.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            offset.x = touch.clientX - protractorTool.getBoundingClientRect().left;
            offset.y = touch.clientY - protractorTool.getBoundingClientRect().top;
        }, { passive: false });

        document.addEventListener('mousemove', (e) => {
            if(isDragging){
                protractorTool.style.left = `${e.clientX - offset.x}px`;
                protractorTool.style.top = `${e.clientY - offset.y}px`;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if(isDragging){
                e.preventDefault();
                const touch = e.touches[0];
                protractorTool.style.left = `${touch.clientX - offset.x}px`;
                protractorTool.style.top = `${touch.clientY - offset.y}px`;
            }
        }, { passive: false });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('touchend', () => {
            isDragging = false;
        });

        // 防止手勢衝突
        protractorTool.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        }, { passive: false });

        protractorTool.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        }, { passive: false });

        protractorTool.addEventListener('gestureend', (e) => {
            e.preventDefault();
        }, { passive: false });

        function getControlPointElement() {
            return protractorTool.querySelector('div[style*="border-radius: 50%"]'); // 確保符合選擇器
        }

        let isControlPointDragging = false; // 判斷是否正在拖拉控制點
        let dragStartPos = { x: 0, y: 0 }; // 拖拉開始的位置
        let initialScale = 1;

        // 啟動控制點拖拉
        function startControlPointDrag(e) {
            e.preventDefault();
            if (!controlPoint) return;

            let x, y;
            if (e.offsetX !== undefined && e.offsetY !== undefined) {
                x = e.offsetX;
                y = e.offsetY;
            }
            else if (e.touches && e.touches.length > 0) {
                const canvasRect = protractorCanvas.getBoundingClientRect();
                x = e.touches[0].clientX - canvasRect.left;
                y = e.touches[0].clientY - canvasRect.top;
            }
            else {
                return; //沒有觸碰，直接結束。
            }

            const distance = Math.sqrt((x-controlPoint.x)**2 + (y-controlPoint.y)**2);

            if (distance <= controlPoint.radius) {
                isControlPointDragging = true;
                dragStartPos = { x: x, y: y };
                initialScale = currentScale;
            }
        }

        // 拖拉控制點
        function handleControlPointDrag(e) {
            if (!isControlPointDragging) return;
            e.preventDefault();

            let x, y;
            if (e.offsetX !== undefined && e.offsetY !== undefined) {
                x = e.offsetX;
                y = e.offsetY;
            }
            else if (e.touches && e.touches.length > 0) {
                const canvasRect = protractorCanvas.getBoundingClientRect();
                x = e.touches[0].clientX - canvasRect.left;
                y = e.touches[0].clientY - canvasRect.top;
            }
            else {
                return; //沒有觸碰，直接結束。
            }

            const deltaX = x - dragStartPos.x;
            const scaleChange = (deltaX/200);

            currentScale = initialScale + scaleChange;
            currentScale = Math.max(0.1, Math.min(5, currentScale));
            drawProtractor();
        }

        // 停止控制點拖拉
        function stopControlPointDrag() {
            isControlPointDragging = false;
        }

        function initMobileControls() {
            joystickBase = document.getElementById('joystick-base');
            joystickKnob = document.getElementById('joystick-knob');

            // 觸摸事件處理
            joystickBase.addEventListener('touchstart', handleJoystickStart);
            document.addEventListener('touchmove', handleJoystickMove);
            document.addEventListener('touchend', handleJoystickEnd);
        }

        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function handleJoystickEnd() {
            joystickActive = false;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            currentJoystickPos = { x: 0, y: 0 };
        }

        function updateJoystickPosition(x, y) {
            const deltaX = x - joystickCenter.x;
            const deltaY = y - joystickCenter.y;
            const angle = Math.atan2(deltaY, deltaX);
            const distance = Math.min(40, Math.sqrt(deltaX * deltaX + deltaY * deltaY));

            const knobX = Math.cos(angle) * distance;
            const knobY = Math.sin(angle) * distance;

            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            currentJoystickPos = {
                x: knobX / 40,
                y: knobY / 40
            };
        }

        // 縱剖面相關函數
        function toggleProfileMode() {
            try {
                isProfileMode = !isProfileMode;
                const profileToggleBtn = document.getElementById('profile-toggle');
                profileToggleBtn.classList.toggle('active');

                // 重置縱剖面數據
                resetProfileTool();

                // 更新滑鼠樣式
                if (isProfileMode) {
                    mapCanvas.style.cursor = 'crosshair'; // 十字準心表示選擇模式

                    // 提示用戶選擇點
                    alert('請在地圖上點選兩個點以創建縱剖面分析');

                    // 禁用其他工具
                    resetOtherTools();
                } else {
                    mapCanvas.style.cursor = 'grab';
                    hideProfilePanel();
                }
            } catch (error) {
                console.error("切換縱剖面模式錯誤:", error);
                isProfileMode = false;
                if (profileToggleBtn) {
                    profileToggleBtn.classList.remove('active');
                }
                mapCanvas.style.cursor = 'grab';
            }
        }

        function resetOtherTools() {
            // 禁用其他測量工具
            isPolylineMode = false;
            const polylineToggleBtn = document.getElementById('polyline-toggle');
            if (polylineToggleBtn) {
                polylineToggleBtn.classList.remove('active');
            }
            hideProtractor();

            // 禁用地圖繪圖工具
            resetMapDrawingTools();
        }

        function resetProfileTool() {
            // 清除之前的點和縱剖面
            profilePoints = [];
            hideProfilePanel();

            // 重繪地圖（移除之前的線條）
            generate2DMap();
        }

        function handleProfileClick(e) {
            if (!isProfileMode) return;

            // 防止事件传播（避免拖曳地图）
            e.stopPropagation();

            try {
                console.log("处理纵剖面点击");
                // 获取点击位置
                const rect = mapCanvas.getBoundingClientRect();
                const clientX = e.clientX;
                const clientY = e.clientY;

                // 计算相对于变换后画布的点击位置
                const rawX = clientX - rect.left;
                const rawY = clientY - rect.top;

                // 考虑地图的变换（CSS transform）
                // 创建一个临时点用于计算
                const canvasCenterX = mapCanvas.width / 2;
                const canvasCenterY = mapCanvas.height / 2;

                // 将点击位置转换回原始（未变换）坐标空间
                // 先移除CSS变换的影响
                const withoutOffsetX = rawX - mapOffset.x;
                const withoutOffsetY = rawY - mapOffset.y;

                // 再考虑缩放（相对于中心点）
                const transformedX = canvasCenterX + (withoutOffsetX - canvasCenterX) / currentScale;
                const transformedY = canvasCenterY + (withoutOffsetY - canvasCenterY) / currentScale;

                // 计算地图的基本参数
                const mapSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                const gridSegments = 100;
                const pixelSize = mapSize / gridSegments;
                const offsetX = (mapCanvas.width - gridSegments * pixelSize) / 2;
                const offsetY = (mapCanvas.height - gridSegments * pixelSize) / 2;

                // 计算相对于地形网格的位置
                const gridX = (transformedX - offsetX) / pixelSize;
                const gridY = (transformedY - offsetY) / pixelSize;

                console.log("点击坐标:", {rawX, rawY, transformedX, transformedY, gridX, gridY});

                // 添加点（最多两个点）
                if (profilePoints.length < 2) {
                    // 检查点是否在有效范围内
                    if (gridX >= 0 && gridX <= gridSegments && gridY >= 0 && gridY <= gridSegments) {
                        profilePoints.push({
                            screenX: rawX,
                            screenY: rawY,
                            // 存储原始坐标（不含缩放信息）
                            transformedX: transformedX,
                            transformedY: transformedY,
                            // 存储网格坐标（用于高度计算）
                            gridX: gridX,
                            gridY: gridY,
                            // 存储选择点时的缩放因子
                            originalScale: currentScale
                        });

                        console.log("添加纵剖面点:", profilePoints.length);

                        // 如果已选两个点，则绘制纵剖面
                        if (profilePoints.length === 2) {
                            console.log("绘制纵剖面线和图表");
                            drawProfileLine();
                            // 使用延时避免阻塞UI
                            setTimeout(() => {
                                try {
                                    createProfileChart();
                                    showProfilePanel();
                                } catch (chartError) {
                                    console.error("创建剖面图表错误:", chartError);
                                    alert("创建剖面图表时发生错误，请重试");
                                    // 重置剖面工具
                                    resetProfileTool();
                                }
                            }, 100);
                        } else {
                            // 重绘地图以显示第一个点
                            generate2DMap();
                        }
                    } else {
                        console.warn("点击位置超出有效范围:", {gridX, gridY});
                    }
                }
            } catch (error) {
                console.error("处理纵剖面点击错误:", error);
                alert("处理纵剖面点击时发生错误。请重试或重置工具。");
                // 重置剖面工具，避免卡死
                resetProfileTool();
            }
        }

        function drawProfileLine() {
            try {
                // 在地圖上繪製連線
                if (profilePoints.length !== 2) return;

                const mapContext = mapCanvas.getContext('2d');

                // 保存畫布狀態
                mapContext.save();

                // 應用與地圖相同的變換
                mapContext.translate(mapOffset.x, mapOffset.y);
                mapContext.translate(mapCanvas.width / 2, mapCanvas.height / 2);
                mapContext.scale(currentScale, currentScale);
                mapContext.translate(-mapCanvas.width / 2, -mapCanvas.height / 2);

                // 繪製連接線
                mapContext.beginPath();

                // 考慮原始缩放因子和当前缩放因子的差异
                // 计算每个点在当前缩放级别下的位置
                const canvasCenterX = mapCanvas.width / 2;
                const canvasCenterY = mapCanvas.height / 2;

                // 调整第一个点
                const point1 = profilePoints[0];
                // 从中心点计算相对位置
                const relX1 = point1.transformedX - canvasCenterX;
                const relY1 = point1.transformedY - canvasCenterY;
                // 调整为当前缩放级别
                const adjustedX1 = canvasCenterX + (relX1 * point1.originalScale / currentScale);
                const adjustedY1 = canvasCenterY + (relY1 * point1.originalScale / currentScale);

                // 调整第二个点
                const point2 = profilePoints[1];
                const relX2 = point2.transformedX - canvasCenterX;
                const relY2 = point2.transformedY - canvasCenterY;
                const adjustedX2 = canvasCenterX + (relX2 * point2.originalScale / currentScale);
                const adjustedY2 = canvasCenterY + (relY2 * point2.originalScale / currentScale);

                // 使用调整后的坐标
                mapContext.moveTo(adjustedX1, adjustedY1);
                mapContext.lineTo(adjustedX2, adjustedY2);
                mapContext.strokeStyle = '#ff0000';
                mapContext.lineWidth = 3 / currentScale; // 考慮縮放調整線寬
                mapContext.stroke();

                // 繪製點（使用调整后的坐标）
                for (let i = 0; i < profilePoints.length; i++) {
                    const point = profilePoints[i];
                    const relX = point.transformedX - canvasCenterX;
                    const relY = point.transformedY - canvasCenterY;
                    const adjustedX = canvasCenterX + (relX * point.originalScale / currentScale);
                    const adjustedY = canvasCenterY + (relY * point.originalScale / currentScale);

                    mapContext.beginPath();
                    mapContext.arc(adjustedX, adjustedY, 6 / currentScale, 0, 2 * Math.PI);
                    mapContext.fillStyle = i === 0 ? '#00ff00' : '#ff0000';
                    mapContext.fill();
                    mapContext.strokeStyle = '#ffffff';
                    mapContext.lineWidth = 2 / currentScale;
                    mapContext.stroke();

                    // 更新点的临时位置以供其他函数使用
                    point.adjustedX = adjustedX;
                    point.adjustedY = adjustedY;
                }

                // 繪製高亮點（如果存在）
                if (isProfileHovering && profileHighlightPoint) {
                    mapContext.beginPath();

                    // 计算高亮点相对于线段的位置（仍保持相同的相对位置）
                    const p1 = profilePoints[0];
                    const p2 = profilePoints[1];

                    // 计算高亮点在调整后的线段上的相应位置
                    let highlightX, highlightY;

                    if (profileHighlightPoint.t !== undefined) {
                        // 如果已经保存了插值因子，直接使用
                        const t = profileHighlightPoint.t;
                        highlightX = adjustedX1 + (adjustedX2 - adjustedX1) * t;
                        highlightY = adjustedY1 + (adjustedY2 - adjustedY1) * t;
                    } else {
                        // 否则使用原始高亮点
                        highlightX = profileHighlightPoint.x;
                        highlightY = profileHighlightPoint.y;
                    }

                    mapContext.arc(
                        highlightX,
                        highlightY,
                        8 / currentScale, // 稍大一點更醒目
                        0,
                        2 * Math.PI
                    );
                    mapContext.fillStyle = '#ffff00'; // 黃色
                    mapContext.strokeStyle = '#000000'; // 黑色邊框
                    mapContext.lineWidth = 2 / currentScale;
                    mapContext.fill();
                    mapContext.stroke();
                }

                // 恢復畫布狀態
                mapContext.restore();
            } catch (error) {
                console.error("繪製縱剖面線錯誤:", error);
            }
            // 添加懸停效果初始化
            addProfileHoverEffect();
        }

        function createProfileChart() {
            try {
                if (profilePoints.length !== 2) return;

                // 獲取縱剖面畫布和上下文
                const canvas = profileCanvas;
                const ctx = profileCtx;

                // 調整畫布大小
                canvas.width = canvas.offsetWidth || 800;
                canvas.height = canvas.offsetHeight || 200;

                // 清除畫布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 獲取地形數據
                const positions = terrain.geometry.attributes.position.array;
                const gridSize = Math.sqrt(positions.length / 3);

                // 設置縱剖面圖的邊距
                const margin = {
                    top: 20,
                    right: 20,
                    bottom: 40,
                    left: 60
                };

                const width = canvas.width - margin.left - margin.right;
                const height = canvas.height - margin.top - margin.bottom;

                // 獲取兩點之間的高度採樣
                const samples = 100; // 採樣點數量
                const samplePoints = [];

                // 計算分析線上的每個點
                for (let i = 0; i < samples; i++) {
                    const t = i / (samples - 1);

                    // 在網格坐標上進行插值
                    const gridX = profilePoints[0].gridX + t * (profilePoints[1].gridX - profilePoints[0].gridX);
                    const gridY = profilePoints[0].gridY + t * (profilePoints[1].gridY - profilePoints[0].gridY);

                    // 使用雙線性插值獲取高度
                    const height = bilinearInterpolate(positions, gridSize, gridX, gridY) * heightMultiplier;

                    // 計算距離（以米為單位）
                    const distance = Math.sqrt(
                        Math.pow(profilePoints[1].gridX - profilePoints[0].gridX, 2) +
                        Math.pow(profilePoints[1].gridY - profilePoints[0].gridY, 2)
                    ) * (100 / 100); // 縮放到實際地形尺寸（100米）

                    const currentDistance = t * distance;

                    samplePoints.push({
                        distance: currentDistance,
                        height: height,
                        x: margin.left + (width * t),
                        y: margin.top + height * (height < 0 ? 0.5 : 1) // 高度縮放
                    });
                }

                // 找出高度的最大值和最小值
                let minHeight = Math.min(...samplePoints.map(p => p.height));
                let maxHeight = Math.max(...samplePoints.map(p => p.height));

                // 為了更好的視覺效果，確保高度範圍合理
                const heightRange = maxHeight - minHeight;
                if (heightRange < 10) {
                    // 如果範圍太小，擴大範圍
                    const mid = (maxHeight + minHeight) / 2;
                    minHeight = mid - 5;
                    maxHeight = mid + 5;
                }

                // 計算總距離和平均坡度
                const totalDistance = samplePoints[samplePoints.length - 1].distance;
                const heightDifference = Math.abs(samplePoints[samplePoints.length - 1].height - samplePoints[0].height);
                const averageSlope = Math.atan(heightDifference / totalDistance) * (180 / Math.PI);

                // 更新資訊面板
                profileInfo.textContent = `距離: ${totalDistance.toFixed(1)}m | 平均坡度: ${averageSlope.toFixed(1)}°`;

                // 繪製背景
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(margin.left, margin.top, width, height);

                // 繪製座標軸
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                // X軸
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top + height);
                ctx.lineTo(margin.left + width, margin.top + height);
                ctx.stroke();

                // Y軸
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top);
                ctx.lineTo(margin.left, margin.top + height);
                ctx.stroke();

                // 繪製X軸標籤
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';

                // 距離刻度
                const distanceStep = Math.ceil(totalDistance / 5); // 5個刻度
                for (let d = 0; d <= totalDistance; d += distanceStep) {
                    const x = margin.left + (d / totalDistance) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top + height);
                    ctx.lineTo(x, margin.top + height + 5);
                    ctx.stroke();
                    ctx.fillText(`${d}m`, x, margin.top + height + 8);
                }

                // 繪製Y軸標籤
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                // 高度刻度
                const heightStep = Math.ceil((maxHeight - minHeight) / 5); // 5個刻度
                for (let h = Math.floor(minHeight); h <= Math.ceil(maxHeight); h += heightStep) {
                    const normalizedHeight = (h - minHeight) / (maxHeight - minHeight);
                    const y = margin.top + height - (normalizedHeight * height);

                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left - 5, y);
                    ctx.stroke();
                    ctx.fillText(`${h.toFixed(0)}m`, margin.left - 8, y);

                    // 繪製水平輔助線
                    ctx.beginPath();
                    ctx.strokeStyle = '#ddd';
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + width, y);
                    ctx.stroke();
                    ctx.strokeStyle = '#000';
                }

                // X軸標題
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillText('距離 (m)', margin.left + width / 2, margin.top + height + 25);

                // Y軸標題
                ctx.save();
                ctx.translate(margin.left - 40, margin.top + height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('高度 (m)', 0, 0);
                ctx.restore();

                // 繪製地形曲線
                ctx.beginPath();

                // 正規化高度值到繪圖區域
                const normalizeY = (h) => margin.top + height - ((h - minHeight) / (maxHeight - minHeight) * height);

                // 移動到第一個點
                ctx.moveTo(samplePoints[0].x, normalizeY(samplePoints[0].height));

                // 繪製剩餘點
                for (let i = 1; i < samplePoints.length; i++) {
                    ctx.lineTo(samplePoints[i].x, normalizeY(samplePoints[i].height));
                }

                // 繪製線條
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.stroke();

                // 填充地形下方區域
                ctx.lineTo(samplePoints[samplePoints.length - 1].x, normalizeY(minHeight));
                ctx.lineTo(samplePoints[0].x, normalizeY(minHeight));
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fill();

                // 繪製起點和終點標記
                const startY = normalizeY(samplePoints[0].height);
                const endY = normalizeY(samplePoints[samplePoints.length - 1].height);

                // 起點（綠色）
                ctx.beginPath();
                ctx.arc(samplePoints[0].x, startY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // 終點（紅色）
                ctx.beginPath();
                ctx.arc(samplePoints[samplePoints.length - 1].x, endY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // 添加海拔標籤
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(`${samplePoints[0].height.toFixed(1)}m`, samplePoints[0].x, startY - 8);

                ctx.textBaseline = 'bottom';
                ctx.fillText(`${samplePoints[samplePoints.length - 1].height.toFixed(1)}m`,
                           samplePoints[samplePoints.length - 1].x, endY - 8);
            } catch (error) {
                console.error("創建縱剖面圖錯誤:", error);
            }
        }

        function hideProfilePanel() {
            profilePanel.style.display = 'none';
        }

        // 繪製縱剖面選擇點
        function drawProfilePoints(context) {
            // 保存上下文状态
            context.save();

            for (let i = 0; i < profilePoints.length; i++) {
                const point = profilePoints[i];
                context.beginPath();

                // 使用变换过的坐标
                const drawX = point.transformedX;
                const drawY = point.transformedY;

                context.arc(drawX, drawY, 6 / currentScale, 0, 2 * Math.PI);
                context.fillStyle = i === 0 ? '#00ff00' : '#ff0000'; // 起点绿色，终点红色
                context.fill();
                context.strokeStyle = '#ffffff';
                context.lineWidth = 2 / currentScale;
                context.stroke();
            }

            // 恢复上下文状态
            context.restore();
        }

        function makeProfilePanelDraggable() {
            const profilePanel = document.getElementById('profile-panel');
            const profileHeader = profilePanel.querySelector('.profile-header');

            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            // 鼠标事件
            profileHeader.addEventListener('mousedown', (e) => {
                // 确保不是点击关闭按钮
                if (e.target.id === 'profile-close') return;

                isDragging = true;
                dragOffset.x = e.clientX - profilePanel.getBoundingClientRect().left;
                dragOffset.y = e.clientY - profilePanel.getBoundingClientRect().top;
                profilePanel.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const left = e.clientX - dragOffset.x;
                const top = e.clientY - dragOffset.y;

                // 确保面板不会被拖出屏幕
                const maxX = window.innerWidth - profilePanel.offsetWidth;
                const maxY = window.innerHeight - profilePanel.offsetHeight;

                profilePanel.style.left = `${Math.max(0, Math.min(left, maxX))}px`;
                profilePanel.style.top = `${Math.max(0, Math.min(top, maxY))}px`;
                profilePanel.style.bottom = 'auto'; // 取消底部定位
                profilePanel.style.transform = 'none'; // 取消原来的中心定位
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                profilePanel.style.cursor = 'default';
            });

            // 触摸事件
            profileHeader.addEventListener('touchstart', (e) => {
                if (e.target.id === 'profile-close') return;

                isDragging = true;
                const touch = e.touches[0];
                dragOffset.x = touch.clientX - profilePanel.getBoundingClientRect().left;
                dragOffset.y = touch.clientY - profilePanel.getBoundingClientRect().top;
                e.preventDefault(); // 防止滚动
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;

                const touch = e.touches[0];
                const left = touch.clientX - dragOffset.x;
                const top = touch.clientY - dragOffset.y;

                const maxX = window.innerWidth - profilePanel.offsetWidth;
                const maxY = window.innerHeight - profilePanel.offsetHeight;

                profilePanel.style.left = `${Math.max(0, Math.min(left, maxX))}px`;
                profilePanel.style.top = `${Math.max(0, Math.min(top, maxY))}px`;
                profilePanel.style.bottom = 'auto';
                profilePanel.style.transform = 'none';
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        }

        // 在showProfilePanel函数中调用此函数
        function showProfilePanel() {
            profilePanel.style.display = 'flex';

            // 初始设置为居中
            profilePanel.style.left = '50%';
            profilePanel.style.top = '50%';
            profilePanel.style.transform = 'translate(-50%, -50%)';
            profilePanel.style.bottom = 'auto';

            // 确保面板可拖动
            makeProfilePanelDraggable();

            // 确保 canvas 在显示后调整大小
            setTimeout(() => {
                profileCanvas.width = profileCanvas.offsetWidth || 800;
                profileCanvas.height = profileCanvas.offsetHeight || 200;
                createProfileChart(); // 在调整大小后重新绘制
            }, 100);
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xb0d5e8);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 50, 60);
            camera.lookAt(0, 0, 0);
            camera.rotation.y = Math.PI/2;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createTerrain();

            // 儲存初始地形資料
            const terrainPositions = terrain.geometry.attributes.position.array;
            initialTerrainPositions = new Float32Array(terrainPositions);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = true;      // 啟用平移
            controls.panSpeed = 1.0;        // 調整平移速度
            controls.enableZoom = true;     // 啟用縮放
            controls.zoomSpeed = 1.0;       // 調整縮放速度
            controls.enableRotate = true;   // 啟用旋轉
            controls.rotateSpeed = 0.8;     // 調整旋轉速度
            controls.maxPolarAngle = Math.PI / 2; // 限制最大俯視角度為90度
            controls.minPolarAngle = 0;     // 允許完全垂直視角
            controls.screenSpacePanning = true; // 使平移與屏幕空間對齊
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(100, 100, 100, 100);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    colorLow: { value: new THREE.Color(0x228B22) },    // 深綠色
                    colorMid: { value: new THREE.Color(0xffd700) },    // 黃色
                    colorHigh: { value: new THREE.Color(0x800000) },   // 深紅色
                    colorWaterShallow: { value: new THREE.Color(0x87CEEB) }, // 淺藍色
                    colorWaterDeep: { value: new THREE.Color(0x0000FF) },   // 深藍色
                    contourInterval: { value: 2.0 },
                    contourWidth: { value: 0.1 },
                    heightScale: { value: 1.0 },
                    maxHeight: { value: 1.0 },
                    waterThreshold: { value: -0.5 }  // 水深閾值（0.5米）
                },
                vertexShader: `
                    varying float vHeight;
                    void main() {
                        vHeight = position.z;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 colorLow;
                    uniform vec3 colorMid;
                    uniform vec3 colorHigh;
                    uniform vec3 colorWaterShallow;
                    uniform vec3 colorWaterDeep;
                    uniform float contourInterval;
                    uniform float contourWidth;
                    uniform float heightScale;
                    uniform float maxHeight;
                    uniform float waterThreshold;
                    varying float vHeight;

                    void main() {
                        float scaledHeight = vHeight * heightScale;
                        vec3 terrainColor;
                        float heightPercent;

                        if (scaledHeight < 0.0) {
                            // 處理負高度（水域）
                            if (scaledHeight > waterThreshold) {
                                // 0到-0.5米之間，使用淺藍色
                                terrainColor = colorWaterShallow;
                            } else {
                                // 低於-0.5米，使用深藍色
                                terrainColor = colorWaterDeep;
                            }
                        } else {
                            // 處理正高度（陸地）
                            heightPercent = scaledHeight / maxHeight;
                            if (heightPercent <= 0.5) {
                                terrainColor = mix(colorLow, colorMid, heightPercent * 2.0);
                            } else {
                                terrainColor = mix(colorMid, colorHigh, (heightPercent - 0.5) * 2.0);
                            }
                        }

                        // 等高線處理
                        float finalColor = 1.0;
                        float absHeight = abs(scaledHeight);
                        if (absHeight > 0.01) {
                            float contour = mod(absHeight, contourInterval);
                            float line = smoothstep(0.0, contourWidth, contour) *
                                        smoothstep(contourInterval, contourInterval - contourWidth, contour);
                            finalColor = line;
                        }

                        gl_FragColor = vec4(mix(vec3(0.0), terrainColor, finalColor), 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);
        }

        function createRadiusIndicator() {
            const geometry = new THREE.CircleGeometry(1, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                opacity: 0.3,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            radiusIndicator = new THREE.Mesh(geometry, material);
            radiusIndicator.rotation.x = -Math.PI / 2;
            radiusIndicator.visible = false;
            scene.add(radiusIndicator);

            const helperGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const helperMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                depthTest: false
            });
            mouseHelper = new THREE.Mesh(helperGeometry, helperMaterial);
            mouseHelper.visible = false;
            scene.add(mouseHelper);
        }

        function updateRadiusIndicator(position) {
            if (!radiusIndicator) return;

            const toolRadius = document.getElementById('tool-radius').value / 5;
            radiusIndicator.position.copy(position);
            radiusIndicator.position.z += 0.1;
            radiusIndicator.scale.set(toolRadius, toolRadius, 1);
            radiusIndicator.visible = true;

            mouseHelper.position.copy(position);
            mouseHelper.position.z += 0.2;
            mouseHelper.visible = true;
        }

        function onTouchStart(event) {
            event.preventDefault();

            if (currentTool === 'addMarker') {
                const touch = event.touches[0];
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                addMarker(event);
                currentTool = null;
                controls.enabled = true;
                return;
            }

            if (currentTool) {
                isMouseDown = true;
                const touch = event.touches[0];
                updateTouchPosition(touch);
                modifyTerrain();
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (!isMouseDown) return;

            const touch = event.touches[0];
            updateTouchPosition(touch);
            if (currentTool) {
                modifyTerrain();
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            isMouseDown = false;
            if (currentTool) saveToHistory();
        }

        function updateTouchPosition(touch) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function initEventListeners() {
            try {
                // 地形工具按鈕事件監聽
                document.querySelectorAll('.terrain-toolbar .tool-button[data-tool]').forEach(button => {
                    button.addEventListener('click', () => {
                        // 如果當前工具已經被選中，則取消選中
                        if (currentTool === button.dataset.tool) {
                            currentTool = null;
                            button.classList.remove('active');
                            controls.enabled = true;
                            if (radiusIndicator) radiusIndicator.visible = false;
                            if (mouseHelper) mouseHelper.visible = false;
                            if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
                            return;
                        }

                        // 重置所有工具按鈕的狀態
                        resetTerrainTools();

                        // 設置新的工具狀態
                        currentTool = button.dataset.tool;
                        button.classList.add('active');
                        controls.enabled = false;
                        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
                    });
                });

                // 標註按鈕事件監聽
                const addMarkerBtn = document.getElementById('addMarkerBtn');
                if (addMarkerBtn) {
                    addMarkerBtn.addEventListener('click', () => {
                        resetTerrainTools();
                        currentTool = 'addMarker';
                        controls.enabled = false;
                        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
                        if (isMobile) {
                            alert('請點擊地圖位置來添加標記');
                        }
                    });
                }

                let renderContainer = renderer.domElement;

                if (isMobile) {
                    renderContainer.addEventListener('touchstart', onTouchStart);
                    renderContainer.addEventListener('touchmove', onTouchMove);
                    renderContainer.addEventListener('touchend', onTouchEnd);
                } else {
                    renderContainer.addEventListener('pointerdown', onMouseDown);
                    renderContainer.addEventListener('pointermove', onMouseMove);
                    renderContainer.addEventListener('pointerup', onMouseUp);
                }

                // 保存按鈕事件
                const saveBtn = document.getElementById('save-btn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => {
                        saveTerrain();
                    });
                }

                // 載入按鈕事件
                const loadBtn = document.getElementById('load-btn');
                if (loadBtn) {
                    loadBtn.addEventListener('click', () => {
                        document.getElementById('file-input').click();
                    });
                }

                // 文件輸入事件
                const fileInput = document.getElementById('file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', loadTerrain);
                }

                // 重設按鈕事件
                const resetBtn = document.getElementById('reset-btn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        resetTerrain();
                    });
                }

                // 設置按鈕事件
                const settingsBtn = document.getElementById('settings-btn');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', () => {
                        const panel = document.querySelector('.settings-panel');
                        panel.classList.toggle('show');
                    });
                }

                // 縱剖面按鈕事件
                const profileToggleBtn = document.getElementById('profile-toggle');
                if (profileToggleBtn) {
                    profileToggleBtn.addEventListener('click', () => {
                        toggleProfileMode();
                    });
                }

                // 縱剖面關閉按鈕事件
                const profileCloseBtn = document.getElementById('profile-close');
                if (profileCloseBtn) {
                    profileCloseBtn.addEventListener('click', () => {
                        hideProfilePanel();
                    });
                }

                // 鍵盤事件
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (keys.hasOwnProperty(key)) {
                        keys[key] = true;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (keys.hasOwnProperty(key)) {
                        keys[key] = false;
                    }
                });

                // 窗口大小調整事件
                window.addEventListener('resize', () => {
                    if (camera) {
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                    }
                    if (renderer) {
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                    if (drawingCanvas) {
                        drawingCanvas.width = window.innerWidth;
                        drawingCanvas.height = window.innerHeight;
                        if (historyIndex >= 0 && drawingHistory[historyIndex] && drawingHistory[historyIndex].canvas) {
                            drawingContext.drawImage(drawingHistory[historyIndex].canvas, 0, 0);
                        }
                    }
                });

            } catch (error) {
                console.error("初始化事件監聽器錯誤:", error);
            }
        }

        // 在縱剖面畫布上添加滑鼠移動監聽
        function addProfileHoverEffect() {
            const profileCanvas = document.getElementById('profile-canvas');
            let debounceTimer;

            profileCanvas.addEventListener('mousemove', (e) => {
                if (profilePoints.length !== 2) return;

                // 清除之前的計時器
                clearTimeout(debounceTimer);

                // 設置新的計時器
                debounceTimer = setTimeout(() => {
                    isProfileHovering = true;

                    // 獲取滑鼠在畫布上的位置
                    const rect = profileCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;

                    // 計算畫布內容區域
                    const margin = {
                        top: 20,
                        right: 20,
                        bottom: 40,
                        left: 60
                    };
                    const contentWidth = profileCanvas.width - margin.left - margin.right;
                    const contentLeft = margin.left;

                    // 計算滑鼠在內容區域的相對位置(0-1)
                    let relativeX = (x - contentLeft) / contentWidth;
                    relativeX = Math.max(0, Math.min(1, relativeX)); // 確保在0-1範圍內

                    // 在地圖上更新高亮點
                    updateHighlightPoint(relativeX);
                }, 10); // 10毫秒的防抖延遲
            });

            profileCanvas.addEventListener('mouseout', () => {
                isProfileHovering = false;
                clearTimeout(debounceTimer);
                // 移除高亮點
                profileHighlightPoint = null;
                // 清除高亮層
                if (highlightContext) {
                    highlightContext.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                }
            });
        }

        // 在地圖上更新高亮點位置
        function updateHighlightPoint(relativePosition) {
            // 基於相對位置計算兩點之間的位置
            const p1 = profilePoints[0];
            const p2 = profilePoints[1];

            // 保存插值因子，这是高亮点在线段上的相对位置
            const t = relativePosition;

            // 使用adjustedX和adjustedY（已在drawProfileLine函数中计算）
            // 这些是考虑了缩放因子的调整坐标
            const x1 = p1.adjustedX !== undefined ? p1.adjustedX : p1.transformedX;
            const y1 = p1.adjustedY !== undefined ? p1.adjustedY : p1.transformedY;
            const x2 = p2.adjustedX !== undefined ? p2.adjustedX : p2.transformedX;
            const y2 = p2.adjustedY !== undefined ? p2.adjustedY : p2.transformedY;

            // 计算线性插值位置
            const highlightX = x1 + (x2 - x1) * t;
            const highlightY = y1 + (y2 - y1) * t;

            // 保存高亮點位置和插值因子
            profileHighlightPoint = {
                x: highlightX,
                y: highlightY,
                t: t  // 保存插值因子以便在缩放变化时重新计算位置
            };

            // 使用覆蓋層繪製高亮點
            drawHighlightPointOnly();
        }

        function drawHighlightPointOnly() {
            if (!isProfileMode || !isProfileHovering || !profileHighlightPoint || !highlightContext) return;

            // 清除整個高亮層
            highlightContext.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            // 保存當前畫布狀態
            highlightContext.save();

            // 應用與地圖相同的變換
            // 這裡的關鍵是使用與drawProfileLine中相同的變換
            highlightContext.translate(mapOffset.x, mapOffset.y);
            highlightContext.translate(highlightCanvas.width / 2, highlightCanvas.height / 2);
            highlightContext.scale(currentScale, currentScale);
            highlightContext.translate(-highlightCanvas.width / 2, -highlightCanvas.height / 2);

            // 使用插值因子t来确定高亮点在线段上的位置
            let x, y;

            if (profileHighlightPoint.t !== undefined && profilePoints.length === 2) {
                const t = profileHighlightPoint.t;

                // 使用adjustedX和adjustedY（在drawProfileLine中计算好的坐标）
                const p1 = profilePoints[0];
                const p2 = profilePoints[1];

                const x1 = p1.adjustedX !== undefined ? p1.adjustedX : p1.transformedX;
                const y1 = p1.adjustedY !== undefined ? p1.adjustedY : p1.transformedY;
                const x2 = p2.adjustedX !== undefined ? p2.adjustedX : p2.transformedX;
                const y2 = p2.adjustedY !== undefined ? p2.adjustedY : p2.transformedY;

                // 线性插值计算高亮点位置
                x = x1 + (x2 - x1) * t;
                y = y1 + (y2 - y1) * t;
            } else {
                // 如果没有插值因子，直接使用保存的坐标
                x = profileHighlightPoint.x;
                y = profileHighlightPoint.y;
            }

            // 绘制黄色高亮点
            highlightContext.beginPath();
            highlightContext.arc(x, y, 8 / currentScale, 0, 2 * Math.PI);
            highlightContext.fillStyle = '#ffff00'; // 黃色
            highlightContext.strokeStyle = '#000000'; // 黑色邊框
            highlightContext.lineWidth = 2 / currentScale;
            highlightContext.fill();
            highlightContext.stroke();

            // 恢復畫布狀態
            highlightContext.restore();
        }

        function onMouseDown(event) {
            event.preventDefault();

            if (currentTool === 'addMarker') {
                addMarker(event);
                currentTool = null;
                controls.enabled = true;
                if (radiusIndicator) radiusIndicator.visible = false;
                if (mouseHelper) mouseHelper.visible = false;
                return;
            }

            if (currentTool) {
                isMouseDown = true;
                updateMousePosition(event);
                modifyTerrain();
            }
        }

         function onMouseMove(event) {
             event.preventDefault();
               updateMousePosition(event);
                   // 更新狀態欄
                updateStatusBar(event);
               //  在標註模式下，隱藏滑鼠工具
                if(currentTool === 'addMarker') {
                   radiusIndicator.visible = false;
                   mouseHelper.visible = false;
                   return;
                }

               // 只在選擇了工具的情況下顯示指示器
                if (currentTool) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(terrain);
                    if (intersects.length > 0) {
                        updateRadiusIndicator(intersects[0].point);
                    } else {
                        radiusIndicator.visible = false;
                        mouseHelper.visible = false;
                    }

                   // 如果滑鼠按住，持續修改地形
                    if (isMouseDown) {
                        modifyTerrain();
                    }
                }
           }

        function onMouseUp(event) {
               event.preventDefault();
               isMouseDown = false;
                if (currentTool) saveToHistory();
           }

        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function addMarker(event) {
            try {
                // 轉換觸摸或滑鼠事件到適當的座標
                const coordinates = getEventCoordinates(event);

                // 更新滑鼠位置
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((coordinates.x - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((coordinates.y - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrain);

                if (intersects.length > 0) {
                    const point = intersects[0].point;

                    const markerDiv = document.createElement('div');
                    markerDiv.classList.add('marker');
                    markerDiv.style.position = 'absolute';
                    document.getElementById('canvas-container').appendChild(markerDiv);

                    const markerLabel = document.createElement('div');
                    markerLabel.classList.add('marker-label');
                    markerDiv.appendChild(markerLabel);

                    const markerTriangle = document.createElement('div');
                    markerTriangle.classList.add('marker-triangle');
                    markerDiv.appendChild(markerTriangle);

                    // 為觸控設備添加特殊的事件處理
                    markerDiv.addEventListener('contextmenu', handleMarkerContextMenu);
                    markerDiv.addEventListener('touchstart', handleMarkerTouchStart);
                    markerDiv.addEventListener('touchend', handleMarkerTouchEnd);

                    let markerName = prompt('請輸入標記名稱:', '新標記');
                    if (markerName === null || markerName === '') {
                        markerDiv.remove();
                        return;
                    }
                    markerLabel.textContent = markerName;

                    const newMarker = {
                        element: markerDiv,
                        position: point,
                        label: markerName
                    };

                    markers.push(newMarker);
                    updateMarkerPositions();
                }
            } catch (error) {
                console.error("添加標記錯誤:", error);
                alert("添加標記時發生錯誤，請再試一次。");
            }
        }

        function getEventCoordinates(event) {
            if (event.touches && event.touches.length > 0) {
                return {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
            return {
                x: event.clientX,
                y: event.clientY
            };
        }

        // 添加觸控事件處理
        let touchTimer = null;
        let touchStartX = 0;
        let touchStartY = 0;

        function handleMarkerTouchStart(event) {
            event.preventDefault();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;

            touchTimer = setTimeout(() => {
                handleMarkerContextMenu({
                    preventDefault: () => {},
                    clientX: touchStartX,
                    clientY: touchStartY,
                    currentTarget: event.currentTarget,
                    stopPropagation: () => {}
                });
            }, 500);
        }

        function handleMarkerTouchEnd(event) {
            event.preventDefault();
            if (touchTimer) {
                clearTimeout(touchTimer);
            }

            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            const moveDistance = Math.sqrt(
                Math.pow(touchEndX - touchStartX, 2) +
                Math.pow(touchEndY - touchStartY, 2)
            );

            if (moveDistance < 10) {
                // 可以添加輕觸處理邏輯
            }
        }


          function updateMarkerPositions() {
              markers.forEach(marker => {
                  // 將 3D 坐標投影到 2D 螢幕坐標
                  const screenPosition = marker.position.clone().project(camera);
                  const canvasRect = renderer.domElement.getBoundingClientRect();
                  const x = (screenPosition.x + 1) / 2 * canvasRect.width;
                  const y = (1 - screenPosition.y) / 2 * canvasRect.height;

                  // 使用射線投射重新獲取標註位置的地形高度
                   raycaster.setFromCamera(screenPosition, camera);
                   const intersects = raycaster.intersectObject(terrain);

                  let markerWorldY = 0;
                  if(intersects.length > 0){
                       markerWorldY = intersects[0].point.y;
                   } else {
                          markerWorldY = marker.position.y;
                      }

                   const worldToScreen = marker.position.clone().project(camera);
                   const markerYOnScreen =  (1 - worldToScreen.y) / 2 * canvasRect.height;
                  const markerHeightOnScreen = (1 - (markerWorldY  - 0.01) - camera.position.y) / (camera.far - camera.near) * canvasRect.height;


                   // 計算縮放比例
                  const distanceToCamera = camera.position.distanceTo(marker.position);
                  const baseScale = 1.5; // 調整標註默認大小
                  const scaleFactor = baseScale / (distanceToCamera * 0.008 + 1);

                   // 更新標註位置，使用新的高度計算和縮放
                   marker.element.style.left = `${x}px`;
                   marker.element.style.top = `${markerYOnScreen}px`;
                   marker.element.style.transform = `translate(-50%, calc(-100% + ${markerHeightOnScreen}px)) scale(${scaleFactor})`;
                  marker.element.style.pointerEvents = 'auto';
              });
          }

        function handleMarkerContextMenu(event) {
             event.preventDefault();
              // 找出點擊的標記
               const clickedMarker = markers.find(marker => marker.element === event.currentTarget);
              if (!clickedMarker) return;
               activeMarker = clickedMarker; // 儲存目前點擊的標記

             // 顯示右鍵菜單
              const contextMenu = document.getElementById('contextMenu');
              contextMenu.style.display = 'block';
              contextMenu.style.left = `${event.clientX}px`;
              contextMenu.style.top = `${event.clientY}px`;

              // 阻止事件冒泡到畫布，避免觸發其他事件
             event.stopPropagation();
         }

         // 編輯標記事件
        document.getElementById('editMarker').addEventListener('click', () => {
            if(activeMarker) {
                  const newLabel = prompt('請輸入新的標記名稱:', activeMarker.label);
                  if(newLabel !== null) {
                       activeMarker.label = newLabel;
                       activeMarker.element.querySelector('.marker-label').textContent = newLabel;
                  }
            }
            hideContextMenu();
        });

        // 刪除標記事件
         document.getElementById('deleteMarker').addEventListener('click', () => {
             if (activeMarker) {
                  activeMarker.element.remove();
                 markers = markers.filter(marker => marker !== activeMarker);
             }
              hideContextMenu();
         });

        // 點擊其他地方隱藏右鍵菜單
         document.addEventListener('click', hideContextMenu);

         // 定義隱藏右鍵選單的函數
         function hideContextMenu() {
             document.getElementById('contextMenu').style.display = 'none';
             activeMarker = null;
         }

        function modifyTerrain() {
             if (!currentTool || !isMouseDown) return;
             raycaster.setFromCamera(mouse, camera);
             const intersects = raycaster.intersectObject(terrain);
             if (intersects.length > 0) {
                 const intersection = intersects[0];
                 const positions = terrain.geometry.attributes.position.array;
                 const toolStrength = document.getElementById('tool-strength').value / 250;
                 const toolRadius = document.getElementById('tool-radius').value / 5;

                 const clickPosition = intersection.point;
                 const localClickPosition = clickPosition.clone();
                 terrain.worldToLocal(localClickPosition);

                 let terrainModified = false;

                 for (let i = 0; i < positions.length; i += 3) {
                     const vertexX = positions[i];
                     const vertexY = positions[i + 1];

                     const dx = vertexX - localClickPosition.x;
                     const dy = vertexY - localClickPosition.y;
                     const distance = Math.sqrt(dx * dx + dy * dy);

                     if (distance < toolRadius) {
                          const influence = Math.cos((distance / toolRadius) * Math.PI * 0.5);
                          const strength = toolStrength * influence;
                          let localModified = 0; // 追蹤區域修改量

                         switch (currentTool) {
                             case 'raise':
                                 localModified += strength;
                                 break;
                             case 'lower':
                                 localModified -= strength;
                                 break;
                             case 'smooth':
                                 const averageHeight = getAverageHeight(i, positions, toolRadius);
                                 localModified += (averageHeight - positions[i + 2]) * strength;
                                 break;
                          }
                           positions[i+2] += localModified;
                            terrainModified = true;
                     }
                 }


                 if (terrainModified) {
                    terrain.geometry.attributes.position.needsUpdate = true;
                    terrain.geometry.computeVertexNormals();
                    updateTerrainMaterial();
                 }
              }
         }

        function getAverageHeight(index, positions, radius) {
            let sum = 0;
            let count = 0;
            const vertexCount = positions.length / 3;
            const gridSize = Math.sqrt(vertexCount);
            const x = Math.floor((index / 3) % gridSize);
            const y = Math.floor((index / 3) / gridSize);

            const currentX = positions[index];
            const currentY = positions[index + 1];

            for (let i = 0; i < positions.length; i += 3) {
                const otherX = positions[i];
                const otherY = positions[i + 1];

                const dx = otherX - currentX;
                const dy = otherY - currentY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius) {
                    sum += positions[i + 2];
                    count++;
                }
            }

            return count > 0 ? sum / count : positions[index + 2];
        }

        function updateTerrainMaterial() {
            if (terrain && terrain.material.uniforms) {
                const positions = terrain.geometry.attributes.position.array;
                let minHeight = Infinity;
                let maxHeight = -Infinity;

                for (let i = 2; i < positions.length; i += 3) {
                    minHeight = Math.min(minHeight, positions[i]);
                    maxHeight = Math.max(maxHeight, positions[i]);
                }

                // 將等高線間距固定為 20 米（因為有 10 倍的高度倍數，所以這裡設為 2.0）
                terrain.material.uniforms.contourInterval.value = 2.0;  // 改這裡
                terrain.material.uniforms.heightScale.value = 1.0;
                terrain.material.uniforms.maxHeight.value = maxHeight;
            }
        }

        function updateStatusBar(event) {
            const heightMultiplier = 10;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(terrain);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                const gridSpacing = 25;
                const eastingBase = 10;
                const northingBase = 65;

                // 將座標轉換為正數
                const gridX = point.x + 50;
                const gridZ = -point.z + 50;

                // 1. 計算東行線編號（前兩位數）
                 const eastingLineNumber = Math.floor(gridX / gridSpacing) + eastingBase;

                // 2. 計算東行格網內的小行位置（第三位數，使用餘數計算偏移量）
                let eastingOffset = gridX % gridSpacing;
                let eastingSubLine = Math.floor((eastingOffset / gridSpacing) * 9) + 1;
                if (eastingSubLine > 9) eastingSubLine = 9;


               // 3. 計算北行線編號（後兩位數）
                const northingLineNumber = Math.floor(gridZ / gridSpacing) + northingBase;

               // 4. 計算北行格網內的小行位置（第六位數，使用餘數計算偏移量，並確保由南到北遞增）
                let northingOffset = gridZ % gridSpacing;
                let northingSubLine = Math.floor((northingOffset / gridSpacing) * 9) + 1;
                if (northingSubLine > 9) northingSubLine = 9;

                 // 5. 組合六位數座標
                const eastingStr = String(eastingLineNumber).padStart(2, '0');
                const eastingSubLineStr = String(eastingSubLine).padStart(1, '0');
                const northingStr = String(northingLineNumber).padStart(2, '0');
                const northingSubLineStr = String(northingSubLine).padStart(1, '0');

                const gridCoordinate = `${eastingStr}${eastingSubLineStr}${northingStr}${northingSubLineStr}`;


                const heightValue = point.y * heightMultiplier;
                const z = heightValue.toFixed(1);

                const face = intersects[0].face;
                const normal = face.normal.clone();
                normal.applyQuaternion(terrain.quaternion);
                const slope = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0))) * (180 / Math.PI);

                const statusBar = document.querySelector('.status-bar');
                statusBar.textContent = `座標: ${gridCoordinate},  高度: ${z}m | 坡度: ${slope.toFixed(1)}°`;
            }
        }

        function saveTerrain() {
            try {
                const positions = terrain.geometry.attributes.position.array;

                const terrainData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    vertexCount: positions.length,
                    positions: Array.from(positions),
                    metadata: {
                        gridSize: Math.sqrt(positions.length / 3),
                        terrainWidth: 100,
                        terrainHeight: 100
                    }
                };

                const jsonString = JSON.stringify(terrainData);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `terrain_${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.json`;

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                alert('地形儲存成功！');
            } catch (error) {
                console.error('儲存地形時發生錯誤:', error);
                alert('儲存地形時發生錯誤！');
            }
        }

        function loadTerrain(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const terrainData = JSON.parse(e.target.result);

                        if (!terrainData.version || !terrainData.positions) {
                            throw new Error('無效的地形數據格式');
                        }

                        const positions = terrain.geometry.attributes.position.array;
                        if (positions.length !== terrainData.positions.length) {
                            throw new Error('地形數據大小不匹配');
                        }

                        for (let i = 0; i < positions.length; i++) {
                            positions[i] = terrainData.positions[i];
                        }

                        terrain.geometry.attributes.position.needsUpdate = true;
                        terrain.geometry.computeVertexNormals();
                        updateTerrainMaterial();

                        alert('地形載入成功！');
                    } catch (error) {
                        console.error('載入地形時發生錯誤:', error);
                        alert('載入地形時發生錯誤！');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            } catch (error) {
                console.error('讀取文件錯誤:', error);
                alert('讀取文件錯誤！');
            }
        }

        function resetTerrain() {
           try {
               if (!confirm('確定要重設地形嗎？這將清除所有修改。')) return;

               const positions = terrain.geometry.attributes.position.array;
               for (let i = 0; i < positions.length; i++) {
                   positions[i] = initialTerrainPositions[i];
               }

               terrain.geometry.attributes.position.needsUpdate = true;
               terrain.geometry.computeVertexNormals();
               updateTerrainMaterial();

               terrainHistory = [];
               terrainHistoryIndex = -1;
               saveToHistory();

               alert('地形已重設！');
           } catch (error) {
               console.error('重設地形錯誤:', error);
               alert('重設地形時發生錯誤！');
           }
        }

        // 檢查瀏覽器是否支持全屏模式
        function getFullscreenElement() {
            return document.fullscreenElement ||
                   document.webkitFullscreenElement ||
                   document.mozFullScreenElement ||
                   document.msFullscreenElement;
        }

        // 請求全屏
        function requestFullscreen(element) {
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }

        // 退出全屏
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }

        // 切換全屏模式
        function toggleFullscreen() {
            if (!getFullscreenElement()) {
                requestFullscreen(document.documentElement);
                fullscreenBtn.classList.add('active-exit'); // 使用類名切換樣式
            } else {
                exitFullscreen();
                fullscreenBtn.classList.remove('active-exit');
            }
        }

        // 監聽全屏變化事件
        function handleFullscreenChange() {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            if (!getFullscreenElement()) {
                fullscreenBtn.innerHTML = '🔲<span class="tool-tooltip">全屏模式</span>';
            } else {
                fullscreenBtn.innerHTML = '⛶<span class="tool-tooltip">退出全屏</span>';
            }
        }

        function initDrawingTools() {
            try {
                let lastX = 0;
                let lastY = 0;
                isDrawing = false;

                // 創建繪圖畫布
                drawingCanvas = document.createElement('canvas');
                drawingCanvas.style.position = 'absolute';
                drawingCanvas.style.top = '0';
                drawingCanvas.style.left = '0';
                // 初始時禁用繪圖功能，讓鼠標事件穿透到 3D 場景
                drawingCanvas.style.pointerEvents = 'none';
                drawingCanvas.style.zIndex = '1';
                document.getElementById('canvas-container').appendChild(drawingCanvas);

                // 設置畫布大小
                function resizeCanvas() {
                    drawingCanvas.width = window.innerWidth;
                    drawingCanvas.height = window.innerHeight;
                    drawingContext = drawingCanvas.getContext('2d');
                    drawingContext.lineCap = 'round';
                    drawingContext.lineJoin = 'round';
                    drawingContext.lineWidth = 3;
                    drawingContext.globalCompositeOperation = 'source-over';

                    // 重繪歷史內容
                    if (historyIndex >= 0 && drawingHistory[historyIndex] && drawingHistory[historyIndex].canvas) {
                        drawingContext.drawImage(drawingHistory[historyIndex].canvas, 0, 0);
                    }
                }

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // 繪圖事件處理
                function getEventCoordinates(e) {
                    if (e.touches && e.touches[0]) {
                        const rect = drawingCanvas.getBoundingClientRect();
                        return {
                            x: e.touches[0].clientX - rect.left,
                            y: e.touches[0].clientY - rect.top
                        };
                    }
                    return {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                }

                // 添加 3D 繪圖模式切換按鈕事件
                const draw3dToggleBtn = document.getElementById('draw3d-toggle');
                if (draw3dToggleBtn) {
                    draw3dToggleBtn.addEventListener('click', () => {
                        is3DDrawingMode = !is3DDrawingMode;
                        draw3dToggleBtn.classList.toggle('active');

                        // 如果關閉 3D 繪圖模式，清除當前未完成的 3D 線條
                        if (!is3DDrawingMode && tube3DMesh) {
                            scene.remove(tube3DMesh);
                            tube3DMesh = null;
                        }
                    });
                }

                // 繪圖事件處理
                function startDraw(e) {
                    e.preventDefault();
                    if (currentTool) return;
                    if (!document.querySelector('.color-btn.active') && !isErasing) return;

                    isDrawing = true;
                    const coords = getEventCoordinates(e);
                    [lastX, lastY] = [coords.x, coords.y];

                    if (is3DDrawingMode && !isErasing) {
                        // 開始新的 3D 繪圖，但不刪除之前的線條
                        drawingPoints = []; // 只重置當前繪圖點
                        const point = get3DPointFromMouse(coords);
                        if (point) {
                            drawingPoints.push(point);
                        }
                    } else {
                        // 原有的 2D 繪圖邏輯
                        drawingContext.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
                        drawingContext.lineWidth = isErasing ? document.getElementById('eraser-size').value * 2 : 3;
                        if(historyIndex === -1) saveToHistory();
                    }
                }

                function draw(e) {
                    e.preventDefault();
                    if (!isDrawing || currentTool) return;

                    const coords = getEventCoordinates(e);

                    if (is3DDrawingMode && !isErasing) {
                        // 3D 繪圖
                        const point = get3DPointFromMouse(coords);
                        if (point) {
                            drawingPoints.push(point);
                            update3DTube();
                        }
                    } else {
                        // 原有的 2D 繪圖邏輯
                        drawingContext.beginPath();
                        drawingContext.moveTo(lastX, lastY);
                        drawingContext.lineTo(coords.x, coords.y);
                        drawingContext.strokeStyle = isErasing ? 'rgba(0,0,0,1)' : currentColor;
                        drawingContext.stroke();
                        [lastX, lastY] = [coords.x, coords.y];
                    }
                }

                function stopDraw() {
                    if (isDrawing) {
                        isDrawing = false;
                        if (is3DDrawingMode && tube3DMesh) {
                            tube3DMeshes.push(tube3DMesh);
                            save3DHistory();
                            tube3DMesh = null;
                        } else if (!is3DDrawingMode) {
                            saveToHistory();
                        }
                    }
                }

                // 綁定鼠標事件
                drawingCanvas.addEventListener('mousedown', startDraw);
                drawingCanvas.addEventListener('mousemove', draw);
                drawingCanvas.addEventListener('mouseup', stopDraw);
                drawingCanvas.addEventListener('mouseout', stopDraw);

                // 綁定觸控事件
                drawingCanvas.addEventListener('touchstart', startDraw, { passive: false });
                drawingCanvas.addEventListener('touchmove', draw, { passive: false });
                drawingCanvas.addEventListener('touchend', stopDraw);
                drawingCanvas.addEventListener('touchcancel', stopDraw);

                // 添加橡皮擦範圍指示器
                const eraserIndicator = document.createElement('div');
                eraserIndicator.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    border: 2px solid rgba(0, 0, 0, 0.8);
                    border-radius: 50%;
                    display: none;
                    z-index: 1000;
                `;
                document.body.appendChild(eraserIndicator);

                // 更新橡皮擦指示器位置和大小的函數
                function updateEraserIndicator(e) {
                    if (isErasing) {
                        const size = document.getElementById('eraser-size').value * 2;
                        eraserIndicator.style.width = `${size}px`;
                        eraserIndicator.style.height = `${size}px`;
                        eraserIndicator.style.left = `${e.clientX - size/2}px`;
                        eraserIndicator.style.top = `${e.clientY - size/2}px`;
                        eraserIndicator.style.display = 'block';
                    } else {
                        eraserIndicator.style.display = 'none';
                    }
                }

                // 在畫布上添加鼠標移動事件
                drawingCanvas.addEventListener('mousemove', updateEraserIndicator);
                drawingCanvas.addEventListener('mouseenter', updateEraserIndicator);
                drawingCanvas.addEventListener('mouseleave', () => {
                    eraserIndicator.style.display = 'none';
                });

                // 橡皮擦按鈕事件
                const eraserBtn = document.getElementById('eraser-btn');
                if (eraserBtn) {
                    eraserBtn.addEventListener('click', () => {
                        if (is3DDrawingMode) {
                            isErasing = !isErasing;
                            eraserBtn.classList.toggle('active');

                            // 更新鼠標樣式
                            renderer.domElement.style.cursor = isErasing ? 'crosshair' : 'default';

                            // 禁用/啟用軌道控制器
                            controls.enabled = !isErasing;

                            // 重置其他工具狀態
                            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                            drawingCanvas.style.pointerEvents = 'none';
                        } else {
                            // 原有的 2D 橡皮擦邏輯
                            isErasing = !isErasing;
                            eraserBtn.classList.toggle('active');
                            drawingCanvas.style.cursor = isErasing ? 'crosshair' : 'default';
                        }
                    });
                }

                // 為橡皮擦大小滑塊添加事件監聽器
                const eraserSize = document.getElementById('eraser-size');
                if (eraserSize) {
                    eraserSize.addEventListener('input', (e) => {
                        if (isErasing) {
                            const size = e.target.value * 2;
                            eraserIndicator.style.width = `${size}px`;
                            eraserIndicator.style.height = `${size}px`;
                            drawingContext.lineWidth = size;
                        }
                    });
                }

                // 修改顏色按鈕事件
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // 如果當前顏色已經被選中，則取消選中並恢復默認狀態
                        if (btn.classList.contains('active')) {
                            btn.classList.remove('active');
                            drawingCanvas.style.pointerEvents = 'none';
                            controls.enabled = true;
                            isDrawing = false;
                            return;
                        }

                        // 重置所有工具狀態
                        resetTerrainTools();

                        // 設置新的繪圖狀態
                        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentColor = btn.dataset.color;
                        isErasing = false;
                        document.getElementById('eraser-btn').classList.remove('active');

                        // 啟用繪圖功能
                        drawingCanvas.style.pointerEvents = 'auto';
                        controls.enabled = false;
                        isDrawing = false;
                    });
                });

                // 上一步按鈕
                const undoBtn = document.getElementById('undo-btn');
                if (undoBtn) {
                    undoBtn.addEventListener('click', () => {
                        if (is3DDrawingMode && tube3DMeshHistoryIndex > 0) {
                            tube3DMeshHistoryIndex--;

                            // 清除當前場景中的所有 3D 線條
                            tube3DMeshes.forEach(mesh => scene.remove(mesh));
                            tube3DMeshes = [];

                            // 恢復上一個狀態
                            const previousState = tube3DMeshHistory[tube3DMeshHistoryIndex];
                            previousState.forEach(meshData => {
                                const mesh = new THREE.Mesh(
                                    meshData.geometry,
                                    meshData.material
                                );
                                mesh.position.copy(meshData.position);
                                mesh.rotation.copy(meshData.rotation);
                                mesh.scale.copy(meshData.scale);
                                scene.add(mesh);
                                tube3DMeshes.push(mesh);
                            });
                        } else if (!is3DDrawingMode) {
                            // 原有的 2D 上一步邏輯
                            if (historyIndex > 0) {
                                historyIndex--;
                                redrawCanvas();
                            }
                        }
                    });
                }

                // 下一步按鈕
                const redoBtn = document.getElementById('redo-btn');
                if (redoBtn) {
                    redoBtn.addEventListener('click', () => {
                        if (is3DDrawingMode && tube3DMeshHistoryIndex < tube3DMeshHistory.length - 1) {
                            tube3DMeshHistoryIndex++;

                            // 清除當前場景中的所有 3D 線條
                            tube3DMeshes.forEach(mesh => scene.remove(mesh));
                            tube3DMeshes = [];

                            // 恢復下一個狀態
                            const nextState = tube3DMeshHistory[tube3DMeshHistoryIndex];
                            nextState.forEach(meshData => {
                                const mesh = new THREE.Mesh(
                                    meshData.geometry,
                                    meshData.material
                                );
                                mesh.position.copy(meshData.position);
                                mesh.rotation.copy(meshData.rotation);
                                mesh.scale.copy(meshData.scale);
                                scene.add(mesh);
                                tube3DMeshes.push(mesh);
                            });
                        } else if (!is3DDrawingMode) {
                            // 原有的 2D 下一步邏輯
                            if (historyIndex < drawingHistory.length - 1) {
                                historyIndex++;
                                redrawCanvas();
                            }
                        }
                    });
                }

                // 清除按鈕
                const clearBtn = document.getElementById('clear-btn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        if (confirm('確定要清除所有繪圖內容嗎？')) {
                            if (is3DDrawingMode) {
                                // 清除所有 3D 線條
                                tube3DMeshes.forEach(mesh => scene.remove(mesh));
                                tube3DMeshes = [];
                                if (tube3DMesh) {
                                    scene.remove(tube3DMesh);
                                    tube3DMesh = null;
                                }

                                // 更新歷史記錄
                                save3DHistory();
                            } else {
                                // 清除 2D 繪圖
                                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                                drawingHistory = [];
                                historyIndex = -1;
                                saveToHistory();
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("初始化繪圖工具錯誤:", error);
            }
        }

        function saveToHistory() {
            try {
                // 複製地形數據
                if (terrain && terrain.geometry && terrain.geometry.attributes.position) {
                    const terrainPositions = terrain.geometry.attributes.position.array;
                    const newTerrainPositions = new Float32Array(terrainPositions);

                    if (currentTool === 'raise' || currentTool === 'lower' || currentTool === 'smooth') {
                        // 移除當前位置之後的地形歷史記錄
                        terrainHistory = terrainHistory.slice(0, terrainHistoryIndex + 1);
                        terrainHistory.push({
                            type: 'terrain',
                            data: newTerrainPositions,
                            drawingIndex: historyIndex, // 儲存繪圖索引
                        });
                        terrainHistoryIndex++;
                    } else if (drawingCanvas && drawingContext) {
                        // 移除當前位置之後的繪圖歷史記錄
                        drawingHistory = drawingHistory.slice(0, historyIndex + 1);

                        // 創建新的畫布並複製當前內容
                        const newCanvas = document.createElement('canvas');
                        newCanvas.width = drawingCanvas.width || 0;
                        newCanvas.height = drawingCanvas.height || 0;

                        // 只有當畫布有尺寸時才複製
                        if (newCanvas.width > 0 && newCanvas.height > 0) {
                            newCanvas.getContext('2d').drawImage(drawingCanvas, 0, 0);
                        }

                        // 添加到歷史記錄 (包含畫布)
                        drawingHistory.push({
                            type: 'drawing',
                            canvas: newCanvas,
                            terrainIndex: terrainHistoryIndex, //儲存地形索引
                        });
                        historyIndex++;
                    }
                }
            } catch (error) {
                console.error("保存歷史記錄錯誤:", error);
            }
        }


        function redrawCanvas() {
            try {
                if (currentTool === 'raise' || currentTool === 'lower' || currentTool === 'smooth') {
                    // 還原地形數據
                    if (terrainHistoryIndex >= 0 && terrainHistory[terrainHistoryIndex]?.data) {
                        const terrainPositions = terrain.geometry.attributes.position.array;
                        const savedTerrainPositions = terrainHistory[terrainHistoryIndex].data;

                        for (let i = 0; i < terrainPositions.length; i++) {
                            terrainPositions[i] = savedTerrainPositions[i];
                        }
                        terrain.geometry.attributes.position.needsUpdate = true;
                        terrain.geometry.computeVertexNormals();
                        updateTerrainMaterial();

                        if (terrainHistory[terrainHistoryIndex].drawingIndex !== undefined &&
                            terrainHistory[terrainHistoryIndex].drawingIndex !== -1) {
                            historyIndex = terrainHistory[terrainHistoryIndex].drawingIndex;
                        }
                    }
                } else if (drawingCanvas && drawingContext) {
                    drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    if (historyIndex >= 0 && drawingHistory[historyIndex]?.canvas) {
                        const canvas = drawingHistory[historyIndex].canvas;
                        if (canvas.width > 0 && canvas.height > 0) { // 確保畫布有尺寸
                            drawingContext.drawImage(canvas, 0, 0);
                        }
                        if (drawingHistory[historyIndex].terrainIndex !== undefined) {
                            terrainHistoryIndex = drawingHistory[historyIndex].terrainIndex;
                        }
                    }
                }
            } catch (error) {
                console.error("重繪畫布錯誤:", error);
            }
        }

        // 2D地圖繪圖工具初始化
        function initMapDrawingTools() {
            try {
                // 初始化 2D 地圖繪圖畫布
                mapDrawingCanvas = document.getElementById('map-drawing-canvas');
                mapDrawingContext = mapDrawingCanvas.getContext('2d');
                // 确保绘图画布与地图画布有相同的变换原点
                mapDrawingCanvas.style.transformOrigin = '0 0';

                // 設置畫布大小
                function resizeMapCanvas() {
                    const mapContainer = document.getElementById('map-container');
                    mapDrawingCanvas.width = mapContainer.offsetWidth;
                    mapDrawingCanvas.height = mapContainer.offsetHeight;

                    // 設置繪圖上下文屬性
                    mapDrawingContext.lineCap = 'round';
                    mapDrawingContext.lineJoin = 'round';
                    mapDrawingContext.lineWidth = 3;

                    // 重繪歷史內容
                    if (mapHistoryIndex >= 0 && mapDrawingHistory[mapHistoryIndex]) {
                        mapDrawingContext.drawImage(mapDrawingHistory[mapHistoryIndex], 0, 0);
                    }
                }

                // 初始調整畫布大小
                resizeMapCanvas();

                // 當窗口大小改變時重新調整
                window.addEventListener('resize', resizeMapCanvas);

                // 繪圖工具欄
                const mapDrawingToolbar = document.querySelector('.map-drawing-toolbar');

                // 繪圖事件變量
                let lastMapX = 0;
                let lastMapY = 0;

                // 取得事件坐標
                function getMapEventCoordinates(e) {
                    if (e.touches && e.touches[0]) {
                        const rect = mapDrawingCanvas.getBoundingClientRect();
                        return {
                            x: e.touches[0].clientX - rect.left,
                            y: e.touches[0].clientY - rect.top
                        };
                    }
                    return {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                }

                // 開始繪圖
                function startMapDraw(e) {
                    if (isProfileMode || isPolylineMode) return;

                    if (!document.querySelector('.map-color-btn.active') && !isMapErasing) return;

                    e.preventDefault();
                    e.stopPropagation();

                    isMapDrawing = true;
                    isDraggingMap = false;

                    const coords = getMapEventCoordinates(e);
                    [lastMapX, lastMapY] = [coords.x, coords.y];

                    // 設置繪圖模式
                    mapDrawingContext.globalCompositeOperation = isMapErasing ? 'destination-out' : 'source-over';
                    mapDrawingContext.lineWidth = isMapErasing ? document.getElementById('eraser-size').value * 2 : 3;

                    // 如果是第一次繪圖，保存初始空白狀態
                    if (mapHistoryIndex === -1) {
                        saveMapDrawingToHistory();
                    }
                }

                // 繪圖過程
                function mapDraw(e) {
                    if (!isMapDrawing) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const coords = getMapEventCoordinates(e);

                    mapDrawingContext.beginPath();
                    mapDrawingContext.moveTo(lastMapX, lastMapY);
                    mapDrawingContext.lineTo(coords.x, coords.y);
                    mapDrawingContext.strokeStyle = isMapErasing ? 'rgba(0,0,0,1)' : mapCurrentColor;
                    mapDrawingContext.stroke();

                    [lastMapX, lastMapY] = [coords.x, coords.y];
                }

                // 結束繪圖
                function stopMapDraw(e) {
                    if (isMapDrawing) {
                        e.preventDefault();
                        e.stopPropagation();

                        isMapDrawing = false;
                        saveMapDrawingToHistory();
                    }
                }

                // 保存繪圖歷史
                function saveMapDrawingToHistory() {
                    // 移除當前位置之後的歷史記錄
                    mapDrawingHistory = mapDrawingHistory.slice(0, mapHistoryIndex + 1);

                    // 創建新的畫布並複製當前內容
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = mapDrawingCanvas.width;
                    newCanvas.height = mapDrawingCanvas.height;

                    // 只有當畫布有尺寸時才複製
                    if (newCanvas.width > 0 && newCanvas.height > 0) {
                        newCanvas.getContext('2d').drawImage(mapDrawingCanvas, 0, 0);
                    }

                    // 添加到歷史記錄
                    mapDrawingHistory.push(newCanvas);
                    mapHistoryIndex++;
                }

                // 重繪畫布
                function redrawMapDrawing() {
                    mapDrawingContext.clearRect(0, 0, mapDrawingCanvas.width, mapDrawingCanvas.height);

                    if (mapHistoryIndex >= 0 && mapDrawingHistory[mapHistoryIndex]) {
                        const canvas = mapDrawingHistory[mapHistoryIndex];
                        if (canvas.width > 0 && canvas.height > 0) {
                            mapDrawingContext.drawImage(canvas, 0, 0);
                        }
                    }
                }

                // 添加事件監聽器
                mapDrawingCanvas.addEventListener('mousedown', startMapDraw);
                mapDrawingCanvas.addEventListener('mousemove', mapDraw);
                mapDrawingCanvas.addEventListener('mouseup', stopMapDraw);
                mapDrawingCanvas.addEventListener('mouseleave', stopMapDraw);

                // 觸控事件
                mapDrawingCanvas.addEventListener('touchstart', startMapDraw, { passive: false });
                mapDrawingCanvas.addEventListener('touchmove', mapDraw, { passive: false });
                mapDrawingCanvas.addEventListener('touchend', stopMapDraw, { passive: false });
                mapDrawingCanvas.addEventListener('touchcancel', stopMapDraw, { passive: false });

                // 添加橡皮擦範圍指示器
                const mapEraserIndicator = document.createElement('div');
                mapEraserIndicator.style.cssText = `
                    position: fixed;
                    pointer-events: none;
                    border: 2px solid rgba(0, 0, 0, 0.8);
                    border-radius: 50%;
                    display: none;
                    z-index: 1000;
                `;
                document.body.appendChild(mapEraserIndicator);

                // 更新橡皮擦指示器
                function updateMapEraserIndicator(e) {
                    if (isMapErasing) {
                        const size = document.getElementById('eraser-size').value * 2;
                        mapEraserIndicator.style.width = `${size}px`;
                        mapEraserIndicator.style.height = `${size}px`;
                        mapEraserIndicator.style.left = `${e.clientX - size/2}px`;
                        mapEraserIndicator.style.top = `${e.clientY - size/2}px`;
                        mapEraserIndicator.style.display = 'block';
                    } else {
                        mapEraserIndicator.style.display = 'none';
                    }
                }

                // 橡皮擦事件
                mapDrawingCanvas.addEventListener('mousemove', updateMapEraserIndicator);
                mapDrawingCanvas.addEventListener('mouseenter', updateMapEraserIndicator);
                mapDrawingCanvas.addEventListener('mouseleave', () => {
                    mapEraserIndicator.style.display = 'none';
                });

                // 繪圖按鈕點擊事件
                document.querySelectorAll('.map-color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // 如果當前顏色已選中，則取消選中
                        if (btn.classList.contains('active')) {
                            btn.classList.remove('active');
                            mapDrawingCanvas.style.pointerEvents = 'none';
                            isMapDrawing = false;
                            return;
                        }

                        // 重置其他工具狀態
                        resetMapDrawingTools();

                        // 設置新的繪圖狀態
                        document.querySelectorAll('.map-color-btn').forEach(b =>
                            b.classList.remove('active'));
                        btn.classList.add('active');
                        mapCurrentColor = btn.dataset.color;
                        isMapErasing = false;

                        const mapEraserBtn = document.getElementById('map-eraser-btn');
                        if (mapEraserBtn) mapEraserBtn.classList.remove('active');

                        // 啟用繪圖功能
                        mapDrawingCanvas.style.pointerEvents = 'auto';
                        mapDrawingCanvas.style.cursor = 'crosshair';
                    });
                });

                // 橡皮擦按鈕事件
                const mapEraserBtn = document.getElementById('map-eraser-btn');
                if (mapEraserBtn) {
                    mapEraserBtn.addEventListener('click', () => {
                        resetMapDrawingTools();

                        isMapErasing = !isMapErasing;
                        mapEraserBtn.classList.toggle('active');

                        if (isMapErasing) {
                            mapDrawingCanvas.style.pointerEvents = 'auto';
                            mapDrawingCanvas.style.cursor = 'crosshair';
                        } else {
                            mapDrawingCanvas.style.pointerEvents = 'none';
                            mapDrawingCanvas.style.cursor = 'default';
                        }
                    });
                }

                // 撤銷按鈕事件
                const mapUndoBtn = document.getElementById('map-undo-btn');
                if (mapUndoBtn) {
                    mapUndoBtn.addEventListener('click', () => {
                        if (mapHistoryIndex > 0) {
                            mapHistoryIndex--;
                            redrawMapDrawing();
                        }
                    });
                }

                // 重做按鈕事件
                const mapRedoBtn = document.getElementById('map-redo-btn');
                if (mapRedoBtn) {
                    mapRedoBtn.addEventListener('click', () => {
                        if (mapHistoryIndex < mapDrawingHistory.length - 1) {
                            mapHistoryIndex++;
                            redrawMapDrawing();
                        }
                    });
                }

                // 清除按鈕事件
                const mapClearBtn = document.getElementById('map-clear-btn');
                if (mapClearBtn) {
                    mapClearBtn.addEventListener('click', () => {
                        if (confirm('確定要清除所有繪圖內容嗎？')) {
                            mapDrawingContext.clearRect(0, 0, mapDrawingCanvas.width, mapDrawingCanvas.height);
                            mapDrawingHistory = [];
                            mapHistoryIndex = -1;
                            saveMapDrawingToHistory();
                        }
                    });
                }
            } catch (error) {
                console.error("初始化地圖繪圖工具錯誤:", error);
            }
        }

        // 重置2D地圖繪圖工具狀態
        function resetMapDrawingTools() {
            isMapDrawing = false;
            isMapErasing = false;

            // 重置按鈕狀態
            document.querySelectorAll('.map-drawing-toolbar .tool-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // 禁用繪圖功能
            const mapDrawingCanvas = document.getElementById('map-drawing-canvas');
            if (mapDrawingCanvas) {
                mapDrawingCanvas.style.pointerEvents = 'none';
                mapDrawingCanvas.style.cursor = 'default';
            }

            // 隱藏橡皮擦指示器
            const mapEraserIndicator = document.querySelector('div[style*="border-radius: 50%"]');
            if (mapEraserIndicator) {
                mapEraserIndicator.style.display = 'none';
            }
        }

        // 添加一個輔助函數來重置地形工具狀態
        function resetTerrainTools() {
            currentTool = null;
            isDrawing = false;  // 添加這行

            // 重置所有工具按鈕狀態（包括地形工具和繪圖工具）
            document.querySelectorAll('.tool-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // 停用繪圖功能
            drawingCanvas.style.pointerEvents = 'none';
            isErasing = false;

            // 啟用相機控制
            if (controls) controls.enabled = true;

            // 隱藏地形工具指示器
            if (radiusIndicator) radiusIndicator.visible = false;
            if (mouseHelper) mouseHelper.visible = false;

            // 隱藏橡皮擦指示器
            const eraserIndicator = document.querySelector('div[style*="border-radius: 50%"]');
            if (eraserIndicator) {
                eraserIndicator.style.display = 'none';
            }
        }

        // 添加2D地图的鼠标移动事件监听器
        mapCanvas.addEventListener('mousemove', (e) => {
            // 始终更新鼠标样式，确保整个画布都是grab样式
            if (!isDraggingMap && !isProfileMode && !isMapDrawing && !isMapErasing && !isPolylineMode) {
                mapCanvas.style.cursor = 'grab';
            }

            // 更新状态栏，即使在拖动状态也显示坐标
            if (isMapMode) {
                updateMapStatusBar(e);
            }
        });

        // 更新2D地图状态栏函数
        function updateMapStatusBar(event) {
            try {
                const mapCanvas = document.getElementById('map-canvas');
                const rect = mapCanvas.getBoundingClientRect();

                // 获取鼠标在视窗中的位置
                const clientX = event.clientX;
                const clientY = event.clientY;

                // 计算鼠标相对于变换后画布的位置
                const mouseX = clientX - rect.left;
                const mouseY = clientY - rect.top;

                // 因为画布是经过缩放和平移的，需要将鼠标坐标转回"画布坐标系"
                const canvasCenterX = mapCanvas.width / 2;
                const canvasCenterY = mapCanvas.height / 2;

                // 移除偏移并考虑缩放
                const withoutOffsetX = mouseX - mapOffset.x;
                const withoutOffsetY = mouseY - mapOffset.y;

                // 考虑缩放（相对于中心点）
                const transformedX = canvasCenterX + (withoutOffsetX - canvasCenterX) / currentScale;
                const transformedY = canvasCenterY + (withoutOffsetY - canvasCenterY) / currentScale;

                // 以下计算地形坐标
                const gridSegments = 100;
                const terrainSizeMeters = 100;

                // 计算基本绘制尺寸和偏移
                const maxSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                const pixelSize = maxSize / gridSegments;
                const offsetX = (mapCanvas.width - gridSegments * pixelSize) / 2;
                const offsetY = (mapCanvas.height - gridSegments * pixelSize) / 2;

                // 将画布坐标转换为地形坐标
                const terrainX = ((transformedX - offsetX) / pixelSize) * (terrainSizeMeters / gridSegments) - 50;
                const terrainZ = -((transformedY - offsetY) / pixelSize) * (terrainSizeMeters / gridSegments) + 50; {

                  // 从地形数据获取高度
                  const positions = terrain.geometry.attributes.position.array;

                  // 计算地形上的索引
                  const normalizedX = (terrainX + 50) / terrainSizeMeters * gridSegments;
                  const normalizedZ = (terrainZ + 50) / terrainSizeMeters * gridSegments;

                  // 使用双线性插值获取高度
                  const height = bilinearInterpolate(positions, gridSegments + 1, normalizedX, normalizedZ) * heightMultiplier;

                    // 计算六位数坐标
                    const gridSpacing = 25;
                    const eastingBase = 10;
                    const northingBase = 65;

                    // 将地形坐标转换为正数
                    const gridX = terrainX + 50;
                    const gridZ = terrainZ + 50;

                    // 1. 计算东行线编号（前两位数）
                    const eastingLineNumber = Math.floor(gridX / gridSpacing) + eastingBase;

                    // 2. 计算东行格网内的小行位置（第三位数）
                    let eastingOffset = gridX % gridSpacing;
                    let eastingSubLine = Math.floor((eastingOffset / gridSpacing) * 9) + 1;
                    if (eastingSubLine > 9) eastingSubLine = 9;

                    // 3. 计算北行线编号（后两位数）
                    const northingLineNumber = Math.floor(gridZ / gridSpacing) + northingBase;

                    // 4. 计算北行格网内的小行位置（第六位数）
                    let northingOffset = gridZ % gridSpacing;
                    let northingSubLine = Math.floor((northingOffset / gridSpacing) * 9) + 1;
                    if (northingSubLine > 9) northingSubLine = 9;

                    // 5. 组合六位数坐标
                    const eastingStr = String(eastingLineNumber).padStart(2, '0');
                    const eastingSubLineStr = String(eastingSubLine).padStart(1, '0');
                    const northingStr = String(northingLineNumber).padStart(2, '0');
                    const northingSubLineStr = String(northingSubLine).padStart(1, '0');

                    const gridCoordinate = `${eastingStr}${eastingSubLineStr}${northingStr}${northingSubLineStr}`;

                    // 计算坡度 - 在2D地图中我们需要使用相邻点来近似计算
                    let slope = 0;
                    try {
                        // 获取四个相邻点的高度
                        const x1 = Math.floor(normalizedX);
                        const x2 = Math.min(x1 + 1, gridSegments);
                        const z1 = Math.floor(normalizedZ);
                        const z2 = Math.min(z1 + 1, gridSegments);

                        const h1 = positions[(z1 * (gridSegments + 1) + x1) * 3 + 2] * heightMultiplier;
                        const h2 = positions[(z1 * (gridSegments + 1) + x2) * 3 + 2] * heightMultiplier;
                        const h3 = positions[(z2 * (gridSegments + 1) + x1) * 3 + 2] * heightMultiplier;
                        const h4 = positions[(z2 * (gridSegments + 1) + x2) * 3 + 2] * heightMultiplier;

                        // 计算 X 和 Z 方向的梯度
                        const dx = (h2 - h1) / (terrainSizeMeters / gridSegments);
                        const dz = (h3 - h1) / (terrainSizeMeters / gridSegments);

                        // 计算法向量
                        const normal = new THREE.Vector3(-dx, 1, -dz).normalize();

                        // 计算与垂直方向的夹角
                        slope = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0))) * (180 / Math.PI);
                    } catch (error) {
                        console.error("计算坡度错误:", error);
                        slope = 0;
                    }

                    // 更新状态栏
                    const statusBar = document.querySelector('.status-bar');
                    statusBar.textContent = `座標: ${gridCoordinate}, 高度: ${height.toFixed(1)}m | 坡度: ${slope.toFixed(1)}°`;
                }
            } catch (error) {
                console.error("更新2D地图状态栏错误:", error);
            }
        }

        function initMapMode() {
            try {
                const mapModeBtn = document.getElementById('map-mode-btn');
                const return3dBtn = document.getElementById('return-3d-btn');
                const measurementToolbar = document.querySelector('.measurement-toolbar');
                const terrainToolbar = document.querySelector('.terrain-toolbar');
                const drawingToolbar = document.querySelector('.drawing-toolbar');
                const mapDrawingToolbar = document.querySelector('.map-drawing-toolbar');
                const mapContainer = document.getElementById('map-container');
                const mapCanvas = document.getElementById('map-canvas');
                const polylineToggleBtn = document.getElementById('polyline-toggle'); //取得連線按鈕
                const polylineClearBtn = document.getElementById('polyline-clear');  //取得清除連線按鈕
                const profileToggleBtn = document.getElementById('profile-toggle'); // 取得縱剖面按鈕

                // 添加放大縮小按鈕的事件監聽
                const zoomInBtn = document.getElementById('zoom-in');
                const zoomOutBtn = document.getElementById('zoom-out');

                // 改進放大和縮小按鈕功能
                if (zoomInBtn) {
                  zoomInBtn.addEventListener('click', () => {
                      // 保存原始位置
                      const oldScale = currentScale;
                      // 放大 20%
                      currentScale *= 1.2;
                      // 調整偏移量，保持視圖中心
                      mapOffset.x = mapOffset.x * (currentScale / oldScale);
                      mapOffset.y = mapOffset.y * (currentScale / oldScale);

                      // 重新生成地图 (已包含纵剖面线绘制逻辑)
                      generate2DMap();
                  });
                }

                if (zoomOutBtn) {
                  zoomOutBtn.addEventListener('click', () => {
                      // 保存原始位置
                      const oldScale = currentScale;
                      // 縮小 20%
                      currentScale *= 0.8;
                      // 調整偏移量，保持視圖中心
                      mapOffset.x = mapOffset.x * (currentScale / oldScale);
                      mapOffset.y = mapOffset.y * (currentScale / oldScale);

                      // 重新生成地图 (已包含纵剖面线绘制逻辑)
                      generate2DMap();
                  });


                    // 确保地图容器可见且正确设置
                    if (mapContainer) {
                        mapContainer.style.position = 'absolute';
                        mapContainer.style.top = '0';
                        mapContainer.style.left = '0';
                        mapContainer.style.width = '100%';
                        mapContainer.style.height = '100%';
                        mapContainer.style.zIndex = '2';
                    }

                    // 确保地图画布可拖动
                    if (mapCanvas) {
                        mapCanvas.style.position = 'absolute';
                        mapCanvas.style.top = '0';
                        mapCanvas.style.left = '0';
                        mapCanvas.style.cursor = 'grab';
                    }

                    // 确保绘图画布不会拦截拖动事件
                    const mapDrawingCanvas = document.getElementById('map-drawing-canvas');
                    if (mapDrawingCanvas) {
                        mapDrawingCanvas.style.position = 'absolute';
                        mapDrawingCanvas.style.top = '0';
                        mapDrawingCanvas.style.left = '0';
                        mapDrawingCanvas.style.zIndex = '2';
                        mapDrawingCanvas.style.pointerEvents = 'none'; // 初始时禁用鼠标事件
                    }

                }

                // 滚轮缩放逻辑修改
                if (mapContainer) {
                  mapContainer.addEventListener('wheel', (e) => {
                      e.preventDefault();

                      // 保存原始位置
                      const oldScale = currentScale;

                      // 調整縮放比例
                      if (e.deltaY > 0) {
                          // 向下滾動，縮小
                          currentScale *= 0.9;
                      } else {
                          // 向上滾動，放大
                          currentScale *= 1.1;
                      }

                      // 限制縮放範圍
                      currentScale = Math.max(0.5, Math.min(currentScale, 3));

                      // 調整偏移量以保持視圖中心
                      mapOffset.x = mapOffset.x * (currentScale / oldScale);
                      mapOffset.y = mapOffset.y * (currentScale / oldScale);

                      // 重新生成地图 (已包含纵剖面线绘制逻辑)
                      generate2DMap();
                  });
                }

                if (!mapCanvas || !mapContainer) {
                    console.error('找不到地圖容器或畫布元素');
                    return;
                }

                if (!return3dBtn) {
                    console.error('找不到返回按鈕元素');
                    return;
                }

                return3dBtn.addEventListener('click', () => {
                    console.log('點擊返回按鈕');
                    isMapMode = false;
                    mapModeBtn.classList.remove('active');
                    renderer.domElement.style.display = 'block';
                    mapContainer.style.display = 'none';
                    measurementToolbar.style.display = 'none';
                    terrainToolbar.style.display = 'flex';
                    drawingToolbar.style.display = 'flex';
                    mapDrawingToolbar.style.display = 'none';
                    resetPolylineTool();
                    resetProfileTool();
                    resetMapDrawingTools();

                    // 重置状态栏
                    const statusBar = document.querySelector('.status-bar');
                    statusBar.textContent = '座標: X: 0, Y: 0, Z: 0 | 高度: 0m | 坡度: 0°';
                });

                mapModeBtn.addEventListener('click', () => {
                    try {
                        isMapMode = !isMapMode;
                        mapModeBtn.classList.toggle('active');

                        if (isMapMode) {
                            console.log('切換到地圖模式');
                            renderer.domElement.style.display = 'none';
                            mapContainer.style.display = 'block';
                            generate2DMap();
                            measurementToolbar.style.display = 'flex';
                            mapDrawingToolbar.style.display = 'flex';
                            terrainToolbar.style.display = 'none';
                            drawingToolbar.style.display = 'none';
                            resetTerrainTools();

                            // 重設高亮層
                            if (highlightCanvas) {
                                highlightContext.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                                highlightCanvas.style.display = 'block';
                            }
                        } else {
                            console.log('返回3D模式');
                            renderer.domElement.style.display = 'block';
                            mapContainer.style.display = 'none';
                            measurementToolbar.style.display = 'none';
                            mapDrawingToolbar.style.display = 'none';
                            terrainToolbar.style.display = 'flex';
                            drawingToolbar.style.display = 'flex';
                            resetProfileTool();
                            resetMapDrawingTools();

                            // 隱藏高亮層
                            if (highlightCanvas) {
                                highlightCanvas.style.display = 'none';
                            }
                        }
                    } catch (error) {
                        console.error('切換地圖模式時發生錯誤:', error);
                        alert('切換地圖模式時發生錯誤！');
                        isMapMode = false;
                        mapModeBtn.classList.remove('active');
                        renderer.domElement.style.display = 'block';
                        mapContainer.style.display = 'none';
                        measurementToolbar.style.display = 'none';
                        mapDrawingToolbar.style.display = 'none';
                        terrainToolbar.style.display = 'flex';
                        drawingToolbar.style.display = 'flex';
                    }
                }); // 这里添加正确的闭合括号


                // 多點連線按鈕事件
                if (polylineToggleBtn) {
                    polylineToggleBtn.addEventListener('click', () => {
                        isPolylineMode = !isPolylineMode;
                        resetTerrainTools(); // 重設其他工具
                        resetMapDrawingTools(); // 重設地圖繪圖工具
                        resetProfileTool(); // 重設縱剖面工具
                        polylineToggleBtn.classList.toggle('active');
                        if(isPolylineMode) {
                            mapCanvas.style.cursor = 'crosshair'; //改變滑鼠樣式
                            hideProtractor();
                        } else {
                            mapCanvas.style.cursor = 'default';
                        }
                    });
                }

                // 創建高亮點覆蓋層畫布
                highlightCanvas = document.createElement('canvas');
                highlightCanvas.style.position = 'absolute';
                highlightCanvas.style.top = '0';
                highlightCanvas.style.left = '0';
                highlightCanvas.style.pointerEvents = 'none'; // 不攔截鼠標事件
                highlightCanvas.style.zIndex = '3'; // 確保在其他畫布上方
                mapContainer.appendChild(highlightCanvas);
                highlightContext = highlightCanvas.getContext('2d');

                // 清除連線按鈕事件
                if (polylineClearBtn) {
                    polylineClearBtn.addEventListener('click', () => {
                        resetPolylineTool();
                    });
                }

                // 創建高亮點覆蓋層畫布
                highlightCanvas = document.createElement('canvas');
                highlightCanvas.style.position = 'absolute';
                highlightCanvas.style.top = '0';
                highlightCanvas.style.left = '0';
                highlightCanvas.style.pointerEvents = 'none'; // 不攔截鼠標事件
                highlightCanvas.style.zIndex = '3'; // 確保在其他畫布上方
                mapContainer.appendChild(highlightCanvas);
                highlightContext = highlightCanvas.getContext('2d');

                mapCanvas.addEventListener('click', handleMapClick);
                polylineLayer = document.createElement('canvas');
                polylineLayer.style.position = 'absolute';
                polylineLayer.style.top = '0';
                polylineLayer.style.left = '0';
                document.getElementById('map-container').appendChild(polylineLayer);
            } catch (error) {
                console.error("初始化地圖模式錯誤:", error);
            }
        }

        function resetRulerTool() {
            // 這是臨時的空實現，以防止出錯
            console.log("重置尺規工具");
        }

        function resetProtractorTool() {
            hideProtractor();
        }

        function resetPolylineTool() {
            polylinePoints = [];
            totalDistance = 0;
            isPolylineMode = false;
            const polylineToggleBtn = document.getElementById('polyline-toggle');
            if(polylineToggleBtn) polylineToggleBtn.classList.remove('active');

            const mapCanvas = document.getElementById('map-canvas');
            if (mapCanvas) mapCanvas.style.cursor = 'default';
            updateStatusBarWithDistance(0);  // 重置距離資訊
            generate2DMap(); // 清除圖層後，重新繪製地圖
        }

        function handleMapClick(event) {
            // 如果在縱剖面模式中，改用縱剖面處理函數
            if (isProfileMode) {
                try {
                    handleProfileClick(event);
                } catch (error) {
                    console.error("縱剖面點擊處理錯誤:", error);
                }
                return;
            }

            // 如果在繪圖模式，跳過連線點添加
            if (isMapDrawing || document.querySelector('.map-color-btn.active') || isMapErasing) {
                return;
            }

            if (!isPolylineMode) return;
             const mapCanvas = document.getElementById('map-canvas');
             if (!mapCanvas) return;

             const rect = mapCanvas.getBoundingClientRect();
             // 获取屏幕点击坐标
             const screenX = event.clientX - rect.left;
             const screenY = event.clientY - rect.top;

             // 地图中心点
             const canvasCenterX = mapCanvas.width / 2;
             const canvasCenterY = mapCanvas.height / 2;

             // 计算转换后的坐标（考虑地图的偏移和缩放）
             // 1. 移除偏移影响
             const withoutOffsetX = screenX - mapOffset.x;
             const withoutOffsetY = screenY - mapOffset.y;

             // 2. 考虑缩放（相对于中心点）
             const transformedX = canvasCenterX + (withoutOffsetX - canvasCenterX) / currentScale;
             const transformedY = canvasCenterY + (withoutOffsetY - canvasCenterY) / currentScale;

             // 保存原始坐标和变换后的坐标
             polylinePoints.push({
                 screenX: screenX,
                 screenY: screenY,
                 transformedX: transformedX,
                 transformedY: transformedY
             });

             // 重新繪製地圖和連線
             generate2DMap();
             calculateDistance();
         }

        function displayDistance(context, offsetX, offsetY) {
            let accumulatedDistance = 0;
            for (let i = 0; i < polylinePoints.length - 1; i++) {
                const p1 = polylinePoints[i];
                const p2 = polylinePoints[i + 1];
                const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                // 使用全局的 pixelSize 並考慮 currentScale
                const distance = dist / (pixelSize * currentScale);
                accumulatedDistance += distance;
            }

            if (polylinePoints.length < 2 || accumulatedDistance === 0) return; // 確保有兩個點

            context.font = 'bold 16px Arial';
            context.fillStyle = 'black';
            context.textAlign = 'left';
            context.textBaseline = 'top';
            context.fillText(`${accumulatedDistance.toFixed(1)} m`, offsetX, offsetY + 10);
        }

        function calculateDistance() {
            totalDistance = 0;
            if (polylinePoints.length < 2) {
                updateStatusBarWithDistance(totalDistance); // 確保沒有點時也更新狀態欄
                return;
            }

            for (let i = 0; i < polylinePoints.length - 1; i++) {
                const p1 = polylinePoints[i];
                const p2 = polylinePoints[i + 1];

                // 使用变换后的坐标计算距离
                const dist = Math.hypot(
                    p2.transformedX - p1.transformedX,
                    p2.transformedY - p1.transformedY
                );

                // 使用全局的 pixelSize 計算實際距離
                const distance = dist / pixelSize;
                totalDistance += distance;
            }
            updateStatusBarWithDistance(totalDistance); // 更新状态栏
        }

        function updateStatusBarWithDistance(distance) {
            const statusBar = document.querySelector('.status-bar');
            const originalText = statusBar.textContent.split('|')[0]; // 保留原本的狀態資訊
            const distanceText = ` | 連線距離: ${distance.toFixed(1)}m`;

            statusBar.textContent = originalText + distanceText;
        }

        function drawPolyline(context, offsetX, offsetY) {
            if (polylinePoints.length < 2) return;

            // 保存上下文状态
            context.save();

            context.strokeStyle = 'red';
            context.lineWidth = 2;

            context.beginPath();
            // 使用变换后的坐标绘制线条
            context.moveTo(polylinePoints[0].transformedX, polylinePoints[0].transformedY);
            for (let i = 1; i < polylinePoints.length; i++) {
                context.lineTo(polylinePoints[i].transformedX, polylinePoints[i].transformedY);
            }
            context.stroke();

            // 繪製每個點，讓使用者知道他們點擊的位置
            context.fillStyle = 'black';
            for (let i = 0; i < polylinePoints.length; i++) {
                context.beginPath();
                context.arc(
                    polylinePoints[i].transformedX,
                    polylinePoints[i].transformedY,
                    4 / currentScale, // 根据缩放调整点的大小
                    0,
                    2 * Math.PI
                );
                context.fill();
            }

            // 恢复上下文状态
            context.restore();
        }

        function getHeightColor(height, minHeight, maxHeight) {
            // 計算標準化高度 (0-1範圍)
            const normalizedHeight = (height - minHeight) / (maxHeight - minHeight);

            // 定義顏色區間
            const colors = [
                { height: 0, color: { r: 0, g: 70, b: 255 } },     // 深藍（水）
                { height: 0.2, color: { r: 0, g: 159, b: 0 } },    // 深綠（低地）
                { height: 0.4, color: { r: 85, g: 255, b: 0 } },   // 淺綠（平原）
                { height: 0.6, color: { r: 255, g: 255, b: 0 } },  // 黃色（丘陵）
                { height: 0.8, color: { r: 160, g: 82, b: 45 } },  // 棕色（山地）
                { height: 1, color: { r: 255, g: 250, b: 250 } }   // 白色（山頂）
            ];

            // 找出當前高度所在的區間
            let i = 0;
            while (i < colors.length - 1 && normalizedHeight > colors[i + 1].height) {
                i++;
            }

            // 在兩個顏色之間進行插值
            const lowerColor = colors[i].color;
            const upperColor = colors[i + 1].color;
            const rangePct = (normalizedHeight - colors[i].height) /
                            (colors[i + 1].height - colors[i].height);

            // 計算插值後的顏色
            return {
                r: Math.floor(lowerColor.r + (upperColor.r - lowerColor.r) * rangePct),
                g: Math.floor(lowerColor.g + (upperColor.g - lowerColor.g) * rangePct),
                b: Math.floor(lowerColor.b + (upperColor.b - lowerColor.b) * rangePct)
            };
        }

        function generate2DMap() {
            try {
                console.time('generate2DMap');

                // 獲取畫布和上下文
                const mapCanvas = document.getElementById('map-canvas');
                const mapContext = mapCanvas.getContext('2d');
                const mapContainer = document.getElementById('map-container');

                // 獲取調試標誌
                const debugMode = document.getElementById('debug-water-boundary').checked;

                // 設置畫布尺寸
                mapCanvas.width = mapContainer.offsetWidth;
                mapCanvas.height = mapContainer.offsetHeight;

                // 同步更新其他畫布尺寸
                if (mapDrawingCanvas) {
                    mapDrawingCanvas.width = mapCanvas.width;
                    mapDrawingCanvas.height = mapCanvas.height;

                    if (mapHistoryIndex >= 0 && mapDrawingHistory[mapHistoryIndex]) {
                        const mapDrawingContext = mapDrawingCanvas.getContext('2d');
                        mapDrawingContext.drawImage(mapDrawingHistory[mapHistoryIndex], 0, 0);
                    }
                }

                if (highlightCanvas) {
                    highlightCanvas.width = mapCanvas.width;
                    highlightCanvas.height = mapCanvas.height;
                    highlightCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
                }

                // 清除整個畫布並設置為純白色
                mapContext.fillStyle = '#ffffff';
                mapContext.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

                // 保存畫布狀態並應用變換
                mapContext.save();
                mapContext.translate(mapOffset.x, mapOffset.y);
                mapContext.translate(mapCanvas.width / 2, mapCanvas.height / 2);
                mapContext.scale(currentScale, currentScale);
                mapContext.translate(-mapCanvas.width / 2, -mapCanvas.height / 2);

                // 計算地圖繪製參數
                const positions = terrain.geometry.attributes.position.array;
                const gridSegments = 100;
                const gridSize = gridSegments + 1;

                // 計算畫布上的繪製尺寸
                const maxSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                pixelSize = maxSize / gridSegments;
                const offsetX = (mapCanvas.width - gridSegments * pixelSize) / 2;
                const offsetY = (mapCanvas.height - gridSegments * pixelSize) / 2;

                // 創建統一的高度數據網格
                const heightData = createUnifiedHeightGrid(positions, gridSize);

                // 先繪製一個完全純白的背景矩形 (覆蓋整個地圖區域)
                mapContext.fillStyle = '#ffffff';
                mapContext.fillRect(offsetX, offsetY, gridSegments * pixelSize, gridSegments * pixelSize);

                // 如果未啟用調試模式，只繪製等高線；否則繪製地形顏色
                if (!debugMode) {
                    // 只繪製等高線，不渲染地形顏色
                    drawOnlyContours(mapContext, heightData, offsetX, offsetY, pixelSize);
                } else {
                    // 調試模式：完整渲染地形顏色和等高線
                    if (typeof drawExactContours === 'function') {
                        drawExactContours(mapContext, heightData, offsetX, offsetY, pixelSize);
                    } else {
                        console.warn('drawExactContours 函數不存在，使用替代方法');
                        drawSmoothContours(mapContext, positions, gridSize, heightData.minHeight, heightData.maxHeight, offsetX, offsetY, pixelSize);
                    }
                }

                // 繪製網格和其他元素
                drawGrid(mapContext, gridSegments, offsetX, offsetY, pixelSize, 25);
                drawScaleBar(mapContext, offsetX, offsetY + gridSegments * pixelSize + 30, gridSegments, pixelSize);

                // 繪製標記
                drawMarkersOnMap(mapContext, offsetX, offsetY, pixelSize);

                // 繪製連線和剖面點
                if (isPolylineMode) {
                    drawPolyline(mapContext, offsetX, offsetY);
                }

                if (isProfileMode && profilePoints.length > 0) {
                    if (profilePoints.length === 2) {
                        // 只调用drawProfileLine，因为它已经包含了绘制点的逻辑
                        drawProfileLine();
                    } else if (profilePoints.length === 1) {
                        // 只绘制第一个点
                        drawProfilePoints(mapContext);
                    }
                }

                // 恢復畫布狀態
                mapContext.restore();

                // 更新繪圖畫布位置
                if (mapDrawingCanvas) {
                    mapDrawingCanvas.style.transform = `translate(${mapOffset.x}px, ${mapOffset.y}px)`;
                }

                console.timeEnd('generate2DMap');
            } catch (error) {
                console.error('生成地圖時發生錯誤:', error);
            }
        }

        // 新增專門只繪製等高線的函數，不渲染任何地形顏色
        function drawOnlyContours(context, heightData, offsetX, offsetY, pixelSize) {
            try {
                // 等高線繪製設置
                const contourInterval = 20; // 20米等高線間隔
                const zeroLineWidth = 1.5;  // 0米等高線寬度
                const majorLineWidth = 1.5; // 主等高線寬度
                const minorLineWidth = 0.8; // 次等高線寬度

                // 設置線條樣式
                context.lineCap = 'round';
                context.lineJoin = 'round';

                // 儲存等高線點
                const contourPoints = new Map();
                const gridSize = heightData.grid.length;

                // 掃描所有網格單元尋找等高線交點
                for (let y = 0; y < gridSize - 1; y++) {
                    for (let x = 0; x < gridSize - 1; x++) {
                        // 獲取單元格四個角的高度
                        const z1 = heightData.grid[y][x];
                        const z2 = heightData.grid[y][x+1];
                        const z3 = heightData.grid[y+1][x];
                        const z4 = heightData.grid[y+1][x+1];

                        // 找出單元格內的最低和最高高度
                        const minZ = Math.min(z1, z2, z3, z4);
                        const maxZ = Math.max(z1, z2, z3, z4);

                        // 計算單元格內經過的所有等高線高度
                        const startHeight = Math.floor(minZ / contourInterval) * contourInterval;
                        const endHeight = Math.ceil(maxZ / contourInterval) * contourInterval;

                        // 處理每一條可能的等高線
                        for (let h = startHeight; h <= endHeight; h += contourInterval) {
                            // 初始化高度對應的點集合
                            if (!contourPoints.has(h)) {
                                contourPoints.set(h, []);
                            }

                            // 檢查四條邊是否與該等高線相交
                            let points = [];

                            // 左邊
                            if ((z1 <= h && h <= z3) || (z3 <= h && h <= z1)) {
                                const t = Math.abs(z3 - z1) < 0.0001 ? 0.5 : (h - z1) / (z3 - z1);
                                points.push({
                                    x: offsetX + x * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }

                            // 右邊
                            if ((z2 <= h && h <= z4) || (z4 <= h && h <= z2)) {
                                const t = Math.abs(z4 - z2) < 0.0001 ? 0.5 : (h - z2) / (z4 - z2);
                                points.push({
                                    x: offsetX + (x + 1) * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }

                            // 上邊
                            if ((z1 <= h && h <= z2) || (z2 <= h && h <= z1)) {
                                const t = Math.abs(z2 - z1) < 0.0001 ? 0.5 : (h - z1) / (z2 - z1);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + y * pixelSize
                                });
                            }

                            // 下邊
                            if ((z3 <= h && h <= z4) || (z4 <= h && h <= z3)) {
                                const t = Math.abs(z4 - z3) < 0.0001 ? 0.5 : (h - z3) / (z4 - z3);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + (y + 1) * pixelSize
                                });
                            }

                            // 只添加有2個交點的線段
                            if (points.length === 2) {
                                contourPoints.get(h).push(points);
                            }
                        }
                    }
                }

                // 繪製所有等高線
                contourPoints.forEach((pointSets, height) => {
                    // 判斷等高線類型
                    const isMajorContour = Math.abs(height) % 100 === 0;
                    const isZeroContour = Math.abs(height) < contourInterval / 2;
                    const isDepthContour = height < 0 && !isZeroContour; // 水下等深線

                    // 設置線條樣式
                    context.beginPath();
                    // 根據高度設置不同顏色
                    if (isZeroContour) {
                        context.strokeStyle = '#000000'; // 0米等高線保持黑色
                    } else if (isDepthContour) {
                        context.strokeStyle = '#87CEEB'; // 等深線設為淺藍色
                    } else {
                        context.strokeStyle = '#8b4513'; // 等高線保持鞍褐色
                    }
                    context.lineWidth = isZeroContour ? zeroLineWidth : (isMajorContour ? majorLineWidth : minorLineWidth);

          // 繪製該高度的所有線段
          pointSets.forEach(points => {
              context.moveTo(points[0].x, points[0].y);
              context.lineTo(points[1].x, points[1].y);
          });

          context.stroke();

          // 為主要等高線/等深線添加標籤
          if ((isMajorContour || isZeroContour) && pointSets.length > 0) {

                        // 選擇最長線段作為標籤位置
                        let longestSegment = pointSets[0];
                        let maxLength = 0;

                        pointSets.forEach(points => {
                            const length = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
                            if (length > maxLength) {
                                maxLength = length;
                                longestSegment = points;
                            }
                        });

                        // 計算標籤位置和角度
                        const midX = (longestSegment[0].x + longestSegment[1].x) / 2;
                        const midY = (longestSegment[0].y + longestSegment[1].y) / 2;
                        const angle = Math.atan2(
                            longestSegment[1].y - longestSegment[0].y,
                            longestSegment[1].x - longestSegment[0].x
                        );

                        // 繪製標籤
                        context.save();
                        context.translate(midX, midY);

                        // 調整文字方向
                        if (angle > Math.PI/2 || angle < -Math.PI/2) {
                            context.rotate(angle + Math.PI);
                        } else {
                            context.rotate(angle);
                        }

                        // 準備文字
                        let text;
                        if (height < 0) {
                            text = `${Math.abs(height)}m`;  // 等深線顯示為正數
                        } else {
                            text = `${height}m`;
                        }
                        const metrics = context.measureText(text);

                        // 繪製背景
                        context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        context.fillRect(
                            -metrics.width/2 - 3,
                            -10,
                            metrics.width + 6,
                            18
                        );

                        // 繪製文字
                        if (isZeroContour) {
                            context.fillStyle = '#000000'; // 0米標籤為黑色
                        } else if (isDepthContour) {
                            context.fillStyle = '#87CEEB'; // 等深線標籤為淺藍色
                        } else {
                            context.fillStyle = '#8b4513'; // 等高線標籤為鞍褐色
                        }
                        context.font = 'bold 12px Arial';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(text, 0, 0);

                        context.restore();
                    }
                });
            } catch (error) {
                console.error('繪製等高線時發生錯誤:', error);
            }
        }

        function renderTerrainWithExactCoordinates(context, heightData, offsetX, offsetY, pixelSize, gridSegments) {
            // 地形顏色渲染和等高線繪製使用完全相同的座標系統

            // 1. 先在離屏畫布上渲染地形顏色
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = gridSegments * pixelSize;
            offscreenCanvas.height = gridSegments * pixelSize;
            const offscreenContext = offscreenCanvas.getContext('2d');

            // 使用精確的像素映射
            for (let y = 0; y < gridSegments; y++) {
                for (let x = 0; x < gridSegments; x++) {
                    // 確保每個網格單元使用統一的座標計算
                    const subSize = pixelSize + 0.5; // 防止像素間隙

                    // 使用網格中心點的高度值確定顏色
                    const height = exactInterpolate(heightData.grid, x + 0.5, y + 0.5);
                    const color = getExactColor(height, heightData.minHeight, heightData.maxHeight);

                    // 填充網格單元
                    offscreenContext.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    offscreenContext.fillRect(x * pixelSize, y * pixelSize, subSize, subSize);
                }
            }

            // 將顏色層複製到主畫布
            context.drawImage(offscreenCanvas, offsetX, offsetY);

            // 2. 使用相同的高度資料繪製等高線
            drawContours(context, heightData, offsetX, offsetY, pixelSize);
        }

        // 新的統一高度數據創建函數
        function createUnifiedHeightGrid(positions, gridSize) {
            const grid = new Array(gridSize);
            let minHeight = Infinity;
            let maxHeight = -Infinity;
            const heightOffset = 0.01; // 添加0.01米的偏移量

            // 填充網格並計算高度範圍
            for (let y = 0; y < gridSize; y++) {
                grid[y] = new Array(gridSize);
                for (let x = 0; x < gridSize; x++) {
                    // 從3D模型中獲取確切的高度值，確保索引計算一致
                    const idx = (y * gridSize + x) * 3 + 2;
                    const originalHeight = positions[idx] * heightMultiplier;

                    // 對陸地部分添加偏移（只對大於等於0的高度值添加偏移）
                    const adjustedHeight = originalHeight >= 0 ? originalHeight + heightOffset : originalHeight;

                    grid[y][x] = adjustedHeight;
                    minHeight = Math.min(minHeight, adjustedHeight);
                    maxHeight = Math.max(maxHeight, adjustedHeight);
                }
            }

            return { grid, minHeight, maxHeight };
        }

        function bilinearInterpolate(positions, gridSize, x, y) {
            // 确保坐标在网格范围内
            const clampedX = Math.max(0, Math.min(x, gridSize - 1.001));
            const clampedY = Math.max(0, Math.min(y, gridSize - 1.001));

            // 获取插值点周围的四个网格点坐标
            const x0 = Math.floor(clampedX);
            const y0 = Math.floor(clampedY);
            const x1 = Math.min(x0 + 1, gridSize - 1);
            const y1 = Math.min(y0 + 1, gridSize - 1);

            // 计算插值权重
            const wx = clampedX - x0;
            const wy = clampedY - y0;

            // 获取四个角的高度值
            const h00 = positions[(y0 * gridSize + x0) * 3 + 2];
            const h10 = positions[(y0 * gridSize + x1) * 3 + 2];
            const h01 = positions[(y1 * gridSize + x0) * 3 + 2];
            const h11 = positions[(y1 * gridSize + x1) * 3 + 2];

            // 双线性插值计算
            const h0 = h00 * (1 - wx) + h10 * wx;
            const h1 = h01 * (1 - wx) + h11 * wx;

            return h0 * (1 - wy) + h1 * wy;
        }

        function drawMarkersOnMap(context, offsetX, offsetY, pixelSize) {
            markers.forEach(marker => {
                const mapCanvas = document.getElementById('map-canvas');
                const centerX = mapCanvas.width / 2;
                const centerY = mapCanvas.height / 2;
                const terrainSizeMeters = 100;  // 地形尺寸（公尺）
                const gridSegments = 100; //網格數
                const mapSize = Math.min(mapCanvas.width, mapCanvas.height) * 0.8;
                pixelSize = mapSize / gridSegments; // 使用 gridSegments
                // 取得地形的世界中心點
                const terrainCenter = new THREE.Vector3(0, 0, 0);
                terrain.localToWorld(terrainCenter);

                // 將標註的世界坐標轉換為以中心為基準的座標
                const relativePosition = marker.position.clone().sub(terrainCenter);


                // 將3D世界座標轉換為2D地圖座標 (旋轉90度)
                const mapX = (relativePosition.x  / terrainSizeMeters * gridSegments * pixelSize) + offsetX + (gridSegments * pixelSize) /2 ;
                const mapY = (relativePosition.z / terrainSizeMeters * gridSegments * pixelSize) + offsetY + (gridSegments * pixelSize) /2 ;



                // 繪製標註點（可根據需要修改樣式）
                context.fillStyle = 'red';
                context.beginPath();
                context.arc(mapX, mapY, 4 * currentScale, 0, 2 * Math.PI);
                context.fill();

                // 繪製標籤
                context.font = `${10 * currentScale}px Arial`; // 調整字體大小
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.textBaseline = 'bottom';
                const text = marker.label;
                context.fillText(text, mapX, mapY - 8 * currentScale); //  讓標籤在點的上方
            });
        }

        function drawSmoothContours(context, positions, gridSize, minHeight, maxHeight, offsetX, offsetY, pixelSize) {
            try {
                // 設置固定的等高線間距為20米
                const contourInterval = 20;  // 直接設為20米

                // 設置等高線樣式
                context.lineCap = 'round';
                context.lineJoin = 'round';

                // 創建一個用於存儲等高線點的數組
                let contourPoints = new Map();

                // 遍歷每個網格單元
                for (let y = 0; y < gridSize - 1; y++) {
                    for (let x = 0; x < gridSize - 1; x++) {
                        // 在drawSmoothContours函数中
                        // 获取网格四个角的高度并乘以倍数因子
                        const z1 = positions[(y * gridSize + x) * 3 + 2] * heightMultiplier;
                        const z2 = positions[(y * gridSize + x + 1) * 3 + 2] * heightMultiplier;
                        const z3 = positions[((y + 1) * gridSize + x) * 3 + 2] * heightMultiplier;
                        const z4 = positions[((y + 1) * gridSize + x + 1) * 3 + 2] * heightMultiplier;

                        // 計算這個網格中應該經過的等高線
                        const minZ = Math.min(z1, z2, z3, z4);
                        const maxZ = Math.max(z1, z2, z3, z4);

                        // 對於每個可能的等高線高度
                        for (let h = Math.floor(minZ / contourInterval) * contourInterval;
                             h <= maxZ;
                             h += contourInterval) {

                            if (!contourPoints.has(h)) {
                                contourPoints.set(h, []);
                            }

                            // 在網格邊緣尋找等高線交點
                            let points = [];

                            // 檢查四個邊
                            // 左邊
                            if ((z1 <= h && h <= z3) || (z3 <= h && h <= z1)) {
                                const t = (h - z1) / (z3 - z1);
                                points.push({
                                    x: offsetX + x * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }
                            // 右邊
                            if ((z2 <= h && h <= z4) || (z4 <= h && h <= z2)) {
                                const t = (h - z2) / (z4 - z2);
                                points.push({
                                    x: offsetX + (x + 1) * pixelSize,
                                    y: offsetY + (y + t) * pixelSize
                                });
                            }
                            // 上邊
                            if ((z1 <= h && h <= z2) || (z2 <= h && h <= z1)) {
                                const t = (h - z1) / (z2 - z1);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + y * pixelSize
                                });
                            }
                            // 下邊
                            if ((z3 <= h && h <= z4) || (z4 <= h && h <= z3)) {
                                const t = (h - z3) / (z4 - z3);
                                points.push({
                                    x: offsetX + (x + t) * pixelSize,
                                    y: offsetY + (y + 1) * pixelSize
                                });
                            }

                            if (points.length === 2) {
                                contourPoints.get(h).push(points);
                            }
                        }
                    }
                }

                // 繪製所有等高線
                contourPoints.forEach((pointSets, height) => {
                    // 每100米（5個間隔）作為主等高線
                    const isMajorContour = Math.round(height / 100) * 100 === height;

                    context.beginPath();
                    context.strokeStyle = 'black'; // 設定為黑色
                    context.lineWidth = isMajorContour ? 2 : 1; // 主等高線 2px, 次等高線 1px

                    pointSets.forEach(points => {
                        context.moveTo(points[0].x, points[0].y);
                        context.lineTo(points[1].x, points[1].y);
                    });

                    context.stroke();

                    // 為主等高線添加高度標籤（每條等高線只顯示一次）
                    if (isMajorContour && pointSets.length > 0) {
                        // 選擇最長的線段來放置標籤
                        let longestSegment = pointSets[0];
                        let maxLength = 0;

                        pointSets.forEach(points => {
                            const length = Math.hypot(
                                points[1].x - points[0].x,
                                points[1].y - points[0].y
                            );
                            if (length > maxLength) {
                                maxLength = length;
                                longestSegment = points;
                            }
                        });

                        // 在最長線段的中點放置標籤
                        const midX = (longestSegment[0].x + longestSegment[1].x) / 2;
                        const midY = (longestSegment[0].y + longestSegment[1].y) / 2;

                        // 計算線段的角度
                        const angle = Math.atan2(
                            longestSegment[1].y - longestSegment[0].y,
                            longestSegment[1].x - longestSegment[0].x
                        );

                        // 保存當前上下文狀態
                        context.save();

                        // 移動到標籤位置並旋轉
                        context.translate(midX, midY);
                        if (angle > Math.PI/2 || angle < -Math.PI/2) {
                            context.rotate(angle + Math.PI);
                        } else {
                            context.rotate(angle);
                        }

                        // 設置標籤樣式
                        context.font = 'bold 10px Arial';
                        context.fillStyle = 'rgba(101, 67, 33, 0.9)';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';

                        // 繪製白色背景
                        const text = Math.round(height) + 'm';
                        const metrics = context.measureText(text);
                        context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        context.fillRect(
                            -metrics.width/2 - 2,
                            -6,
                            metrics.width + 4,
                            12
                        );

                        // 繪製文字
                        context.fillStyle = 'rgba(101, 67, 33, 0.9)';
                        context.fillText(text, 0, 0);

                        // 恢復上下文狀態
                        context.restore();
                    }
                });

            } catch (error) {
                console.error('繪製等高線時發生錯誤:', error);
            }
        }

        // 雙線性插值函數
        // 改進雙線性插值函數（增加快取）
        const interpolationCache = new Map(); // 全局快取

        // 新的統一插值函數
        function unifiedInterpolate(grid, x, y) {
            const gridSize = grid.length;

            // 確保座標在有效範圍內
            const safeX = Math.max(0, Math.min(x, gridSize - 1.001));
            const safeY = Math.max(0, Math.min(y, gridSize - 1.001));

            // 取得四個最近的網格點
            const x1 = Math.floor(safeX);
            const x2 = Math.min(x1 + 1, gridSize - 1);
            const y1 = Math.floor(safeY);
            const y2 = Math.min(y1 + 1, gridSize - 1);

            // 計算插值權重
            const wx = safeX - x1;
            const wy = safeY - y1;

            // 雙線性插值計算
            const h11 = grid[y1][x1];
            const h21 = grid[y1][x2];
            const h12 = grid[y2][x1];
            const h22 = grid[y2][x2];

            return h11 * (1-wx) * (1-wy) + h21 * wx * (1-wy) + h12 * (1-wx) * wy + h22 * wx * wy;
        }

        function renderTerrainColors(context, heightData, offsetX, offsetY, pixelSize, gridSegments) {
            // 使用离屏画布提高性能
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = gridSegments * pixelSize;
            offscreenCanvas.height = gridSegments * pixelSize;
            const offscreenContext = offscreenCanvas.getContext('2d');

            const resolution = 2; // 降低分辨率以提高性能
            const subPixelSize = pixelSize / resolution;

            // 逐像素渲染地形颜色
            for (let y = 0; y < gridSegments; y++) {
                for (let x = 0; x < gridSegments; x++) {
                    for (let subY = 0; subY < resolution; subY++) {
                        for (let subX = 0; subX < resolution; subX++) {
                            // 计算精确位置
                            const fx = x + subX / resolution;
                            const fy = y + subY / resolution;

                            // 使用统一插值函数计算高度
                            const height = exactInterpolate(heightData.grid, fx, fy, heightData.grid.length);

                            // 严格映射高度到颜色
                            const color = getExactTerrainColor(height, heightData.minHeight, heightData.maxHeight);

                            // 填充像素
                            offscreenContext.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                            offscreenContext.fillRect(
                                x * pixelSize + subX * subPixelSize,
                                y * pixelSize + subY * subPixelSize,
                                subPixelSize,
                                subPixelSize
                            );
                        }
                    }
                }
            }

            // 将离屏画布复制到主画布
            context.drawImage(offscreenCanvas, offsetX, offsetY);
        }


        // 繪製等高線
        function drawContourLine(context, positions, gridSize, height, offsetX, offsetY, pixelSize) {
            context.beginPath();
            let isFirstPoint = true;

            for (let y = 0; y < gridSize - 1; y++) {
                for (let x = 0; x < gridSize - 1; x++) {
                    const idx = (y * gridSize + x) * 3;
                    const h = positions[idx + 2];

                    if (Math.abs(h - height) < 0.1) {
                        if (isFirstPoint) {
                            context.moveTo(offsetX + x * pixelSize, offsetY + y * pixelSize);
                            isFirstPoint = false;
                        } else {
                            context.lineTo(offsetX + x * pixelSize, offsetY + y * pixelSize);
                        }
                    }
                }
            }
            context.stroke();
        }

        // 繪製網格
        function drawGrid(context, gridSegments, offsetX, offsetY, pixelSize, gridIntervalMeters) {
            const totalSize = gridSegments * pixelSize;
            const gridCount = 4;
            const gridLines = gridSegments / gridCount;
            const eastingLabels = [];
            for (let i = 10; i < 10 + (gridCount + 1); i++) { // 從10開始
                eastingLabels.push(String(i).padStart(2, '0'));
            }

            const northingLabels = [];
            for (let i = 65; i < 65 + (gridCount + 1); i++) {
                northingLabels.push(String(i).padStart(2, '0'));
            }
            northingLabels.reverse();

            context.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            context.lineWidth = 1;

            for (let i = 0; i <= gridSegments; i += gridLines) {
                context.beginPath();
                context.moveTo(offsetX + i * pixelSize, offsetY);
                context.lineTo(offsetX + i * pixelSize, offsetY + totalSize);
                context.stroke();

                context.beginPath();
                context.moveTo(offsetX, offsetY + i * pixelSize);
                context.lineTo(offsetX + totalSize, offsetY + i * pixelSize);
                context.stroke();

                // 添加格網編號
                context.fillStyle = 'black';
                context.font = 'bold 16px Arial';

                const labelIndex = Math.round(i / gridLines);

                // 東行線數字位置：在上方
                context.fillText(
                    eastingLabels[labelIndex],
                    offsetX + i * pixelSize - 6,
                    offsetY - 20
                );

                // 北行線數字位置：在左方
                context.fillText(
                    northingLabels[labelIndex],
                    offsetX - 30,
                    offsetY + i * pixelSize + 6
                );
            }
        }

        // 繪製比例尺
        function drawScaleBar(context, x, y, gridSegments, pixelSize) {
            const scaleHeight = 3;
            const totalMeters = 100; // 地圖總寬度（米）
            const gridCount = 4;
            const gridInterval = totalMeters / gridCount;

            // 地圖總寬度（像素）
            const mapWidthPixels = gridSegments * pixelSize;

            // 繪製比例尺背景
            context.fillStyle = 'rgba(255, 255, 255, 0.8)';
            context.fillRect(x - 5, y - 5, mapWidthPixels + 10, 35);

            // 繪製比例尺主線
            context.fillStyle = 'black';
            context.fillRect(x, y, mapWidthPixels, scaleHeight);

            // 繪製刻度與標籤
            for (let i = 0; i <= gridCount; i++) {
                const xPos = x + (mapWidthPixels / gridCount) * i;

                // 繪製刻度線
                context.fillRect(xPos, y - 5, 1, 15);

                // 繪製刻度標籤
                context.font = '12px Arial';
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.fillText(`${gridInterval * i}m`, xPos, y + 20);
            }
        }

        function drawDebugInfo(context) {
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0); // 重置變換
            context.font = '12px Arial';
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillText(`Scale: ${currentScale.toFixed(2)}, Offset: X=${mapOffset.x.toFixed(0)}, Y=${mapOffset.y.toFixed(0)}`, 10, 20);
            context.restore();
        }

        // 在generate2DMap函數結尾處調用
        drawDebugInfo(mapContext);

        function animate() {
            requestAnimationFrame(animate);
            if (isMouseDown && currentTool) {
                modifyTerrain(); // 確保在滑鼠按住時持續更新地形
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrain);
                if (intersects.length > 0) {
                    updateRadiusIndicator(intersects[0].point);
                } else {
                    radiusIndicator.visible = false;
                    mouseHelper.visible = false;
                }
            }
            // 移動設備的控制邏輯
            if (isMobile && joystickActive) {
                const moveSpeed = 1.0;

                // 獲取相機前方向和右方向
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(forward);
                right.crossVectors(forward, camera.up).normalize();

                // 將前方向投影到水平面上
                forward.y = 0;
                forward.normalize();

                // 根據搖桿位置移動相機
                const moveX = currentJoystickPos.x * moveSpeed;
                const moveZ = -currentJoystickPos.y * moveSpeed;

                camera.position.addScaledVector(right, moveX);
                camera.position.addScaledVector(forward, moveZ);
                controls.target.addScaledVector(right, moveX);
                controls.target.addScaledVector(forward, moveZ);
            }

            // 原有的鍵盤控制邏輯保持不變
            if (!isMobile) {
                const moveSpeed = 1.0;
                const rotateSpeed = 0.02;

                // 獲取相機前方向和右方向
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(forward);
                right.crossVectors(forward, camera.up).normalize();

                // 將前方向投影到水平面上
                forward.y = 0;
                forward.normalize();

                // WASD 移動
                if (keys.w) {
                    camera.position.addScaledVector(forward, moveSpeed);
                    controls.target.addScaledVector(forward, moveSpeed);
                }
                if (keys.s) {
                    camera.position.addScaledVector(forward, -moveSpeed);
                    controls.target.addScaledVector(forward, -moveSpeed);
                }
                if (keys.a) {
                    camera.position.addScaledVector(right, -moveSpeed);
                    controls.target.addScaledVector(right, -moveSpeed);
                }
                if (keys.d) {
                    camera.position.addScaledVector(right, moveSpeed);
                    controls.target.addScaledVector(right, moveSpeed);
                }

                // Z/C 調整視角
                if (keys.z) {
                    // 向上旋轉（降低視角）
                    const rotation = new THREE.Quaternion().setFromAxisAngle(right, rotateSpeed);
                    const cameraToTarget = camera.position.clone().sub(controls.target);
                    cameraToTarget.applyQuaternion(rotation);
                    camera.position.copy(controls.target).add(cameraToTarget);
                    camera.lookAt(controls.target);
                }
                if (keys.c) {
                    // 向下旋轉（提高視角）
                    const rotation = new THREE.Quaternion().setFromAxisAngle(right, -rotateSpeed);
                    const cameraToTarget = camera.position.clone().sub(controls.target);
                    cameraToTarget.applyQuaternion(rotation);
                    camera.position.copy(controls.target).add(cameraToTarget);
                    camera.lookAt(controls.target);
                }
            }
            updateMarkerPositions(); //每次都更新標註位置
            controls.update();
            renderer.render(scene, camera);
        }

        // 新增的輔助函數
        function get3DPointFromMouse(coords) {
            // 將滑鼠座標轉換為 3D 空間中的點
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((coords.x - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((coords.y - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            const intersects = raycaster.intersectObject(terrain);

            if (intersects.length > 0) {
                return intersects[0].point.clone();
            }
            return null;
        }

        function update3DTube() {
            if (drawingPoints.length < 2) return;

            // 創建平滑的曲線
            const curve = new THREE.CatmullRomCurve3(drawingPoints);

            // 創建管狀幾何體
            const tubeGeometry = new THREE.TubeGeometry(
                curve,
                drawingPoints.length * 10, // 分段數
                0.3, // 管道半徑
                8, // 管道截面分段數
                false // 是否閉合
            );

            // 創建材質
            const tubeMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(currentColor),
                metalness: 0.3,
                roughness: 0.7,
            });

            // 創建新的網格並加入場景
            const newTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(newTube);

            // 更新當前繪製中的管狀物體
            if (tube3DMesh) {
                scene.remove(tube3DMesh);
            }
            tube3DMesh = newTube;
        }

        renderer.domElement.addEventListener('click', (event) => {
            if (is3DDrawingMode && isErasing) {
                const rect = renderer.domElement.getBoundingClientRect();
                const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
                const intersects = raycaster.intersectObjects(tube3DMeshes);

                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    scene.remove(mesh);
                    const index = tube3DMeshes.indexOf(mesh);
                    if (index > -1) {
                        tube3DMeshes.splice(index, 1);
                        save3DHistory();
                    }
                }
            }
        });

        // 修改 3D 線條的歷史記錄管理
        function save3DHistory() {
            // 創建當前場景中所有 3D 線條的深度拷貝
            const currentState = tube3DMeshes.map(mesh => ({
                geometry: mesh.geometry.clone(),
                material: mesh.material.clone(),
                position: mesh.position.clone(),
                rotation: mesh.rotation.clone(),
                scale: mesh.scale.clone()
            }));

            // 清除後面的歷史記錄
            tube3DMeshHistory = tube3DMeshHistory.slice(0, tube3DMeshHistoryIndex + 1);
            tube3DMeshHistory.push(currentState);
            tube3DMeshHistoryIndex++;
        }
    </script>
</body>
</html>
